"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/react.tsx
var react_exports = {};
__export(react_exports, {
  useDropzone: () => useDropzone
});
module.exports = __toCommonJS(react_exports);
var import_react = require("react");
var import_file_selector = require("file-selector");

// src/core.ts
var import_attr_accept = __toESM(require("attr-accept"));
var accepts = (
  // @ts-expect-error - ESM interop
  typeof import_attr_accept.default === "function" ? import_attr_accept.default : import_attr_accept.default.default
);
function isFileAccepted(file, accept) {
  return file.type === "application/x-moz-file" || accepts(file, accept);
}
function isEnterOrSpace(event) {
  return "key" in event && (event.key === " " || event.key === "Enter") || "keyCode" in event && (event.keyCode === 32 || event.keyCode === 13);
}
var isDefined = (v) => v != null;
function isValidSize(file, minSize, maxSize) {
  if (!isDefined(file.size))
    return true;
  if (isDefined(minSize) && isDefined(maxSize)) {
    return file.size >= minSize && file.size <= maxSize;
  }
  if (isDefined(minSize) && file.size < minSize)
    return false;
  if (isDefined(maxSize) && file.size > maxSize)
    return false;
  return true;
}
function isValidQuantity(files, multiple, maxFiles) {
  if (!multiple && files.length > 1)
    return false;
  if (multiple && maxFiles >= 1 && files.length > maxFiles)
    return false;
  return true;
}
function allFilesAccepted({
  files,
  accept,
  minSize,
  maxSize,
  multiple,
  maxFiles
}) {
  if (!isValidQuantity(files, multiple, maxFiles))
    return false;
  return files.every(
    (file) => isFileAccepted(file, accept) && isValidSize(file, minSize, maxSize)
  );
}
function isEventWithFiles(event) {
  var _a;
  if (!("dataTransfer" in event && event.dataTransfer !== null)) {
    return !!event.target && "files" in event.target && !!event.target.files;
  }
  return Array.prototype.some.call(
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    (_a = event.dataTransfer) == null ? void 0 : _a.types,
    (type) => type === "Files" || type === "application/x-moz-file"
  );
}
function isIeOrEdge(ua = window.navigator.userAgent) {
  return ua.indexOf("MSIE ") > -1 || ua.indexOf("Trident/") > -1 || ua.indexOf("Edge/") > -1;
}
function isMIMEType(v) {
  return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
  return /^.*\.[\w]+$/.test(v);
}
function acceptPropAsAcceptAttr(accept) {
  if (isDefined(accept)) {
    return Object.entries(accept).reduce((a, [mimeType, ext]) => [...a, mimeType, ...ext], []).filter((v) => isMIMEType(v) || isExt(v)).join(",");
  }
  return void 0;
}
function noop() {
}
var initialState = {
  isFocused: false,
  isFileDialogActive: false,
  isDragActive: false,
  isDragAccept: false,
  isDragReject: false,
  acceptedFiles: []
};
function reducer(state, action) {
  switch (action.type) {
    case "focus":
      return {
        ...state,
        isFocused: true
      };
    case "blur":
      return {
        ...state,
        isFocused: false
      };
    case "openDialog":
      return {
        ...initialState,
        isFileDialogActive: true
      };
    case "closeDialog":
      return {
        ...state,
        isFileDialogActive: false
      };
    case "setDraggedFiles":
      return {
        ...state,
        ...action.payload
      };
    case "setFiles":
      return {
        ...state,
        ...action.payload
      };
    case "reset":
      return initialState;
    default:
      return state;
  }
}

// src/react.tsx
function useDropzone({
  accept,
  disabled = false,
  maxSize = Number.POSITIVE_INFINITY,
  minSize = 0,
  multiple = true,
  maxFiles = 0,
  onDrop
}) {
  const acceptAttr = (0, import_react.useMemo)(() => acceptPropAsAcceptAttr(accept), [accept]);
  const rootRef = (0, import_react.useRef)(null);
  const inputRef = (0, import_react.useRef)(null);
  const dragTargetsRef = (0, import_react.useRef)([]);
  const [state, dispatch] = (0, import_react.useReducer)(reducer, initialState);
  (0, import_react.useEffect)(() => {
    const onWindowFocus = () => {
      if (state.isFileDialogActive) {
        setTimeout(() => {
          if (inputRef.current) {
            const { files } = inputRef.current;
            if (!(files == null ? void 0 : files.length)) {
              dispatch({ type: "closeDialog" });
            }
          }
        }, 300);
      }
    };
    window.addEventListener("focus", onWindowFocus, false);
    return () => {
      window.removeEventListener("focus", onWindowFocus, false);
    };
  }, [state.isFileDialogActive]);
  (0, import_react.useEffect)(() => {
    const onDocumentDrop = (event) => {
      var _a;
      if ((_a = rootRef.current) == null ? void 0 : _a.contains(event.target))
        return;
      event.preventDefault();
      dragTargetsRef.current = [];
    };
    const onDocumentDragOver = (e) => e.preventDefault();
    document.addEventListener("dragover", onDocumentDragOver, false);
    document.addEventListener("drop", onDocumentDrop, false);
    return () => {
      document.removeEventListener("dragover", onDocumentDragOver);
      document.removeEventListener("drop", onDocumentDrop);
    };
  }, []);
  const onDragEnter = (0, import_react.useCallback)(
    (event) => {
      event.preventDefault();
      event.persist();
      dragTargetsRef.current = [...dragTargetsRef.current, event.target];
      if (isEventWithFiles(event)) {
        Promise.resolve((0, import_file_selector.fromEvent)(event)).then((files) => {
          if (event.isPropagationStopped())
            return;
          const fileCount = files.length;
          const isDragAccept = fileCount > 0 && allFilesAccepted({
            files,
            accept: acceptAttr,
            minSize,
            maxSize,
            multiple,
            maxFiles
          });
          const isDragReject = fileCount > 0 && !isDragAccept;
          dispatch({
            type: "setDraggedFiles",
            payload: {
              isDragAccept,
              isDragReject,
              isDragActive: true
            }
          });
        }).catch(noop);
      }
    },
    [acceptAttr, maxFiles, maxSize, minSize, multiple]
  );
  const onDragOver = (0, import_react.useCallback)((event) => {
    event.preventDefault();
    event.persist();
    const hasFiles = isEventWithFiles(event);
    if (hasFiles && event.dataTransfer !== null) {
      try {
        event.dataTransfer.dropEffect = "copy";
      } catch {
        noop();
      }
    }
    return false;
  }, []);
  const onDragLeave = (0, import_react.useCallback)((event) => {
    event.preventDefault();
    event.persist();
    const targets = dragTargetsRef.current.filter(
      (target) => {
        var _a;
        return (_a = rootRef.current) == null ? void 0 : _a.contains(target);
      }
    );
    const targetIdx = targets.indexOf(event.target);
    if (targetIdx !== -1)
      targets.splice(targetIdx, 1);
    dragTargetsRef.current = targets;
    if (targets.length > 0)
      return;
    dispatch({
      type: "setDraggedFiles",
      payload: {
        isDragActive: false,
        isDragAccept: false,
        isDragReject: false
      }
    });
  }, []);
  const setFiles = (0, import_react.useCallback)(
    (files) => {
      const acceptedFiles = [];
      files.forEach((file) => {
        const accepted = isFileAccepted(file, acceptAttr);
        const sizeMatch = isValidSize(file, minSize, maxSize);
        if (accepted && sizeMatch) {
          acceptedFiles.push(file);
        }
      });
      if (!isValidQuantity(acceptedFiles, multiple, maxFiles)) {
        acceptedFiles.splice(0);
      }
      dispatch({
        type: "setFiles",
        payload: {
          acceptedFiles
        }
      });
      onDrop(acceptedFiles);
    },
    [acceptAttr, maxFiles, maxSize, minSize, multiple, onDrop]
  );
  const onDropCb = (0, import_react.useCallback)(
    (event) => {
      event.preventDefault();
      event.persist();
      dragTargetsRef.current = [];
      if (isEventWithFiles(event)) {
        Promise.resolve((0, import_file_selector.fromEvent)(event)).then((files) => {
          if (event.isPropagationStopped())
            return;
          setFiles(files);
        }).catch(noop);
      }
      dispatch({ type: "reset" });
    },
    [setFiles]
  );
  const openFileDialog = (0, import_react.useCallback)(() => {
    if (inputRef.current) {
      dispatch({ type: "openDialog" });
      inputRef.current.value = "";
      inputRef.current.click();
    }
  }, []);
  const onKeyDown = (0, import_react.useCallback)(
    (event) => {
      var _a;
      if (!((_a = rootRef.current) == null ? void 0 : _a.isEqualNode(event.target)))
        return;
      if (isEnterOrSpace(event)) {
        event.preventDefault();
        openFileDialog();
      }
    },
    [openFileDialog]
  );
  const onInputElementClick = (0, import_react.useCallback)((e) => {
    e.stopPropagation();
  }, []);
  const onFocus = (0, import_react.useCallback)(() => dispatch({ type: "focus" }), []);
  const onBlur = (0, import_react.useCallback)(() => dispatch({ type: "blur" }), []);
  const onClick = (0, import_react.useCallback)(() => {
    isIeOrEdge() ? setTimeout(openFileDialog, 0) : openFileDialog();
  }, [openFileDialog]);
  const getRootProps = (0, import_react.useMemo)(
    () => () => ({
      ref: rootRef,
      role: "presentation",
      ...!disabled ? {
        tabIndex: 0,
        onKeyDown,
        onFocus,
        onBlur,
        onClick,
        onDragEnter,
        onDragOver,
        onDragLeave,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        onDrop: onDropCb
      } : {}
    }),
    [
      disabled,
      onBlur,
      onClick,
      onDragEnter,
      onDragLeave,
      onDragOver,
      onDropCb,
      onFocus,
      onKeyDown
    ]
  );
  const getInputProps = (0, import_react.useMemo)(
    () => () => ({
      ref: inputRef,
      type: "file",
      style: { display: "none" },
      accept: acceptAttr,
      multiple,
      tabIndex: -1,
      ...!disabled ? {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        onChange: onDropCb,
        onClick: onInputElementClick
      } : {}
    }),
    [acceptAttr, multiple, onDropCb, onInputElementClick, disabled]
  );
  return {
    ...state,
    getRootProps,
    getInputProps,
    rootRef
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useDropzone
});
//# sourceMappingURL=react.js.map