import {
  acceptPropAsAcceptAttr,
  allFilesAccepted,
  initialState,
  isEnterOrSpace,
  isEventWithFiles,
  isFileAccepted,
  isIeOrEdge,
  isValidQuantity,
  isValidSize,
  noop,
  reducer
} from "./chunk-UFRRDKQV.mjs";

// src/react.tsx
import { useCallback, useEffect, useMemo, useReducer, useRef } from "react";
import { fromEvent } from "file-selector";
function useDropzone({
  accept,
  disabled = false,
  maxSize = Number.POSITIVE_INFINITY,
  minSize = 0,
  multiple = true,
  maxFiles = 0,
  onDrop
}) {
  const acceptAttr = useMemo(() => acceptPropAsAcceptAttr(accept), [accept]);
  const rootRef = useRef(null);
  const inputRef = useRef(null);
  const dragTargetsRef = useRef([]);
  const [state, dispatch] = useReducer(reducer, initialState);
  useEffect(() => {
    const onWindowFocus = () => {
      if (state.isFileDialogActive) {
        setTimeout(() => {
          if (inputRef.current) {
            const { files } = inputRef.current;
            if (!(files == null ? void 0 : files.length)) {
              dispatch({ type: "closeDialog" });
            }
          }
        }, 300);
      }
    };
    window.addEventListener("focus", onWindowFocus, false);
    return () => {
      window.removeEventListener("focus", onWindowFocus, false);
    };
  }, [state.isFileDialogActive]);
  useEffect(() => {
    const onDocumentDrop = (event) => {
      var _a;
      if ((_a = rootRef.current) == null ? void 0 : _a.contains(event.target))
        return;
      event.preventDefault();
      dragTargetsRef.current = [];
    };
    const onDocumentDragOver = (e) => e.preventDefault();
    document.addEventListener("dragover", onDocumentDragOver, false);
    document.addEventListener("drop", onDocumentDrop, false);
    return () => {
      document.removeEventListener("dragover", onDocumentDragOver);
      document.removeEventListener("drop", onDocumentDrop);
    };
  }, []);
  const onDragEnter = useCallback(
    (event) => {
      event.preventDefault();
      event.persist();
      dragTargetsRef.current = [...dragTargetsRef.current, event.target];
      if (isEventWithFiles(event)) {
        Promise.resolve(fromEvent(event)).then((files) => {
          if (event.isPropagationStopped())
            return;
          const fileCount = files.length;
          const isDragAccept = fileCount > 0 && allFilesAccepted({
            files,
            accept: acceptAttr,
            minSize,
            maxSize,
            multiple,
            maxFiles
          });
          const isDragReject = fileCount > 0 && !isDragAccept;
          dispatch({
            type: "setDraggedFiles",
            payload: {
              isDragAccept,
              isDragReject,
              isDragActive: true
            }
          });
        }).catch(noop);
      }
    },
    [acceptAttr, maxFiles, maxSize, minSize, multiple]
  );
  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.persist();
    const hasFiles = isEventWithFiles(event);
    if (hasFiles && event.dataTransfer !== null) {
      try {
        event.dataTransfer.dropEffect = "copy";
      } catch {
        noop();
      }
    }
    return false;
  }, []);
  const onDragLeave = useCallback((event) => {
    event.preventDefault();
    event.persist();
    const targets = dragTargetsRef.current.filter(
      (target) => {
        var _a;
        return (_a = rootRef.current) == null ? void 0 : _a.contains(target);
      }
    );
    const targetIdx = targets.indexOf(event.target);
    if (targetIdx !== -1)
      targets.splice(targetIdx, 1);
    dragTargetsRef.current = targets;
    if (targets.length > 0)
      return;
    dispatch({
      type: "setDraggedFiles",
      payload: {
        isDragActive: false,
        isDragAccept: false,
        isDragReject: false
      }
    });
  }, []);
  const setFiles = useCallback(
    (files) => {
      const acceptedFiles = [];
      files.forEach((file) => {
        const accepted = isFileAccepted(file, acceptAttr);
        const sizeMatch = isValidSize(file, minSize, maxSize);
        if (accepted && sizeMatch) {
          acceptedFiles.push(file);
        }
      });
      if (!isValidQuantity(acceptedFiles, multiple, maxFiles)) {
        acceptedFiles.splice(0);
      }
      dispatch({
        type: "setFiles",
        payload: {
          acceptedFiles
        }
      });
      onDrop(acceptedFiles);
    },
    [acceptAttr, maxFiles, maxSize, minSize, multiple, onDrop]
  );
  const onDropCb = useCallback(
    (event) => {
      event.preventDefault();
      event.persist();
      dragTargetsRef.current = [];
      if (isEventWithFiles(event)) {
        Promise.resolve(fromEvent(event)).then((files) => {
          if (event.isPropagationStopped())
            return;
          setFiles(files);
        }).catch(noop);
      }
      dispatch({ type: "reset" });
    },
    [setFiles]
  );
  const openFileDialog = useCallback(() => {
    if (inputRef.current) {
      dispatch({ type: "openDialog" });
      inputRef.current.value = "";
      inputRef.current.click();
    }
  }, []);
  const onKeyDown = useCallback(
    (event) => {
      var _a;
      if (!((_a = rootRef.current) == null ? void 0 : _a.isEqualNode(event.target)))
        return;
      if (isEnterOrSpace(event)) {
        event.preventDefault();
        openFileDialog();
      }
    },
    [openFileDialog]
  );
  const onInputElementClick = useCallback((e) => {
    e.stopPropagation();
  }, []);
  const onFocus = useCallback(() => dispatch({ type: "focus" }), []);
  const onBlur = useCallback(() => dispatch({ type: "blur" }), []);
  const onClick = useCallback(() => {
    isIeOrEdge() ? setTimeout(openFileDialog, 0) : openFileDialog();
  }, [openFileDialog]);
  const getRootProps = useMemo(
    () => () => ({
      ref: rootRef,
      role: "presentation",
      ...!disabled ? {
        tabIndex: 0,
        onKeyDown,
        onFocus,
        onBlur,
        onClick,
        onDragEnter,
        onDragOver,
        onDragLeave,
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        onDrop: onDropCb
      } : {}
    }),
    [
      disabled,
      onBlur,
      onClick,
      onDragEnter,
      onDragLeave,
      onDragOver,
      onDropCb,
      onFocus,
      onKeyDown
    ]
  );
  const getInputProps = useMemo(
    () => () => ({
      ref: inputRef,
      type: "file",
      style: { display: "none" },
      accept: acceptAttr,
      multiple,
      tabIndex: -1,
      ...!disabled ? {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        onChange: onDropCb,
        onClick: onInputElementClick
      } : {}
    }),
    [acceptAttr, multiple, onDropCb, onInputElementClick, disabled]
  );
  return {
    ...state,
    getRootProps,
    getInputProps,
    rootRef
  };
}
export {
  useDropzone
};
//# sourceMappingURL=react.mjs.map