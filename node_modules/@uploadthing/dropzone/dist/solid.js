"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/solid.tsx
var solid_exports = {};
__export(solid_exports, {
  createDropzone: () => createDropzone
});
module.exports = __toCommonJS(solid_exports);
var import_file_selector = require("file-selector");
var import_solid_js = require("solid-js");
var import_store = require("solid-js/store");

// src/core.ts
var import_attr_accept = __toESM(require("attr-accept"));
var accepts = (
  // @ts-expect-error - ESM interop
  typeof import_attr_accept.default === "function" ? import_attr_accept.default : import_attr_accept.default.default
);
function isFileAccepted(file, accept) {
  return file.type === "application/x-moz-file" || accepts(file, accept);
}
function isEnterOrSpace(event) {
  return "key" in event && (event.key === " " || event.key === "Enter") || "keyCode" in event && (event.keyCode === 32 || event.keyCode === 13);
}
var isDefined = (v) => v != null;
function isValidSize(file, minSize, maxSize) {
  if (!isDefined(file.size))
    return true;
  if (isDefined(minSize) && isDefined(maxSize)) {
    return file.size >= minSize && file.size <= maxSize;
  }
  if (isDefined(minSize) && file.size < minSize)
    return false;
  if (isDefined(maxSize) && file.size > maxSize)
    return false;
  return true;
}
function isValidQuantity(files, multiple, maxFiles) {
  if (!multiple && files.length > 1)
    return false;
  if (multiple && maxFiles >= 1 && files.length > maxFiles)
    return false;
  return true;
}
function allFilesAccepted({
  files,
  accept,
  minSize,
  maxSize,
  multiple,
  maxFiles
}) {
  if (!isValidQuantity(files, multiple, maxFiles))
    return false;
  return files.every(
    (file) => isFileAccepted(file, accept) && isValidSize(file, minSize, maxSize)
  );
}
function isEventWithFiles(event) {
  var _a;
  if (!("dataTransfer" in event && event.dataTransfer !== null)) {
    return !!event.target && "files" in event.target && !!event.target.files;
  }
  return Array.prototype.some.call(
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    (_a = event.dataTransfer) == null ? void 0 : _a.types,
    (type) => type === "Files" || type === "application/x-moz-file"
  );
}
function isIeOrEdge(ua = window.navigator.userAgent) {
  return ua.indexOf("MSIE ") > -1 || ua.indexOf("Trident/") > -1 || ua.indexOf("Edge/") > -1;
}
function isMIMEType(v) {
  return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
  return /^.*\.[\w]+$/.test(v);
}
function acceptPropAsAcceptAttr(accept) {
  if (isDefined(accept)) {
    return Object.entries(accept).reduce((a, [mimeType, ext]) => [...a, mimeType, ...ext], []).filter((v) => isMIMEType(v) || isExt(v)).join(",");
  }
  return void 0;
}
function noop() {
}
var initialState = {
  isFocused: false,
  isFileDialogActive: false,
  isDragActive: false,
  isDragAccept: false,
  isDragReject: false,
  acceptedFiles: []
};

// src/solid.tsx
function createDropzone(_props) {
  const props = (0, import_solid_js.mergeProps)(
    {
      disabled: false,
      maxSize: Number.POSITIVE_INFINITY,
      minSize: 0,
      multiple: true,
      maxFiles: 0
    },
    _props
  );
  const acceptAttr = (0, import_solid_js.createMemo)(() => acceptPropAsAcceptAttr(props.accept));
  const [rootRef, setRootRef] = (0, import_solid_js.createSignal)();
  const [inputRef, setInputRef] = (0, import_solid_js.createSignal)();
  let dragTargets = [];
  const [state, setState] = (0, import_store.createStore)(initialState);
  (0, import_solid_js.createEffect)(() => {
    const onWindowFocus = () => {
      if (state.isFileDialogActive) {
        setTimeout(() => {
          const input = inputRef();
          if (input) {
            const { files } = input;
            if (!(files == null ? void 0 : files.length)) {
              setState("isFileDialogActive", false);
            }
          }
        }, 300);
      }
    };
    window.addEventListener("focus", onWindowFocus, false);
    (0, import_solid_js.onCleanup)(() => {
      window.removeEventListener("focus", onWindowFocus, false);
    });
  });
  (0, import_solid_js.createEffect)(() => {
    const onDocumentDrop = (event) => {
      const root = rootRef();
      if (root && root.contains(event.target)) {
        return;
      }
      event.preventDefault();
      dragTargets = [];
    };
    const onDocumentDragOver = (e) => e.preventDefault();
    document.addEventListener("dragover", onDocumentDragOver, false);
    document.addEventListener("drop", onDocumentDrop, false);
    (0, import_solid_js.onCleanup)(() => {
      document.removeEventListener("dragover", onDocumentDragOver, false);
      document.removeEventListener("drop", onDocumentDrop, false);
    });
  });
  function isPropagationStopped(event) {
    if (typeof event.cancelBubble !== "undefined") {
      return event.cancelBubble;
    }
    return false;
  }
  const onDragEnter = (event) => {
    event.preventDefault();
    event.stopPropagation();
    dragTargets = [...dragTargets, event.target];
    if (isEventWithFiles(event)) {
      Promise.resolve((0, import_file_selector.fromEvent)(event)).then((files) => {
        if (isPropagationStopped(event))
          return;
        const fileCount = files.length;
        const isDragAccept = fileCount > 0 && allFilesAccepted({
          files,
          accept: acceptAttr(),
          minSize: props.minSize,
          maxSize: props.maxSize,
          multiple: props.multiple,
          maxFiles: props.maxFiles
        });
        const isDragReject = fileCount > 0 && !isDragAccept;
        setState({
          isDragAccept,
          isDragReject,
          isDragActive: true
        });
      }).catch(noop);
    }
  };
  const onDragOver = (event) => {
    event.preventDefault();
    event.stopPropagation();
    const hasFiles = isEventWithFiles(event);
    if (hasFiles && event.dataTransfer) {
      try {
        event.dataTransfer.dropEffect = "copy";
      } catch {
        noop();
      }
    }
    return false;
  };
  const onDragLeave = (event) => {
    event.preventDefault();
    event.stopPropagation();
    const root = rootRef();
    const targets = dragTargets.filter((target) => root == null ? void 0 : root.contains(target));
    const targetIdx = targets.indexOf(event.target);
    if (targetIdx !== -1) {
      targets.splice(targetIdx, 1);
    }
    dragTargets = targets;
    if (targets.length > 0) {
      return;
    }
    setState({
      isDragActive: false,
      isDragAccept: false,
      isDragReject: false
    });
  };
  const setFiles = (files) => {
    var _a;
    const acceptedFiles = [];
    files.forEach((file) => {
      const accepted = isFileAccepted(file, acceptAttr());
      const sizeMatch = isValidSize(file, props.minSize, props.maxSize);
      if (accepted && sizeMatch) {
        acceptedFiles.push(file);
      }
    });
    if (isValidQuantity(acceptedFiles, props.multiple, props.maxFiles)) {
      acceptedFiles.splice(0);
    }
    setState({
      acceptedFiles
    });
    (_a = props.onDrop) == null ? void 0 : _a.call(props, acceptedFiles);
  };
  const onDrop = (event) => {
    event.preventDefault();
    event.stopPropagation();
    dragTargets = [];
    if (isEventWithFiles(event)) {
      Promise.resolve((0, import_file_selector.fromEvent)(event)).then((files) => {
        if (isPropagationStopped(event)) {
          return;
        }
        setFiles(files);
      }).catch(noop);
    }
    setState(initialState);
  };
  const openFileDialog = () => {
    const input = inputRef();
    if (input) {
      setState("isFileDialogActive", true);
      input.value = "";
      input.click();
    }
  };
  const onKeyDown = (event) => {
    const root = rootRef();
    if (!root || !root.isEqualNode(event.target)) {
      return;
    }
    if (isEnterOrSpace(event)) {
      event.preventDefault();
      openFileDialog();
    }
  };
  const onInputElementClick = (event) => {
    event.stopPropagation();
  };
  const onFocus = () => setState("isFocused", true);
  const onBlur = () => setState("isFocused", false);
  const onClick = () => () => {
    isIeOrEdge() ? setTimeout(openFileDialog, 0) : openFileDialog();
  };
  const getRootProps = () => ({
    ref: setRootRef,
    role: "presentation",
    ...!props.disabled ? {
      tabIndex: 0,
      onKeyDown,
      onFocus,
      onBlur,
      onClick,
      onDragEnter,
      onDragOver,
      onDragLeave,
      onDrop
    } : {}
  });
  const getInputProps = () => ({
    ref: setInputRef,
    type: "file",
    style: { display: "none" },
    accept: acceptAttr(),
    multiple: props.multiple,
    tabIndex: -1,
    ...!props.disabled ? {
      onChange: onDrop,
      onClick: onInputElementClick
    } : {}
  });
  return (0, import_solid_js.mergeProps)(state, {
    getInputProps,
    getRootProps,
    rootRef: setRootRef,
    inputRef: setInputRef
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createDropzone
});
//# sourceMappingURL=solid.js.map