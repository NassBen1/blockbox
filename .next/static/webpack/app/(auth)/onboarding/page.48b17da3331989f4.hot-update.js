"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(auth)/onboarding/page",{

/***/ "(app-pages-browser)/./node_modules/@remix-run/router/dist/router.js":
/*!*******************************************************!*\
  !*** ./node_modules/@remix-run/router/dist/router.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: function() { return /* binding */ AbortedDeferredError; },\n/* harmony export */   Action: function() { return /* binding */ Action; },\n/* harmony export */   IDLE_BLOCKER: function() { return /* binding */ IDLE_BLOCKER; },\n/* harmony export */   IDLE_FETCHER: function() { return /* binding */ IDLE_FETCHER; },\n/* harmony export */   IDLE_NAVIGATION: function() { return /* binding */ IDLE_NAVIGATION; },\n/* harmony export */   UNSAFE_DEFERRED_SYMBOL: function() { return /* binding */ UNSAFE_DEFERRED_SYMBOL; },\n/* harmony export */   UNSAFE_DeferredData: function() { return /* binding */ DeferredData; },\n/* harmony export */   UNSAFE_ErrorResponseImpl: function() { return /* binding */ ErrorResponseImpl; },\n/* harmony export */   UNSAFE_convertRouteMatchToUiMatch: function() { return /* binding */ convertRouteMatchToUiMatch; },\n/* harmony export */   UNSAFE_convertRoutesToDataRoutes: function() { return /* binding */ convertRoutesToDataRoutes; },\n/* harmony export */   UNSAFE_getResolveToMatches: function() { return /* binding */ getResolveToMatches; },\n/* harmony export */   UNSAFE_invariant: function() { return /* binding */ invariant; },\n/* harmony export */   UNSAFE_warning: function() { return /* binding */ warning; },\n/* harmony export */   createBrowserHistory: function() { return /* binding */ createBrowserHistory; },\n/* harmony export */   createHashHistory: function() { return /* binding */ createHashHistory; },\n/* harmony export */   createMemoryHistory: function() { return /* binding */ createMemoryHistory; },\n/* harmony export */   createPath: function() { return /* binding */ createPath; },\n/* harmony export */   createRouter: function() { return /* binding */ createRouter; },\n/* harmony export */   createStaticHandler: function() { return /* binding */ createStaticHandler; },\n/* harmony export */   defer: function() { return /* binding */ defer; },\n/* harmony export */   generatePath: function() { return /* binding */ generatePath; },\n/* harmony export */   getStaticContextFromError: function() { return /* binding */ getStaticContextFromError; },\n/* harmony export */   getToPathname: function() { return /* binding */ getToPathname; },\n/* harmony export */   isDeferredData: function() { return /* binding */ isDeferredData; },\n/* harmony export */   isRouteErrorResponse: function() { return /* binding */ isRouteErrorResponse; },\n/* harmony export */   joinPaths: function() { return /* binding */ joinPaths; },\n/* harmony export */   json: function() { return /* binding */ json; },\n/* harmony export */   matchPath: function() { return /* binding */ matchPath; },\n/* harmony export */   matchRoutes: function() { return /* binding */ matchRoutes; },\n/* harmony export */   normalizePathname: function() { return /* binding */ normalizePathname; },\n/* harmony export */   parsePath: function() { return /* binding */ parsePath; },\n/* harmony export */   redirect: function() { return /* binding */ redirect; },\n/* harmony export */   redirectDocument: function() { return /* binding */ redirectDocument; },\n/* harmony export */   resolvePath: function() { return /* binding */ resolvePath; },\n/* harmony export */   resolveTo: function() { return /* binding */ resolveTo; },\n/* harmony export */   stripBasename: function() { return /* binding */ stripBasename; }\n/* harmony export */ });\n/**\n * @remix-run/router v1.14.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */ var Action;\n(function(Action) {\n    /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */ Action[\"Pop\"] = \"POP\";\n    /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */ Action[\"Push\"] = \"PUSH\";\n    /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */ Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nconst PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */ function createMemoryHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    let { initialEntries = [\n        \"/\"\n    ], initialIndex, v5Compat = false } = options;\n    let entries; // Declare so we can access from createMemoryLocation\n    entries = initialEntries.map((entry, index)=>createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\n    let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n    let action = Action.Pop;\n    let listener = null;\n    function clampIndex(n) {\n        return Math.min(Math.max(n, 0), entries.length - 1);\n    }\n    function getCurrentLocation() {\n        return entries[index];\n    }\n    function createMemoryLocation(to, state, key) {\n        if (state === void 0) {\n            state = null;\n        }\n        let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n        warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n        return location;\n    }\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    let history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return getCurrentLocation();\n        },\n        createHref,\n        createURL (to) {\n            return new URL(createHref(to), \"http://localhost\");\n        },\n        encodeLocation (to) {\n            let path = typeof to === \"string\" ? parsePath(to) : to;\n            return {\n                pathname: path.pathname || \"\",\n                search: path.search || \"\",\n                hash: path.hash || \"\"\n            };\n        },\n        push (to, state) {\n            action = Action.Push;\n            let nextLocation = createMemoryLocation(to, state);\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 1\n                });\n            }\n        },\n        replace (to, state) {\n            action = Action.Replace;\n            let nextLocation = createMemoryLocation(to, state);\n            entries[index] = nextLocation;\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 0\n                });\n            }\n        },\n        go (delta) {\n            action = Action.Pop;\n            let nextIndex = clampIndex(index + delta);\n            let nextLocation = entries[nextIndex];\n            index = nextIndex;\n            if (listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta\n                });\n            }\n        },\n        listen (fn) {\n            listener = fn;\n            return ()=>{\n                listener = null;\n            };\n        }\n    };\n    return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */ function createBrowserHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createBrowserLocation(window1, globalHistory) {\n        let { pathname, search, hash } = window1.location;\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createBrowserHref(window1, to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */ function createHashHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createHashLocation(window1, globalHistory) {\n        let { pathname = \"/\", search = \"\", hash = \"\" } = parsePath(window1.location.hash.substr(1));\n        // Hash URL should always have a leading / just like window.location.pathname\n        // does, so if an app ends up at a route like /#something then we add a\n        // leading slash so all of our path-matching behaves the same as if it would\n        // in a browser router.  This is particularly important when there exists a\n        // root splat route (<Route path=\"*\">) since that matches internally against\n        // \"/*\" and we'd expect /#something to 404 in a hash router app.\n        if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n            pathname = \"/\" + pathname;\n        }\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createHashHref(window1, to) {\n        let base = window1.document.querySelector(\"base\");\n        let href = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            let url = window1.location.href;\n            let hashIndex = url.indexOf(\"#\");\n            href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function validateHashLocation(location, to) {\n        warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n    }\n    return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\nfunction warning(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging history!\n            //\n            // This error is thrown as a convenience, so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message);\n        // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n}\nfunction createKey() {\n    return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */ function getHistoryState(location, index) {\n    return {\n        usr: location.state,\n        key: location.key,\n        idx: index\n    };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */ function createLocation(current, to, state, key) {\n    if (state === void 0) {\n        state = null;\n    }\n    let location = _extends({\n        pathname: typeof current === \"string\" ? current : current.pathname,\n        search: \"\",\n        hash: \"\"\n    }, typeof to === \"string\" ? parsePath(to) : to, {\n        state,\n        // TODO: This could be cleaned up.  push/replace should probably just take\n        // full Locations now and avoid the need to run through this flow at all\n        // But that's a pretty big refactor to the current test suite so going to\n        // keep as is for the time being and just let any incoming keys take precedence\n        key: to && to.key || key || createKey()\n    });\n    return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */ function createPath(_ref) {\n    let { pathname = \"/\", search = \"\", hash = \"\" } = _ref;\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */ function parsePath(path) {\n    let parsedPath = {};\n    if (path) {\n        let hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substr(hashIndex);\n            path = path.substr(0, hashIndex);\n        }\n        let searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substr(searchIndex);\n            path = path.substr(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    let { window: window1 = document.defaultView, v5Compat = false } = options;\n    let globalHistory = window1.history;\n    let action = Action.Pop;\n    let listener = null;\n    let index = getIndex();\n    // Index should only be null when we initialize. If not, it's because the\n    // user called history.pushState or history.replaceState directly, in which\n    // case we should log a warning as it will result in bugs.\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState(_extends({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function getIndex() {\n        let state = globalHistory.state || {\n            idx: null\n        };\n        return state.idx;\n    }\n    function handlePop() {\n        action = Action.Pop;\n        let nextIndex = getIndex();\n        let delta = nextIndex == null ? null : nextIndex - index;\n        index = nextIndex;\n        if (listener) {\n            listener({\n                action,\n                location: history.location,\n                delta\n            });\n        }\n    }\n    function push(to, state) {\n        action = Action.Push;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex() + 1;\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        // try...catch because iOS limits us to 100 pushState calls :/\n        try {\n            globalHistory.pushState(historyState, \"\", url);\n        } catch (error) {\n            // If the exception is because `state` can't be serialized, let that throw\n            // outwards just like a replace call would so the dev knows the cause\n            // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n            // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n            if (error instanceof DOMException && error.name === \"DataCloneError\") {\n                throw error;\n            }\n            // They are going to lose state here, but there is no real\n            // way to warn them about it since the page will refresh...\n            window1.location.assign(url);\n        }\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 1\n            });\n        }\n    }\n    function replace(to, state) {\n        action = Action.Replace;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex();\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        globalHistory.replaceState(historyState, \"\", url);\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 0\n            });\n        }\n    }\n    function createURL(to) {\n        // window.location.origin is \"null\" (the literal string value) in Firefox\n        // under certain conditions, notably when serving from a local HTML file\n        // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n        let base = window1.location.origin !== \"null\" ? window1.location.origin : window1.location.href;\n        let href = typeof to === \"string\" ? to : createPath(to);\n        invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n        return new URL(href, base);\n    }\n    let history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return getLocation(window1, globalHistory);\n        },\n        listen (fn) {\n            if (listener) {\n                throw new Error(\"A history only accepts one active listener\");\n            }\n            window1.addEventListener(PopStateEventType, handlePop);\n            listener = fn;\n            return ()=>{\n                window1.removeEventListener(PopStateEventType, handlePop);\n                listener = null;\n            };\n        },\n        createHref (to) {\n            return createHref(window1, to);\n        },\n        createURL,\n        encodeLocation (to) {\n            // Encode a Location the same way window.location would\n            let url = createURL(to);\n            return {\n                pathname: url.pathname,\n                search: url.search,\n                hash: url.hash\n            };\n        },\n        push,\n        replace,\n        go (n) {\n            return globalHistory.go(n);\n        }\n    };\n    return history;\n}\n//#endregion\nvar ResultType;\n(function(ResultType) {\n    ResultType[\"data\"] = \"data\";\n    ResultType[\"deferred\"] = \"deferred\";\n    ResultType[\"redirect\"] = \"redirect\";\n    ResultType[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nconst immutableRouteKeys = new Set([\n    \"lazy\",\n    \"caseSensitive\",\n    \"path\",\n    \"id\",\n    \"index\",\n    \"children\"\n]);\nfunction isIndexRoute(route) {\n    return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    if (manifest === void 0) {\n        manifest = {};\n    }\n    return routes.map((route, index)=>{\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n        invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n        invariant(!manifest[id], 'Found a route id collision on id \"' + id + '\".  Route ' + \"id's must be globally unique within Data Router usages\");\n        if (isIndexRoute(route)) {\n            let indexRoute = _extends({}, route, mapRouteProperties(route), {\n                id\n            });\n            manifest[id] = indexRoute;\n            return indexRoute;\n        } else {\n            let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n                id,\n                children: undefined\n            });\n            manifest[id] = pathOrLayoutRoute;\n            if (route.children) {\n                pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n            }\n            return pathOrLayoutRoute;\n        }\n    });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */ function matchRoutes(routes, locationArg, basename) {\n    if (basename === void 0) {\n        basename = \"/\";\n    }\n    let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    let pathname = stripBasename(location.pathname || \"/\", basename);\n    if (pathname == null) {\n        return null;\n    }\n    let branches = flattenRoutes(routes);\n    rankRouteBranches(branches);\n    let matches = null;\n    for(let i = 0; matches == null && i < branches.length; ++i){\n        matches = matchRouteBranch(branches[i], // Incoming pathnames are generally encoded from either window.location\n        // or from router.navigate, but we want to match against the unencoded\n        // paths in the route definitions.  Memory router locations won't be\n        // encoded here but there also shouldn't be anything to decode so this\n        // should be a safe operation.  This avoids needing matchRoutes to be\n        // history-aware.\n        safelyDecodeURI(pathname));\n    }\n    return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n    let { route, pathname, params } = match;\n    return {\n        id: route.id,\n        pathname,\n        params,\n        data: loaderData[route.id],\n        handle: route.handle\n    };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n    if (branches === void 0) {\n        branches = [];\n    }\n    if (parentsMeta === void 0) {\n        parentsMeta = [];\n    }\n    if (parentPath === void 0) {\n        parentPath = \"\";\n    }\n    let flattenRoute = (route, index, relativePath)=>{\n        let meta = {\n            relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n            caseSensitive: route.caseSensitive === true,\n            childrenIndex: index,\n            route\n        };\n        if (meta.relativePath.startsWith(\"/\")) {\n            invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path \"' + meta.relativePath + '\" nested under path ' + ('\"' + parentPath + '\" is not valid. An absolute child route path ') + \"must start with the combined path of all its parent routes.\");\n            meta.relativePath = meta.relativePath.slice(parentPath.length);\n        }\n        let path = joinPaths([\n            parentPath,\n            meta.relativePath\n        ]);\n        let routesMeta = parentsMeta.concat(meta);\n        // Add the children before adding this route to the array, so we traverse the\n        // route tree depth-first and child routes appear before their parents in\n        // the \"flattened\" version.\n        if (route.children && route.children.length > 0) {\n            invariant(// Our types know better, but runtime JS may not!\n            // @ts-expect-error\n            route.index !== true, \"Index routes must not have child routes. Please remove \" + ('all child routes from route path \"' + path + '\".'));\n            flattenRoutes(route.children, branches, routesMeta, path);\n        }\n        // Routes without a path shouldn't ever match by themselves unless they are\n        // index routes, so don't add them to the list of possible branches.\n        if (route.path == null && !route.index) {\n            return;\n        }\n        branches.push({\n            path,\n            score: computeScore(path, route.index),\n            routesMeta\n        });\n    };\n    routes.forEach((route, index)=>{\n        var _route$path;\n        // coarse-grain check for optional params\n        if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n            flattenRoute(route, index);\n        } else {\n            for (let exploded of explodeOptionalSegments(route.path)){\n                flattenRoute(route, index, exploded);\n            }\n        }\n    });\n    return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */ function explodeOptionalSegments(path) {\n    let segments = path.split(\"/\");\n    if (segments.length === 0) return [];\n    let [first, ...rest] = segments;\n    // Optional path segments are denoted by a trailing `?`\n    let isOptional = first.endsWith(\"?\");\n    // Compute the corresponding required segment: `foo?` -> `foo`\n    let required = first.replace(/\\?$/, \"\");\n    if (rest.length === 0) {\n        // Intepret empty string as omitting an optional segment\n        // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n        return isOptional ? [\n            required,\n            \"\"\n        ] : [\n            required\n        ];\n    }\n    let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n    let result = [];\n    // All child paths with the prefix.  Do this for all children before the\n    // optional version for all children, so we get consistent ordering where the\n    // parent optional aspect is preferred as required.  Otherwise, we can get\n    // child sections interspersed where deeper optional segments are higher than\n    // parent optional segments, where for example, /:two would explode _earlier_\n    // then /:one.  By always including the parent as required _for all children_\n    // first, we avoid this issue\n    result.push(...restExploded.map((subpath)=>subpath === \"\" ? required : [\n            required,\n            subpath\n        ].join(\"/\")));\n    // Then, if this is an optional value, add all child versions without\n    if (isOptional) {\n        result.push(...restExploded);\n    }\n    // for absolute paths, ensure `/` instead of empty segment\n    return result.map((exploded)=>path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n    branches.sort((a, b)=>a.score !== b.score ? b.score - a.score // Higher score first\n         : compareIndexes(a.routesMeta.map((meta)=>meta.childrenIndex), b.routesMeta.map((meta)=>meta.childrenIndex)));\n}\nconst paramRe = /^:[\\w-]+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s)=>s === \"*\";\nfunction computeScore(path, index) {\n    let segments = path.split(\"/\");\n    let initialScore = segments.length;\n    if (segments.some(isSplat)) {\n        initialScore += splatPenalty;\n    }\n    if (index) {\n        initialScore += indexRouteValue;\n    }\n    return segments.filter((s)=>!isSplat(s)).reduce((score, segment)=>score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n    let siblings = a.length === b.length && a.slice(0, -1).every((n, i)=>n === b[i]);\n    return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0;\n}\nfunction matchRouteBranch(branch, pathname) {\n    let { routesMeta } = branch;\n    let matchedParams = {};\n    let matchedPathname = \"/\";\n    let matches = [];\n    for(let i = 0; i < routesMeta.length; ++i){\n        let meta = routesMeta[i];\n        let end = i === routesMeta.length - 1;\n        let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n        let match = matchPath({\n            path: meta.relativePath,\n            caseSensitive: meta.caseSensitive,\n            end\n        }, remainingPathname);\n        if (!match) return null;\n        Object.assign(matchedParams, match.params);\n        let route = meta.route;\n        matches.push({\n            // TODO: Can this as be avoided?\n            params: matchedParams,\n            pathname: joinPaths([\n                matchedPathname,\n                match.pathname\n            ]),\n            pathnameBase: normalizePathname(joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ])),\n            route\n        });\n        if (match.pathnameBase !== \"/\") {\n            matchedPathname = joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ]);\n        }\n    }\n    return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */ function generatePath(originalPath, params) {\n    if (params === void 0) {\n        params = {};\n    }\n    let path = originalPath;\n    if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n        warning(false, 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n        path = path.replace(/\\*$/, \"/*\");\n    }\n    // ensure `/` is added at the beginning if the path is absolute\n    const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n    const stringify = (p)=>p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n    const segments = path.split(/\\/+/).map((segment, index, array)=>{\n        const isLastSegment = index === array.length - 1;\n        // only apply the splat if it's the last segment\n        if (isLastSegment && segment === \"*\") {\n            const star = \"*\";\n            // Apply the splat\n            return stringify(params[star]);\n        }\n        const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n        if (keyMatch) {\n            const [, key, optional] = keyMatch;\n            let param = params[key];\n            invariant(optional === \"?\" || param != null, 'Missing \":' + key + '\" param');\n            return stringify(param);\n        }\n        // Remove any optional markers from optional static segments\n        return segment.replace(/\\?$/g, \"\");\n    })// Remove empty segments\n    .filter((segment)=>!!segment);\n    return prefix + segments.join(\"/\");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */ function matchPath(pattern, pathname) {\n    if (typeof pattern === \"string\") {\n        pattern = {\n            path: pattern,\n            caseSensitive: false,\n            end: true\n        };\n    }\n    let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n    let match = pathname.match(matcher);\n    if (!match) return null;\n    let matchedPathname = match[0];\n    let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n    let captureGroups = match.slice(1);\n    let params = compiledParams.reduce((memo, _ref, index)=>{\n        let { paramName, isOptional } = _ref;\n        // We need to compute the pathnameBase here using the raw splat value\n        // instead of using params[\"*\"] later because it will be decoded then\n        if (paramName === \"*\") {\n            let splatValue = captureGroups[index] || \"\";\n            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        const value = captureGroups[index];\n        if (isOptional && !value) {\n            memo[paramName] = undefined;\n        } else {\n            memo[paramName] = safelyDecodeURIComponent(value || \"\", paramName);\n        }\n        return memo;\n    }, {});\n    return {\n        params,\n        pathname: matchedPathname,\n        pathnameBase,\n        pattern\n    };\n}\nfunction compilePath(path, caseSensitive, end) {\n    if (caseSensitive === void 0) {\n        caseSensitive = false;\n    }\n    if (end === void 0) {\n        end = true;\n    }\n    warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n    let params = [];\n    let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n    .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n    .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n    .replace(/\\/:([\\w-]+)(\\?)?/g, (_, paramName, isOptional)=>{\n        params.push({\n            paramName,\n            isOptional: isOptional != null\n        });\n        return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n    });\n    if (path.endsWith(\"*\")) {\n        params.push({\n            paramName: \"*\"\n        });\n        regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n         : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n    } else if (end) {\n        // When matching to the end, ignore trailing slashes\n        regexpSource += \"\\\\/*$\";\n    } else if (path !== \"\" && path !== \"/\") {\n        // If our path is non-empty and contains anything beyond an initial slash,\n        // then we have _some_ form of path in our regex, so we should expect to\n        // match only if we find the end of this path segment.  Look for an optional\n        // non-captured trailing slash (to match a portion of the URL) or the end\n        // of the path (if we've matched to the end).  We used to do this with a\n        // word boundary but that gives false positives on routes like\n        // /user-preferences since `-` counts as a word boundary.\n        regexpSource += \"(?:(?=\\\\/|$))\";\n    } else ;\n    let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n    return [\n        matcher,\n        params\n    ];\n}\nfunction safelyDecodeURI(value) {\n    try {\n        return decodeURI(value);\n    } catch (error) {\n        warning(false, 'The URL path \"' + value + '\" could not be decoded because it is is a ' + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n        return value;\n    }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n    try {\n        return decodeURIComponent(value);\n    } catch (error) {\n        warning(false, 'The value for the URL param \"' + paramName + '\" will not be decoded because' + (' the string \"' + value + '\" is a malformed URL segment. This is probably') + (\" due to a bad percent encoding (\" + error + \").\"));\n        return value;\n    }\n}\n/**\n * @private\n */ function stripBasename(pathname, basename) {\n    if (basename === \"/\") return pathname;\n    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n        return null;\n    }\n    // We want to leave trailing slash behavior in the user's control, so if they\n    // specify a basename with a trailing slash, we should support it\n    let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n    let nextChar = pathname.charAt(startIndex);\n    if (nextChar && nextChar !== \"/\") {\n        // pathname does not start with basename/\n        return null;\n    }\n    return pathname.slice(startIndex) || \"/\";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */ function resolvePath(to, fromPathname) {\n    if (fromPathname === void 0) {\n        fromPathname = \"/\";\n    }\n    let { pathname: toPathname, search = \"\", hash = \"\" } = typeof to === \"string\" ? parsePath(to) : to;\n    let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n    return {\n        pathname,\n        search: normalizeSearch(search),\n        hash: normalizeHash(hash)\n    };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n    let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n    let relativeSegments = relativePath.split(\"/\");\n    relativeSegments.forEach((segment)=>{\n        if (segment === \"..\") {\n            // Keep the root \"\" segment so the pathname starts at /\n            if (segments.length > 1) segments.pop();\n        } else if (segment !== \".\") {\n            segments.push(segment);\n        }\n    });\n    return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n    return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + 'a string in <Link to=\"...\"> and the router will parse it for you.';\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */ function getPathContributingMatches(matches) {\n    return matches.filter((match, index)=>index === 0 || match.route.path && match.route.path.length > 0);\n}\n// Return the array of pathnames for the current route matches - used to\n// generate the routePathnames input for resolveTo()\nfunction getResolveToMatches(matches, v7_relativeSplatPath) {\n    let pathMatches = getPathContributingMatches(matches);\n    // When v7_relativeSplatPath is enabled, use the full pathname for the leaf\n    // match so we include splat values for \".\" links.  See:\n    // https://github.com/remix-run/react-router/issues/11052#issuecomment-1836589329\n    if (v7_relativeSplatPath) {\n        return pathMatches.map((match, idx)=>idx === matches.length - 1 ? match.pathname : match.pathnameBase);\n    }\n    return pathMatches.map((match)=>match.pathnameBase);\n}\n/**\n * @private\n */ function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n    if (isPathRelative === void 0) {\n        isPathRelative = false;\n    }\n    let to;\n    if (typeof toArg === \"string\") {\n        to = parsePath(toArg);\n    } else {\n        to = _extends({}, toArg);\n        invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n        invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n        invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n    }\n    let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n    let toPathname = isEmptyPath ? \"/\" : to.pathname;\n    let from;\n    // Routing is relative to the current pathname if explicitly requested.\n    //\n    // If a pathname is explicitly provided in `to`, it should be relative to the\n    // route context. This is explained in `Note on `<Link to>` values` in our\n    // migration guide from v5 as a means of disambiguation between `to` values\n    // that begin with `/` and those that do not. However, this is problematic for\n    // `to` values that do not provide a pathname. `to` can simply be a search or\n    // hash string, in which case we should assume that the navigation is relative\n    // to the current location's pathname and *not* the route pathname.\n    if (toPathname == null) {\n        from = locationPathname;\n    } else {\n        let routePathnameIndex = routePathnames.length - 1;\n        // With relative=\"route\" (the default), each leading .. segment means\n        // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n        // difference from how <a href> works and a major reason we call this a\n        // \"to\" value instead of a \"href\".\n        if (!isPathRelative && toPathname.startsWith(\"..\")) {\n            let toSegments = toPathname.split(\"/\");\n            while(toSegments[0] === \"..\"){\n                toSegments.shift();\n                routePathnameIndex -= 1;\n            }\n            to.pathname = toSegments.join(\"/\");\n        }\n        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n    }\n    let path = resolvePath(to, from);\n    // Ensure the pathname has a trailing slash if the original \"to\" had one\n    let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n    // Or if this was a link to the current path which has a trailing slash\n    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n    if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n        path.pathname += \"/\";\n    }\n    return path;\n}\n/**\n * @private\n */ function getToPathname(to) {\n    // Empty strings should be treated the same as / paths\n    return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */ const joinPaths = (paths)=>paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n/**\n * @private\n */ const normalizePathname = (pathname)=>pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n/**\n * @private\n */ const normalizeSearch = (search)=>!search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n/**\n * @private\n */ const normalizeHash = (hash)=>!hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */ const json = function json(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    let responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    let headers = new Headers(responseInit.headers);\n    if (!headers.has(\"Content-Type\")) {\n        headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n    }\n    return new Response(JSON.stringify(data), _extends({}, responseInit, {\n        headers\n    }));\n};\nclass AbortedDeferredError extends Error {\n}\nclass DeferredData {\n    trackPromise(key, value) {\n        if (!(value instanceof Promise)) {\n            return value;\n        }\n        this.deferredKeys.push(key);\n        this.pendingKeysSet.add(key);\n        // We store a little wrapper promise that will be extended with\n        // _data/_error props upon resolve/reject\n        let promise = Promise.race([\n            value,\n            this.abortPromise\n        ]).then((data)=>this.onSettle(promise, key, undefined, data), (error)=>this.onSettle(promise, key, error));\n        // Register rejection listeners to avoid uncaught promise rejections on\n        // errors or aborted deferred values\n        promise.catch(()=>{});\n        Object.defineProperty(promise, \"_tracked\", {\n            get: ()=>true\n        });\n        return promise;\n    }\n    onSettle(promise, key, error, data) {\n        if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n            this.unlistenAbortSignal();\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>error\n            });\n            return Promise.reject(error);\n        }\n        this.pendingKeysSet.delete(key);\n        if (this.done) {\n            // Nothing left to abort!\n            this.unlistenAbortSignal();\n        }\n        // If the promise was resolved/rejected with undefined, we'll throw an error as you\n        // should always resolve with a value or null\n        if (error === undefined && data === undefined) {\n            let undefinedError = new Error('Deferred data for key \"' + key + '\" resolved/rejected with `undefined`, ' + \"you must resolve/reject with a value or `null`.\");\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>undefinedError\n            });\n            this.emit(false, key);\n            return Promise.reject(undefinedError);\n        }\n        if (data === undefined) {\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>error\n            });\n            this.emit(false, key);\n            return Promise.reject(error);\n        }\n        Object.defineProperty(promise, \"_data\", {\n            get: ()=>data\n        });\n        this.emit(false, key);\n        return data;\n    }\n    emit(aborted, settledKey) {\n        this.subscribers.forEach((subscriber)=>subscriber(aborted, settledKey));\n    }\n    subscribe(fn) {\n        this.subscribers.add(fn);\n        return ()=>this.subscribers.delete(fn);\n    }\n    cancel() {\n        this.controller.abort();\n        this.pendingKeysSet.forEach((v, k)=>this.pendingKeysSet.delete(k));\n        this.emit(true);\n    }\n    async resolveData(signal) {\n        let aborted = false;\n        if (!this.done) {\n            let onAbort = ()=>this.cancel();\n            signal.addEventListener(\"abort\", onAbort);\n            aborted = await new Promise((resolve)=>{\n                this.subscribe((aborted)=>{\n                    signal.removeEventListener(\"abort\", onAbort);\n                    if (aborted || this.done) {\n                        resolve(aborted);\n                    }\n                });\n            });\n        }\n        return aborted;\n    }\n    get done() {\n        return this.pendingKeysSet.size === 0;\n    }\n    get unwrappedData() {\n        invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n        return Object.entries(this.data).reduce((acc, _ref3)=>{\n            let [key, value] = _ref3;\n            return Object.assign(acc, {\n                [key]: unwrapTrackedPromise(value)\n            });\n        }, {});\n    }\n    get pendingKeys() {\n        return Array.from(this.pendingKeysSet);\n    }\n    constructor(data, responseInit){\n        this.pendingKeysSet = new Set();\n        this.subscribers = new Set();\n        this.deferredKeys = [];\n        invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n        // Set up an AbortController + Promise we can race against to exit early\n        // cancellation\n        let reject;\n        this.abortPromise = new Promise((_, r)=>reject = r);\n        this.controller = new AbortController();\n        let onAbort = ()=>reject(new AbortedDeferredError(\"Deferred data aborted\"));\n        this.unlistenAbortSignal = ()=>this.controller.signal.removeEventListener(\"abort\", onAbort);\n        this.controller.signal.addEventListener(\"abort\", onAbort);\n        this.data = Object.entries(data).reduce((acc, _ref2)=>{\n            let [key, value] = _ref2;\n            return Object.assign(acc, {\n                [key]: this.trackPromise(key, value)\n            });\n        }, {});\n        if (this.done) {\n            // All incoming values were resolved\n            this.unlistenAbortSignal();\n        }\n        this.init = responseInit;\n    }\n}\nfunction isTrackedPromise(value) {\n    return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n    if (!isTrackedPromise(value)) {\n        return value;\n    }\n    if (value._error) {\n        throw value._error;\n    }\n    return value._data;\n}\nconst defer = function defer(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    let responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */ const redirect = function redirect(url, init) {\n    if (init === void 0) {\n        init = 302;\n    }\n    let responseInit = init;\n    if (typeof responseInit === \"number\") {\n        responseInit = {\n            status: responseInit\n        };\n    } else if (typeof responseInit.status === \"undefined\") {\n        responseInit.status = 302;\n    }\n    let headers = new Headers(responseInit.headers);\n    headers.set(\"Location\", url);\n    return new Response(null, _extends({}, responseInit, {\n        headers\n    }));\n};\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */ const redirectDocument = (url, init)=>{\n    let response = redirect(url, init);\n    response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n    return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */ class ErrorResponseImpl {\n    constructor(status, statusText, data, internal){\n        if (internal === void 0) {\n            internal = false;\n        }\n        this.status = status;\n        this.statusText = statusText || \"\";\n        this.internal = internal;\n        if (data instanceof Error) {\n            this.data = data.toString();\n            this.error = data;\n        } else {\n            this.data = data;\n        }\n    }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */ function isRouteErrorResponse(error) {\n    return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\nconst validMutationMethodsArr = [\n    \"post\",\n    \"put\",\n    \"patch\",\n    \"delete\"\n];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = [\n    \"get\",\n    ...validMutationMethodsArr\n];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\nconst redirectPreserveMethodStatusCodes = new Set([\n    307,\n    308\n]);\nconst IDLE_NAVIGATION = {\n    state: \"idle\",\n    location: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nconst IDLE_FETCHER = {\n    state: \"idle\",\n    data: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nconst IDLE_BLOCKER = {\n    state: \"unblocked\",\n    proceed: undefined,\n    reset: undefined,\n    location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = (route)=>({\n        hasErrorBoundary: Boolean(route.hasErrorBoundary)\n    });\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */ function createRouter(init) {\n    const routerWindow = init.window ? init.window :  true ? window : 0;\n    const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n    const isServer = !isBrowser;\n    invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n    let mapRouteProperties;\n    if (init.mapRouteProperties) {\n        mapRouteProperties = init.mapRouteProperties;\n    } else if (init.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        let detectErrorBoundary = init.detectErrorBoundary;\n        mapRouteProperties = (route)=>({\n                hasErrorBoundary: detectErrorBoundary(route)\n            });\n    } else {\n        mapRouteProperties = defaultMapRouteProperties;\n    }\n    // Routes keyed by ID\n    let manifest = {};\n    // Routes in tree format for matching\n    let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n    let inFlightDataRoutes;\n    let basename = init.basename || \"/\";\n    // Config driven behavior flags\n    let future = _extends({\n        v7_fetcherPersist: false,\n        v7_normalizeFormMethod: false,\n        v7_partialHydration: false,\n        v7_prependBasename: false,\n        v7_relativeSplatPath: false\n    }, init.future);\n    // Cleanup function for history\n    let unlistenHistory = null;\n    // Externally-provided functions to call on all state changes\n    let subscribers = new Set();\n    // Externally-provided object to hold scroll restoration locations during routing\n    let savedScrollPositions = null;\n    // Externally-provided function to get scroll restoration keys\n    let getScrollRestorationKey = null;\n    // Externally-provided function to get current scroll position\n    let getScrollPosition = null;\n    // One-time flag to control the initial hydration scroll restoration.  Because\n    // we don't get the saved positions from <ScrollRestoration /> until _after_\n    // the initial render, we need to manually trigger a separate updateState to\n    // send along the restoreScrollPosition\n    // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n    // SSR did the initial scroll restoration.\n    let initialScrollRestored = init.hydrationData != null;\n    let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n    let initialErrors = null;\n    if (initialMatches == null) {\n        // If we do not match a user-provided-route, fall back to the root\n        // to allow the error boundary to take over\n        let error = getInternalRouterError(404, {\n            pathname: init.history.location.pathname\n        });\n        let { matches, route } = getShortCircuitMatches(dataRoutes);\n        initialMatches = matches;\n        initialErrors = {\n            [route.id]: error\n        };\n    }\n    let initialized;\n    let hasLazyRoutes = initialMatches.some((m)=>m.route.lazy);\n    let hasLoaders = initialMatches.some((m)=>m.route.loader);\n    if (hasLazyRoutes) {\n        // All initialMatches need to be loaded before we're ready.  If we have lazy\n        // functions around still then we'll need to run them in initialize()\n        initialized = false;\n    } else if (!hasLoaders) {\n        // If we've got no loaders to run, then we're good to go\n        initialized = true;\n    } else if (future.v7_partialHydration) {\n        // If partial hydration is enabled, we're initialized so long as we were\n        // provided with hydrationData for every route with a loader, and no loaders\n        // were marked for explicit hydration\n        let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n        let errors = init.hydrationData ? init.hydrationData.errors : null;\n        initialized = initialMatches.every((m)=>m.route.loader && m.route.loader.hydrate !== true && (loaderData && loaderData[m.route.id] !== undefined || errors && errors[m.route.id] !== undefined));\n    } else {\n        // Without partial hydration - we're initialized if we were provided any\n        // hydrationData - which is expected to be complete\n        initialized = init.hydrationData != null;\n    }\n    let router;\n    let state = {\n        historyAction: init.history.action,\n        location: init.history.location,\n        matches: initialMatches,\n        initialized,\n        navigation: IDLE_NAVIGATION,\n        // Don't restore on initial updateState() if we were SSR'd\n        restoreScrollPosition: init.hydrationData != null ? false : null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n        actionData: init.hydrationData && init.hydrationData.actionData || null,\n        errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n        fetchers: new Map(),\n        blockers: new Map()\n    };\n    // -- Stateful internal variables to manage navigations --\n    // Current navigation in progress (to be committed in completeNavigation)\n    let pendingAction = Action.Pop;\n    // Should the current navigation prevent the scroll reset if scroll cannot\n    // be restored?\n    let pendingPreventScrollReset = false;\n    // AbortController for the active navigation\n    let pendingNavigationController;\n    // Should the current navigation enable document.startViewTransition?\n    let pendingViewTransitionEnabled = false;\n    // Store applied view transitions so we can apply them on POP\n    let appliedViewTransitions = new Map();\n    // Cleanup function for persisting applied transitions to sessionStorage\n    let removePageHideEventListener = null;\n    // We use this to avoid touching history in completeNavigation if a\n    // revalidation is entirely uninterrupted\n    let isUninterruptedRevalidation = false;\n    // Use this internal flag to force revalidation of all loaders:\n    //  - submissions (completed or interrupted)\n    //  - useRevalidator()\n    //  - X-Remix-Revalidate (from redirect)\n    let isRevalidationRequired = false;\n    // Use this internal array to capture routes that require revalidation due\n    // to a cancelled deferred on action submission\n    let cancelledDeferredRoutes = [];\n    // Use this internal array to capture fetcher loads that were cancelled by an\n    // action navigation and require revalidation\n    let cancelledFetcherLoads = [];\n    // AbortControllers for any in-flight fetchers\n    let fetchControllers = new Map();\n    // Track loads based on the order in which they started\n    let incrementingLoadId = 0;\n    // Track the outstanding pending navigation data load to be compared against\n    // the globally incrementing load when a fetcher load lands after a completed\n    // navigation\n    let pendingNavigationLoadId = -1;\n    // Fetchers that triggered data reloads as a result of their actions\n    let fetchReloadIds = new Map();\n    // Fetchers that triggered redirect navigations\n    let fetchRedirectIds = new Set();\n    // Most recent href/match for fetcher.load calls for fetchers\n    let fetchLoadMatches = new Map();\n    // Ref-count mounted fetchers so we know when it's ok to clean them up\n    let activeFetchers = new Map();\n    // Fetchers that have requested a delete when using v7_fetcherPersist,\n    // they'll be officially removed after they return to idle\n    let deletedFetchers = new Set();\n    // Store DeferredData instances for active route matches.  When a\n    // route loader returns defer() we stick one in here.  Then, when a nested\n    // promise resolves we update loaderData.  If a new navigation starts we\n    // cancel active deferreds for eliminated routes.\n    let activeDeferreds = new Map();\n    // Store blocker functions in a separate Map outside of router state since\n    // we don't need to update UI state if they change\n    let blockerFunctions = new Map();\n    // Flag to ignore the next history update, so we can revert the URL change on\n    // a POP navigation that was blocked by the user without touching router state\n    let ignoreNextHistoryUpdate = false;\n    // Initialize the router, all side effects should be kicked off from here.\n    // Implemented as a Fluent API for ease of:\n    //   let router = createRouter(init).initialize();\n    function initialize() {\n        // If history informs us of a POP navigation, start the navigation but do not update\n        // state.  We'll update our own state once the navigation completes\n        unlistenHistory = init.history.listen((_ref)=>{\n            let { action: historyAction, location, delta } = _ref;\n            // Ignore this event if it was just us resetting the URL from a\n            // blocked POP navigation\n            if (ignoreNextHistoryUpdate) {\n                ignoreNextHistoryUpdate = false;\n                return;\n            }\n            warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\n            let blockerKey = shouldBlockNavigation({\n                currentLocation: state.location,\n                nextLocation: location,\n                historyAction\n            });\n            if (blockerKey && delta != null) {\n                // Restore the URL to match the current UI, but don't update router state\n                ignoreNextHistoryUpdate = true;\n                init.history.go(delta * -1);\n                // Put the blocker into a blocked state\n                updateBlocker(blockerKey, {\n                    state: \"blocked\",\n                    location,\n                    proceed () {\n                        updateBlocker(blockerKey, {\n                            state: \"proceeding\",\n                            proceed: undefined,\n                            reset: undefined,\n                            location\n                        });\n                        // Re-do the same POP navigation we just blocked\n                        init.history.go(delta);\n                    },\n                    reset () {\n                        let blockers = new Map(state.blockers);\n                        blockers.set(blockerKey, IDLE_BLOCKER);\n                        updateState({\n                            blockers\n                        });\n                    }\n                });\n                return;\n            }\n            return startNavigation(historyAction, location);\n        });\n        if (isBrowser) {\n            // FIXME: This feels gross.  How can we cleanup the lines between\n            // scrollRestoration/appliedTransitions persistance?\n            restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n            let _saveAppliedTransitions = ()=>persistAppliedTransitions(routerWindow, appliedViewTransitions);\n            routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n            removePageHideEventListener = ()=>routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n        }\n        // Kick off initial data load if needed.  Use Pop to avoid modifying history\n        // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n        // in the normal navigation flow.  For SSR it's expected that lazy modules are\n        // resolved prior to router creation since we can't go into a fallbackElement\n        // UI for SSR'd apps\n        if (!state.initialized) {\n            startNavigation(Action.Pop, state.location, {\n                initialHydration: true\n            });\n        }\n        return router;\n    }\n    // Clean up a router and it's side effects\n    function dispose() {\n        if (unlistenHistory) {\n            unlistenHistory();\n        }\n        if (removePageHideEventListener) {\n            removePageHideEventListener();\n        }\n        subscribers.clear();\n        pendingNavigationController && pendingNavigationController.abort();\n        state.fetchers.forEach((_, key)=>deleteFetcher(key));\n        state.blockers.forEach((_, key)=>deleteBlocker(key));\n    }\n    // Subscribe to state updates for the router\n    function subscribe(fn) {\n        subscribers.add(fn);\n        return ()=>subscribers.delete(fn);\n    }\n    // Update our state and notify the calling context of the change\n    function updateState(newState, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        state = _extends({}, state, newState);\n        // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n        // can be removed\n        let completedFetchers = [];\n        let deletedFetchersKeys = [];\n        if (future.v7_fetcherPersist) {\n            state.fetchers.forEach((fetcher, key)=>{\n                if (fetcher.state === \"idle\") {\n                    if (deletedFetchers.has(key)) {\n                        // Unmounted from the UI and can be totally removed\n                        deletedFetchersKeys.push(key);\n                    } else {\n                        // Returned to idle but still mounted in the UI, so semi-remains for\n                        // revalidations and such\n                        completedFetchers.push(key);\n                    }\n                }\n            });\n        }\n        // Iterate over a local copy so that if flushSync is used and we end up\n        // removing and adding a new subscriber due to the useCallback dependencies,\n        // we don't get ourselves into a loop calling the new subscriber immediately\n        [\n            ...subscribers\n        ].forEach((subscriber)=>subscriber(state, {\n                deletedFetchers: deletedFetchersKeys,\n                unstable_viewTransitionOpts: opts.viewTransitionOpts,\n                unstable_flushSync: opts.flushSync === true\n            }));\n        // Remove idle fetchers from state since we only care about in-flight fetchers.\n        if (future.v7_fetcherPersist) {\n            completedFetchers.forEach((key)=>state.fetchers.delete(key));\n            deletedFetchersKeys.forEach((key)=>deleteFetcher(key));\n        }\n    }\n    // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n    // and setting state.[historyAction/location/matches] to the new route.\n    // - Location is a required param\n    // - Navigation will always be set to IDLE_NAVIGATION\n    // - Can pass any other state in newState\n    function completeNavigation(location, newState, _temp) {\n        var _location$state, _location$state2;\n        let { flushSync } = _temp === void 0 ? {} : _temp;\n        // Deduce if we're in a loading/actionReload state:\n        // - We have committed actionData in the store\n        // - The current navigation was a mutation submission\n        // - We're past the submitting state and into the loading state\n        // - The location being loaded is not the result of a redirect\n        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n        let actionData;\n        if (newState.actionData) {\n            if (Object.keys(newState.actionData).length > 0) {\n                actionData = newState.actionData;\n            } else {\n                // Empty actionData -> clear prior actionData due to an action error\n                actionData = null;\n            }\n        } else if (isActionReload) {\n            // Keep the current data if we're wrapping up the action reload\n            actionData = state.actionData;\n        } else {\n            // Clear actionData on any other completed navigations\n            actionData = null;\n        }\n        // Always preserve any existing loaderData from re-used routes\n        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n        // On a successful navigation we can assume we got through all blockers\n        // so we can start fresh\n        let blockers = state.blockers;\n        if (blockers.size > 0) {\n            blockers = new Map(blockers);\n            blockers.forEach((_, k)=>blockers.set(k, IDLE_BLOCKER));\n        }\n        // Always respect the user flag.  Otherwise don't reset on mutation\n        // submission navigations unless they redirect\n        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n        if (inFlightDataRoutes) {\n            dataRoutes = inFlightDataRoutes;\n            inFlightDataRoutes = undefined;\n        }\n        if (isUninterruptedRevalidation) ;\n        else if (pendingAction === Action.Pop) ;\n        else if (pendingAction === Action.Push) {\n            init.history.push(location, location.state);\n        } else if (pendingAction === Action.Replace) {\n            init.history.replace(location, location.state);\n        }\n        let viewTransitionOpts;\n        // On POP, enable transitions if they were enabled on the original navigation\n        if (pendingAction === Action.Pop) {\n            // Forward takes precedence so they behave like the original navigation\n            let priorPaths = appliedViewTransitions.get(state.location.pathname);\n            if (priorPaths && priorPaths.has(location.pathname)) {\n                viewTransitionOpts = {\n                    currentLocation: state.location,\n                    nextLocation: location\n                };\n            } else if (appliedViewTransitions.has(location.pathname)) {\n                // If we don't have a previous forward nav, assume we're popping back to\n                // the new location and enable if that location previously enabled\n                viewTransitionOpts = {\n                    currentLocation: location,\n                    nextLocation: state.location\n                };\n            }\n        } else if (pendingViewTransitionEnabled) {\n            // Store the applied transition on PUSH/REPLACE\n            let toPaths = appliedViewTransitions.get(state.location.pathname);\n            if (toPaths) {\n                toPaths.add(location.pathname);\n            } else {\n                toPaths = new Set([\n                    location.pathname\n                ]);\n                appliedViewTransitions.set(state.location.pathname, toPaths);\n            }\n            viewTransitionOpts = {\n                currentLocation: state.location,\n                nextLocation: location\n            };\n        }\n        updateState(_extends({}, newState, {\n            actionData,\n            loaderData,\n            historyAction: pendingAction,\n            location,\n            initialized: true,\n            navigation: IDLE_NAVIGATION,\n            revalidation: \"idle\",\n            restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n            preventScrollReset,\n            blockers\n        }), {\n            viewTransitionOpts,\n            flushSync: flushSync === true\n        });\n        // Reset stateful navigation vars\n        pendingAction = Action.Pop;\n        pendingPreventScrollReset = false;\n        pendingViewTransitionEnabled = false;\n        isUninterruptedRevalidation = false;\n        isRevalidationRequired = false;\n        cancelledDeferredRoutes = [];\n        cancelledFetcherLoads = [];\n    }\n    // Trigger a navigation event, which can either be a numerical POP or a PUSH\n    // replace with an optional submission\n    async function navigate(to, opts) {\n        if (typeof to === \"number\") {\n            init.history.go(to);\n            return;\n        }\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n        let { path, submission, error } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n        let currentLocation = state.location;\n        let nextLocation = createLocation(state.location, path, opts && opts.state);\n        // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n        // URL from window.location, so we need to encode it here so the behavior\n        // remains the same as POP and non-data-router usages.  new URL() does all\n        // the same encoding we'd get from a history.pushState/window.location read\n        // without having to touch history\n        nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n        let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n        let historyAction = Action.Push;\n        if (userReplace === true) {\n            historyAction = Action.Replace;\n        } else if (userReplace === false) ;\n        else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n            // By default on submissions to the current location we REPLACE so that\n            // users don't have to double-click the back button to get to the prior\n            // location.  If the user redirects to a different location from the\n            // action/loader this will be ignored and the redirect will be a PUSH\n            historyAction = Action.Replace;\n        }\n        let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n        let flushSync = (opts && opts.unstable_flushSync) === true;\n        let blockerKey = shouldBlockNavigation({\n            currentLocation,\n            nextLocation,\n            historyAction\n        });\n        if (blockerKey) {\n            // Put the blocker into a blocked state\n            updateBlocker(blockerKey, {\n                state: \"blocked\",\n                location: nextLocation,\n                proceed () {\n                    updateBlocker(blockerKey, {\n                        state: \"proceeding\",\n                        proceed: undefined,\n                        reset: undefined,\n                        location: nextLocation\n                    });\n                    // Send the same navigation through\n                    navigate(to, opts);\n                },\n                reset () {\n                    let blockers = new Map(state.blockers);\n                    blockers.set(blockerKey, IDLE_BLOCKER);\n                    updateState({\n                        blockers\n                    });\n                }\n            });\n            return;\n        }\n        return await startNavigation(historyAction, nextLocation, {\n            submission,\n            // Send through the formData serialization error if we have one so we can\n            // render at the right error boundary after we match routes\n            pendingError: error,\n            preventScrollReset,\n            replace: opts && opts.replace,\n            enableViewTransition: opts && opts.unstable_viewTransition,\n            flushSync\n        });\n    }\n    // Revalidate all current loaders.  If a navigation is in progress or if this\n    // is interrupted by a navigation, allow this to \"succeed\" by calling all\n    // loaders during the next loader round\n    function revalidate() {\n        interruptActiveLoads();\n        updateState({\n            revalidation: \"loading\"\n        });\n        // If we're currently submitting an action, we don't need to start a new\n        // navigation, we'll just let the follow up loader execution call all loaders\n        if (state.navigation.state === \"submitting\") {\n            return;\n        }\n        // If we're currently in an idle state, start a new navigation for the current\n        // action/location and mark it as uninterrupted, which will skip the history\n        // update in completeNavigation\n        if (state.navigation.state === \"idle\") {\n            startNavigation(state.historyAction, state.location, {\n                startUninterruptedRevalidation: true\n            });\n            return;\n        }\n        // Otherwise, if we're currently in a loading state, just start a new\n        // navigation to the navigation.location but do not trigger an uninterrupted\n        // revalidation so that history correctly updates once the navigation completes\n        startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n            overrideNavigation: state.navigation\n        });\n    }\n    // Start a navigation to the given action/location.  Can optionally provide a\n    // overrideNavigation which will override the normalLoad in the case of a redirect\n    // navigation\n    async function startNavigation(historyAction, location, opts) {\n        // Abort any in-progress navigations and start a new one. Unset any ongoing\n        // uninterrupted revalidations unless told otherwise, since we want this\n        // new navigation to update history normally\n        pendingNavigationController && pendingNavigationController.abort();\n        pendingNavigationController = null;\n        pendingAction = historyAction;\n        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n        // Save the current scroll position every time we start a new navigation,\n        // and track whether we should reset scroll on completion\n        saveScrollPosition(state.location, state.matches);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let loadingNavigation = opts && opts.overrideNavigation;\n        let matches = matchRoutes(routesToUse, location, basename);\n        let flushSync = (opts && opts.flushSync) === true;\n        // Short circuit with a 404 on the root error boundary if we match nothing\n        if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(routesToUse);\n            // Cancel all pending deferred on 404s since we don't keep any routes\n            cancelActiveDeferreds();\n            completeNavigation(location, {\n                matches: notFoundMatches,\n                loaderData: {},\n                errors: {\n                    [route.id]: error\n                }\n            }, {\n                flushSync\n            });\n            return;\n        }\n        // Short circuit if it's only a hash change and not a revalidation or\n        // mutation submission.\n        //\n        // Ignore on initial page loads because since the initial load will always\n        // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n        // which will default to a navigation to /page\n        if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n            completeNavigation(location, {\n                matches\n            }, {\n                flushSync\n            });\n            return;\n        }\n        // Create a controller/Request for this navigation\n        pendingNavigationController = new AbortController();\n        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n        let pendingActionData;\n        let pendingError;\n        if (opts && opts.pendingError) {\n            // If we have a pendingError, it means the user attempted a GET submission\n            // with binary FormData so assign here and skip to handleLoaders.  That\n            // way we handle calling loaders above the boundary etc.  It's not really\n            // different from an actionError in that sense.\n            pendingError = {\n                [findNearestBoundary(matches).route.id]: opts.pendingError\n            };\n        } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n            // Call action if we received an action submission\n            let actionOutput = await handleAction(request, location, opts.submission, matches, {\n                replace: opts.replace,\n                flushSync\n            });\n            if (actionOutput.shortCircuited) {\n                return;\n            }\n            pendingActionData = actionOutput.pendingActionData;\n            pendingError = actionOutput.pendingActionError;\n            loadingNavigation = getLoadingNavigation(location, opts.submission);\n            flushSync = false;\n            // Create a GET request for the loaders\n            request = new Request(request.url, {\n                signal: request.signal\n            });\n        }\n        // Call loaders\n        let { shortCircuited, loaderData, errors } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionData, pendingError);\n        if (shortCircuited) {\n            return;\n        }\n        // Clean up now that the action/loaders have completed.  Don't clean up if\n        // we short circuited because pendingNavigationController will have already\n        // been assigned to a new controller for the next navigation\n        pendingNavigationController = null;\n        completeNavigation(location, _extends({\n            matches\n        }, pendingActionData ? {\n            actionData: pendingActionData\n        } : {}, {\n            loaderData,\n            errors\n        }));\n    }\n    // Call the action matched by the leaf route for this navigation and handle\n    // redirects/errors\n    async function handleAction(request, location, submission, matches, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        interruptActiveLoads();\n        // Put us in a submitting state\n        let navigation = getSubmittingNavigation(location, submission);\n        updateState({\n            navigation\n        }, {\n            flushSync: opts.flushSync === true\n        });\n        // Call our action and get the result\n        let result;\n        let actionMatch = getTargetMatch(matches, location);\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            result = {\n                type: ResultType.error,\n                error: getInternalRouterError(405, {\n                    method: request.method,\n                    pathname: location.pathname,\n                    routeId: actionMatch.route.id\n                })\n            };\n        } else {\n            result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n            if (request.signal.aborted) {\n                return {\n                    shortCircuited: true\n                };\n            }\n        }\n        if (isRedirectResult(result)) {\n            let replace;\n            if (opts && opts.replace != null) {\n                replace = opts.replace;\n            } else {\n                // If the user didn't explicity indicate replace behavior, replace if\n                // we redirected to the exact same location we're currently at to avoid\n                // double back-buttons\n                replace = result.location === state.location.pathname + state.location.search;\n            }\n            await startRedirectNavigation(state, result, {\n                submission,\n                replace\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        if (isErrorResult(result)) {\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            // By default, all submissions are REPLACE navigations, but if the\n            // action threw an error that'll be rendered in an errorElement, we fall\n            // back to PUSH so that the user can use the back button to get back to\n            // the pre-submission form location to try again\n            if ((opts && opts.replace) !== true) {\n                pendingAction = Action.Push;\n            }\n            return {\n                // Send back an empty object we can use to clear out any prior actionData\n                pendingActionData: {},\n                pendingActionError: {\n                    [boundaryMatch.route.id]: result.error\n                }\n            };\n        }\n        if (isDeferredResult(result)) {\n            throw getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n        }\n        return {\n            pendingActionData: {\n                [actionMatch.route.id]: result.data\n            }\n        };\n    }\n    // Call all applicable loaders for the given matches, handling redirects,\n    // errors, etc.\n    async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionData, pendingError) {\n        // Figure out the right navigation we want to use for data loading\n        let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n        // If this was a redirect from an action we don't have a \"submission\" but\n        // we have it on the loading navigation so use that if available\n        let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, future.v7_partialHydration && initialHydration === true, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n        // Cancel pending deferreds for no-longer-matched routes or routes we're\n        // about to reload.  Note that if this is an action reload we would have\n        // already cancelled all pending deferreds so this would be a no-op\n        cancelActiveDeferreds((routeId)=>!(matches && matches.some((m)=>m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m)=>m.route.id === routeId));\n        pendingNavigationLoadId = ++incrementingLoadId;\n        // Short circuit if we have no loaders to run\n        if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n            let updatedFetchers = markFetchRedirectsDone();\n            completeNavigation(location, _extends({\n                matches,\n                loaderData: {},\n                // Commit pending error if we're short circuiting\n                errors: pendingError || null\n            }, pendingActionData ? {\n                actionData: pendingActionData\n            } : {}, updatedFetchers ? {\n                fetchers: new Map(state.fetchers)\n            } : {}), {\n                flushSync\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        // If this is an uninterrupted revalidation, we remain in our current idle\n        // state.  If not, we need to switch to our loading state and load data,\n        // preserving any new action data or existing action data (in the case of\n        // a revalidation interrupting an actionReload)\n        // If we have partialHydration enabled, then don't update the state for the\n        // initial data load since iot's not a \"navigation\"\n        if (!isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration)) {\n            revalidatingFetchers.forEach((rf)=>{\n                let fetcher = state.fetchers.get(rf.key);\n                let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n                state.fetchers.set(rf.key, revalidatingFetcher);\n            });\n            let actionData = pendingActionData || state.actionData;\n            updateState(_extends({\n                navigation: loadingNavigation\n            }, actionData ? Object.keys(actionData).length === 0 ? {\n                actionData: null\n            } : {\n                actionData\n            } : {}, revalidatingFetchers.length > 0 ? {\n                fetchers: new Map(state.fetchers)\n            } : {}), {\n                flushSync\n            });\n        }\n        revalidatingFetchers.forEach((rf)=>{\n            if (fetchControllers.has(rf.key)) {\n                abortFetcher(rf.key);\n            }\n            if (rf.controller) {\n                // Fetchers use an independent AbortController so that aborting a fetcher\n                // (via deleteFetcher) does not abort the triggering navigation that\n                // triggered the revalidation\n                fetchControllers.set(rf.key, rf.controller);\n            }\n        });\n        // Proxy navigation abort through to revalidation fetchers\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((f)=>abortFetcher(f.key));\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        let { results, loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n        if (request.signal.aborted) {\n            return {\n                shortCircuited: true\n            };\n        }\n        // Clean up _after_ loaders have completed.  Don't clean up if we short\n        // circuited because fetchControllers would have been aborted and\n        // reassigned to new controllers for the next navigation\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        revalidatingFetchers.forEach((rf)=>fetchControllers.delete(rf.key));\n        // If any loaders returned a redirect Response, start a new REPLACE navigation\n        let redirect = findRedirect(results);\n        if (redirect) {\n            if (redirect.idx >= matchesToLoad.length) {\n                // If this redirect came from a fetcher make sure we mark it in\n                // fetchRedirectIds so it doesn't get revalidated on the next set of\n                // loader executions\n                let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                fetchRedirectIds.add(fetcherKey);\n            }\n            await startRedirectNavigation(state, redirect.result, {\n                replace\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        // Process and commit output from loaders\n        let { loaderData, errors } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n        // Wire up subscribers to update loaderData as promises settle\n        activeDeferreds.forEach((deferredData, routeId)=>{\n            deferredData.subscribe((aborted)=>{\n                // Note: No need to updateState here since the TrackedPromise on\n                // loaderData is stable across resolve/reject\n                // Remove this instance if we were aborted or if promises have settled\n                if (aborted || deferredData.done) {\n                    activeDeferreds.delete(routeId);\n                }\n            });\n        });\n        let updatedFetchers = markFetchRedirectsDone();\n        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n        return _extends({\n            loaderData,\n            errors\n        }, shouldUpdateFetchers ? {\n            fetchers: new Map(state.fetchers)\n        } : {});\n    }\n    // Trigger a fetcher load/submit for the given fetcher key\n    function fetch(key, routeId, href, opts) {\n        if (isServer) {\n            throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n        }\n        if (fetchControllers.has(key)) abortFetcher(key);\n        let flushSync = (opts && opts.unstable_flushSync) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);\n        let matches = matchRoutes(routesToUse, normalizedPath, basename);\n        if (!matches) {\n            setFetcherError(key, routeId, getInternalRouterError(404, {\n                pathname: normalizedPath\n            }), {\n                flushSync\n            });\n            return;\n        }\n        let { path, submission, error } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n        if (error) {\n            setFetcherError(key, routeId, error, {\n                flushSync\n            });\n            return;\n        }\n        let match = getTargetMatch(matches, path);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        if (submission && isMutationMethod(submission.formMethod)) {\n            handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n            return;\n        }\n        // Store off the match so we can call it's shouldRevalidate on subsequent\n        // revalidations\n        fetchLoadMatches.set(key, {\n            routeId,\n            path\n        });\n        handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n    }\n    // Call the action for the matched fetcher.submit(), and then handle redirects,\n    // errors, and revalidation\n    async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\n        interruptActiveLoads();\n        fetchLoadMatches.delete(key);\n        if (!match.route.action && !match.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: submission.formMethod,\n                pathname: path,\n                routeId: routeId\n            });\n            setFetcherError(key, routeId, error, {\n                flushSync\n            });\n            return;\n        }\n        // Put this fetcher into it's submitting state\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n            flushSync\n        });\n        // Call the action for the fetcher\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n        if (fetchRequest.signal.aborted) {\n            // We can delete this so long as we weren't aborted by our own fetcher\n            // re-submit which would have put _new_ controller is in fetchControllers\n            if (fetchControllers.get(key) === abortController) {\n                fetchControllers.delete(key);\n            }\n            return;\n        }\n        // When using v7_fetcherPersist, we don't want errors bubbling up to the UI\n        // or redirects processed for unmounted fetchers so we just revert them to\n        // idle\n        if (future.v7_fetcherPersist && deletedFetchers.has(key)) {\n            if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n                updateFetcherState(key, getDoneFetcher(undefined));\n                return;\n            }\n        // Let SuccessResult's fall through for revalidation\n        } else {\n            if (isRedirectResult(actionResult)) {\n                fetchControllers.delete(key);\n                if (pendingNavigationLoadId > originatingLoadId) {\n                    // A new navigation was kicked off after our action started, so that\n                    // should take precedence over this redirect navigation.  We already\n                    // set isRevalidationRequired so all loaders for the new route should\n                    // fire unless opted out via shouldRevalidate\n                    updateFetcherState(key, getDoneFetcher(undefined));\n                    return;\n                } else {\n                    fetchRedirectIds.add(key);\n                    updateFetcherState(key, getLoadingFetcher(submission));\n                    return startRedirectNavigation(state, actionResult, {\n                        fetcherSubmission: submission\n                    });\n                }\n            }\n            // Process any non-redirect errors thrown\n            if (isErrorResult(actionResult)) {\n                setFetcherError(key, routeId, actionResult.error);\n                return;\n            }\n        }\n        if (isDeferredResult(actionResult)) {\n            throw getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n        }\n        // Start the data load for current matches, or the next location if we're\n        // in the middle of a navigation\n        let nextLocation = state.navigation.location || state.location;\n        let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n        invariant(matches, \"Didn't find any matches after fetcher action\");\n        let loadId = ++incrementingLoadId;\n        fetchReloadIds.set(key, loadId);\n        let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n        state.fetchers.set(key, loadFetcher);\n        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {\n            [match.route.id]: actionResult.data\n        }, undefined // No need to send through errors since we short circuit above\n        );\n        // Put all revalidating fetchers into the loading state, except for the\n        // current fetcher which we want to keep in it's current loading state which\n        // contains it's action submission info + action data\n        revalidatingFetchers.filter((rf)=>rf.key !== key).forEach((rf)=>{\n            let staleKey = rf.key;\n            let existingFetcher = state.fetchers.get(staleKey);\n            let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n            state.fetchers.set(staleKey, revalidatingFetcher);\n            if (fetchControllers.has(staleKey)) {\n                abortFetcher(staleKey);\n            }\n            if (rf.controller) {\n                fetchControllers.set(staleKey, rf.controller);\n            }\n        });\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((rf)=>abortFetcher(rf.key));\n        abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        let { results, loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n        if (abortController.signal.aborted) {\n            return;\n        }\n        abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        fetchReloadIds.delete(key);\n        fetchControllers.delete(key);\n        revalidatingFetchers.forEach((r)=>fetchControllers.delete(r.key));\n        let redirect = findRedirect(results);\n        if (redirect) {\n            if (redirect.idx >= matchesToLoad.length) {\n                // If this redirect came from a fetcher make sure we mark it in\n                // fetchRedirectIds so it doesn't get revalidated on the next set of\n                // loader executions\n                let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                fetchRedirectIds.add(fetcherKey);\n            }\n            return startRedirectNavigation(state, redirect.result);\n        }\n        // Process and commit output from loaders\n        let { loaderData, errors } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n        // Since we let revalidations complete even if the submitting fetcher was\n        // deleted, only put it back to idle if it hasn't been deleted\n        if (state.fetchers.has(key)) {\n            let doneFetcher = getDoneFetcher(actionResult.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n        abortStaleFetchLoads(loadId);\n        // If we are currently in a navigation loading state and this fetcher is\n        // more recent than the navigation, we want the newer data so abort the\n        // navigation and complete it with the fetcher data\n        if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n            invariant(pendingAction, \"Expected pending action\");\n            pendingNavigationController && pendingNavigationController.abort();\n            completeNavigation(state.navigation.location, {\n                matches,\n                loaderData,\n                errors,\n                fetchers: new Map(state.fetchers)\n            });\n        } else {\n            // otherwise just update with the fetcher data, preserving any existing\n            // loaderData for loaders that did not need to reload.  We have to\n            // manually merge here since we aren't going through completeNavigation\n            updateState({\n                errors,\n                loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n                fetchers: new Map(state.fetchers)\n            });\n            isRevalidationRequired = false;\n        }\n    }\n    // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n    async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {\n            flushSync\n        });\n        // Call the loader for this fetcher route match\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n        // Deferred isn't supported for fetcher loads, await everything and treat it\n        // as a normal load.  resolveDeferredData will return undefined if this\n        // fetcher gets aborted, so we just leave result untouched and short circuit\n        // below if that happens\n        if (isDeferredResult(result)) {\n            result = await resolveDeferredData(result, fetchRequest.signal, true) || result;\n        }\n        // We can delete this so long as we weren't aborted by our our own fetcher\n        // re-load which would have put _new_ controller is in fetchControllers\n        if (fetchControllers.get(key) === abortController) {\n            fetchControllers.delete(key);\n        }\n        if (fetchRequest.signal.aborted) {\n            return;\n        }\n        // We don't want errors bubbling up or redirects followed for unmounted\n        // fetchers, so short circuit here if it was removed from the UI\n        if (deletedFetchers.has(key)) {\n            updateFetcherState(key, getDoneFetcher(undefined));\n            return;\n        }\n        // If the loader threw a redirect Response, start a new REPLACE navigation\n        if (isRedirectResult(result)) {\n            if (pendingNavigationLoadId > originatingLoadId) {\n                // A new navigation was kicked off after our loader started, so that\n                // should take precedence over this redirect navigation\n                updateFetcherState(key, getDoneFetcher(undefined));\n                return;\n            } else {\n                fetchRedirectIds.add(key);\n                await startRedirectNavigation(state, result);\n                return;\n            }\n        }\n        // Process any non-redirect errors thrown\n        if (isErrorResult(result)) {\n            setFetcherError(key, routeId, result.error);\n            return;\n        }\n        invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n        // Put the fetcher back into an idle state\n        updateFetcherState(key, getDoneFetcher(result.data));\n    }\n    /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */ async function startRedirectNavigation(state, redirect, _temp2) {\n        let { submission, fetcherSubmission, replace } = _temp2 === void 0 ? {} : _temp2;\n        if (redirect.revalidate) {\n            isRevalidationRequired = true;\n        }\n        let redirectLocation = createLocation(state.location, redirect.location, {\n            _isRedirect: true\n        });\n        invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n        if (isBrowser) {\n            let isDocumentReload = false;\n            if (redirect.reloadDocument) {\n                // Hard reload if the response contained X-Remix-Reload-Document\n                isDocumentReload = true;\n            } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n                const url = init.history.createURL(redirect.location);\n                isDocumentReload = // Hard reload if it's an absolute URL to a new origin\n                url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n                stripBasename(url.pathname, basename) == null;\n            }\n            if (isDocumentReload) {\n                if (replace) {\n                    routerWindow.location.replace(redirect.location);\n                } else {\n                    routerWindow.location.assign(redirect.location);\n                }\n                return;\n            }\n        }\n        // There's no need to abort on redirects, since we don't detect the\n        // redirect until the action/loaders have settled\n        pendingNavigationController = null;\n        let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n        // Use the incoming submission if provided, fallback on the active one in\n        // state.navigation\n        let { formMethod, formAction, formEncType } = state.navigation;\n        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n            submission = getSubmissionFromNavigation(state.navigation);\n        }\n        // If this was a 307/308 submission we want to preserve the HTTP method and\n        // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n        // redirected location\n        let activeSubmission = submission || fetcherSubmission;\n        if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n            await startNavigation(redirectHistoryAction, redirectLocation, {\n                submission: _extends({}, activeSubmission, {\n                    formAction: redirect.location\n                }),\n                // Preserve this flag across redirects\n                preventScrollReset: pendingPreventScrollReset\n            });\n        } else {\n            // If we have a navigation submission, we will preserve it through the\n            // redirect navigation\n            let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n            await startNavigation(redirectHistoryAction, redirectLocation, {\n                overrideNavigation,\n                // Send fetcher submissions through for shouldRevalidate\n                fetcherSubmission,\n                // Preserve this flag across redirects\n                preventScrollReset: pendingPreventScrollReset\n            });\n        }\n    }\n    async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n        // Call all navigation loaders and revalidating fetcher loaders in parallel,\n        // then slice off the results into separate arrays so we can handle them\n        // accordingly\n        let results = await Promise.all([\n            ...matchesToLoad.map((match)=>callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath)),\n            ...fetchersToLoad.map((f)=>{\n                if (f.matches && f.match && f.controller) {\n                    return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath);\n                } else {\n                    let error = {\n                        type: ResultType.error,\n                        error: getInternalRouterError(404, {\n                            pathname: f.path\n                        })\n                    };\n                    return error;\n                }\n            })\n        ]);\n        let loaderResults = results.slice(0, matchesToLoad.length);\n        let fetcherResults = results.slice(matchesToLoad.length);\n        await Promise.all([\n            resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(()=>request.signal), false, state.loaderData),\n            resolveDeferredResults(currentMatches, fetchersToLoad.map((f)=>f.match), fetcherResults, fetchersToLoad.map((f)=>f.controller ? f.controller.signal : null), true)\n        ]);\n        return {\n            results,\n            loaderResults,\n            fetcherResults\n        };\n    }\n    function interruptActiveLoads() {\n        // Every interruption triggers a revalidation\n        isRevalidationRequired = true;\n        // Cancel pending route-level deferreds and mark cancelled routes for\n        // revalidation\n        cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n        // Abort in-flight fetcher loads\n        fetchLoadMatches.forEach((_, key)=>{\n            if (fetchControllers.has(key)) {\n                cancelledFetcherLoads.push(key);\n                abortFetcher(key);\n            }\n        });\n    }\n    function updateFetcherState(key, fetcher, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        state.fetchers.set(key, fetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function setFetcherError(key, routeId, error, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        let boundaryMatch = findNearestBoundary(state.matches, routeId);\n        deleteFetcher(key);\n        updateState({\n            errors: {\n                [boundaryMatch.route.id]: error\n            },\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function getFetcher(key) {\n        if (future.v7_fetcherPersist) {\n            activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n            // If this fetcher was previously marked for deletion, unmark it since we\n            // have a new instance\n            if (deletedFetchers.has(key)) {\n                deletedFetchers.delete(key);\n            }\n        }\n        return state.fetchers.get(key) || IDLE_FETCHER;\n    }\n    function deleteFetcher(key) {\n        let fetcher = state.fetchers.get(key);\n        // Don't abort the controller if this is a deletion of a fetcher.submit()\n        // in it's loading phase since - we don't want to abort the corresponding\n        // revalidation and want them to complete and land\n        if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n            abortFetcher(key);\n        }\n        fetchLoadMatches.delete(key);\n        fetchReloadIds.delete(key);\n        fetchRedirectIds.delete(key);\n        deletedFetchers.delete(key);\n        state.fetchers.delete(key);\n    }\n    function deleteFetcherAndUpdateState(key) {\n        if (future.v7_fetcherPersist) {\n            let count = (activeFetchers.get(key) || 0) - 1;\n            if (count <= 0) {\n                activeFetchers.delete(key);\n                deletedFetchers.add(key);\n            } else {\n                activeFetchers.set(key, count);\n            }\n        } else {\n            deleteFetcher(key);\n        }\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    function abortFetcher(key) {\n        let controller = fetchControllers.get(key);\n        invariant(controller, \"Expected fetch controller: \" + key);\n        controller.abort();\n        fetchControllers.delete(key);\n    }\n    function markFetchersDone(keys) {\n        for (let key of keys){\n            let fetcher = getFetcher(key);\n            let doneFetcher = getDoneFetcher(fetcher.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    function markFetchRedirectsDone() {\n        let doneKeys = [];\n        let updatedFetchers = false;\n        for (let key of fetchRedirectIds){\n            let fetcher = state.fetchers.get(key);\n            invariant(fetcher, \"Expected fetcher: \" + key);\n            if (fetcher.state === \"loading\") {\n                fetchRedirectIds.delete(key);\n                doneKeys.push(key);\n                updatedFetchers = true;\n            }\n        }\n        markFetchersDone(doneKeys);\n        return updatedFetchers;\n    }\n    function abortStaleFetchLoads(landedId) {\n        let yeetedKeys = [];\n        for (let [key, id] of fetchReloadIds){\n            if (id < landedId) {\n                let fetcher = state.fetchers.get(key);\n                invariant(fetcher, \"Expected fetcher: \" + key);\n                if (fetcher.state === \"loading\") {\n                    abortFetcher(key);\n                    fetchReloadIds.delete(key);\n                    yeetedKeys.push(key);\n                }\n            }\n        }\n        markFetchersDone(yeetedKeys);\n        return yeetedKeys.length > 0;\n    }\n    function getBlocker(key, fn) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        if (blockerFunctions.get(key) !== fn) {\n            blockerFunctions.set(key, fn);\n        }\n        return blocker;\n    }\n    function deleteBlocker(key) {\n        state.blockers.delete(key);\n        blockerFunctions.delete(key);\n    }\n    // Utility function to update blockers, ensuring valid state transitions\n    function updateBlocker(key, newBlocker) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        // Poor mans state machine :)\n        // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n        invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n        let blockers = new Map(state.blockers);\n        blockers.set(key, newBlocker);\n        updateState({\n            blockers\n        });\n    }\n    function shouldBlockNavigation(_ref2) {\n        let { currentLocation, nextLocation, historyAction } = _ref2;\n        if (blockerFunctions.size === 0) {\n            return;\n        }\n        // We ony support a single active blocker at the moment since we don't have\n        // any compelling use cases for multi-blocker yet\n        if (blockerFunctions.size > 1) {\n            warning(false, \"A router only supports one blocker at a time\");\n        }\n        let entries = Array.from(blockerFunctions.entries());\n        let [blockerKey, blockerFunction] = entries[entries.length - 1];\n        let blocker = state.blockers.get(blockerKey);\n        if (blocker && blocker.state === \"proceeding\") {\n            // If the blocker is currently proceeding, we don't need to re-check\n            // it and can let this navigation continue\n            return;\n        }\n        // At this point, we know we're unblocked/blocked so we need to check the\n        // user-provided blocker function\n        if (blockerFunction({\n            currentLocation,\n            nextLocation,\n            historyAction\n        })) {\n            return blockerKey;\n        }\n    }\n    function cancelActiveDeferreds(predicate) {\n        let cancelledRouteIds = [];\n        activeDeferreds.forEach((dfd, routeId)=>{\n            if (!predicate || predicate(routeId)) {\n                // Cancel the deferred - but do not remove from activeDeferreds here -\n                // we rely on the subscribers to do that so our tests can assert proper\n                // cleanup via _internalActiveDeferreds\n                dfd.cancel();\n                cancelledRouteIds.push(routeId);\n                activeDeferreds.delete(routeId);\n            }\n        });\n        return cancelledRouteIds;\n    }\n    // Opt in to capturing and reporting scroll positions during navigations,\n    // used by the <ScrollRestoration> component\n    function enableScrollRestoration(positions, getPosition, getKey) {\n        savedScrollPositions = positions;\n        getScrollPosition = getPosition;\n        getScrollRestorationKey = getKey || null;\n        // Perform initial hydration scroll restoration, since we miss the boat on\n        // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n        // and therefore have no savedScrollPositions available\n        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n            initialScrollRestored = true;\n            let y = getSavedScrollPosition(state.location, state.matches);\n            if (y != null) {\n                updateState({\n                    restoreScrollPosition: y\n                });\n            }\n        }\n        return ()=>{\n            savedScrollPositions = null;\n            getScrollPosition = null;\n            getScrollRestorationKey = null;\n        };\n    }\n    function getScrollKey(location, matches) {\n        if (getScrollRestorationKey) {\n            let key = getScrollRestorationKey(location, matches.map((m)=>convertRouteMatchToUiMatch(m, state.loaderData)));\n            return key || location.key;\n        }\n        return location.key;\n    }\n    function saveScrollPosition(location, matches) {\n        if (savedScrollPositions && getScrollPosition) {\n            let key = getScrollKey(location, matches);\n            savedScrollPositions[key] = getScrollPosition();\n        }\n    }\n    function getSavedScrollPosition(location, matches) {\n        if (savedScrollPositions) {\n            let key = getScrollKey(location, matches);\n            let y = savedScrollPositions[key];\n            if (typeof y === \"number\") {\n                return y;\n            }\n        }\n        return null;\n    }\n    function _internalSetRoutes(newRoutes) {\n        manifest = {};\n        inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n    }\n    router = {\n        get basename () {\n            return basename;\n        },\n        get future () {\n            return future;\n        },\n        get state () {\n            return state;\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        get window () {\n            return routerWindow;\n        },\n        initialize,\n        subscribe,\n        enableScrollRestoration,\n        navigate,\n        fetch,\n        revalidate,\n        // Passthrough to history-aware createHref used by useHref so we get proper\n        // hash-aware URLs in DOM paths\n        createHref: (to)=>init.history.createHref(to),\n        encodeLocation: (to)=>init.history.encodeLocation(to),\n        getFetcher,\n        deleteFetcher: deleteFetcherAndUpdateState,\n        dispose,\n        getBlocker,\n        deleteBlocker,\n        _internalFetchControllers: fetchControllers,\n        _internalActiveDeferreds: activeDeferreds,\n        // TODO: Remove setRoutes, it's temporary to avoid dealing with\n        // updating the tree while validating the update algorithm.\n        _internalSetRoutes\n    };\n    return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction createStaticHandler(routes, opts) {\n    invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n    let manifest = {};\n    let basename = (opts ? opts.basename : null) || \"/\";\n    let mapRouteProperties;\n    if (opts != null && opts.mapRouteProperties) {\n        mapRouteProperties = opts.mapRouteProperties;\n    } else if (opts != null && opts.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        let detectErrorBoundary = opts.detectErrorBoundary;\n        mapRouteProperties = (route)=>({\n                hasErrorBoundary: detectErrorBoundary(route)\n            });\n    } else {\n        mapRouteProperties = defaultMapRouteProperties;\n    }\n    // Config driven behavior flags\n    let future = _extends({\n        v7_relativeSplatPath: false\n    }, opts ? opts.future : null);\n    let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n    /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */ async function query(request, _temp3) {\n        let { requestContext } = _temp3 === void 0 ? {} : _temp3;\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        // SSR supports HEAD requests while SPA doesn't\n        if (!isValidMethod(method) && method !== \"HEAD\") {\n            let error = getInternalRouterError(405, {\n                method\n            });\n            let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);\n            return {\n                basename,\n                location,\n                matches: methodNotAllowedMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        } else if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);\n            return {\n                basename,\n                location,\n                matches: notFoundMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        let result = await queryImpl(request, location, matches, requestContext);\n        if (isResponse(result)) {\n            return result;\n        }\n        // When returning StaticHandlerContext, we patch back in the location here\n        // since we need it for React Context.  But this helps keep our submit and\n        // loadRouteData operating on a Request instead of a Location\n        return _extends({\n            location,\n            basename\n        }, result);\n    }\n    /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */ async function queryRoute(request, _temp4) {\n        let { routeId, requestContext } = _temp4 === void 0 ? {} : _temp4;\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        // SSR supports HEAD requests while SPA doesn't\n        if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n            throw getInternalRouterError(405, {\n                method\n            });\n        } else if (!matches) {\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let match = routeId ? matches.find((m)=>m.route.id === routeId) : getTargetMatch(matches, location);\n        if (routeId && !match) {\n            throw getInternalRouterError(403, {\n                pathname: location.pathname,\n                routeId\n            });\n        } else if (!match) {\n            // This should never hit I don't think?\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let result = await queryImpl(request, location, matches, requestContext, match);\n        if (isResponse(result)) {\n            return result;\n        }\n        let error = result.errors ? Object.values(result.errors)[0] : undefined;\n        if (error !== undefined) {\n            // If we got back result.errors, that means the loader/action threw\n            // _something_ that wasn't a Response, but it's not guaranteed/required\n            // to be an `instanceof Error` either, so we have to use throw here to\n            // preserve the \"error\" state outside of queryImpl.\n            throw error;\n        }\n        // Pick off the right state value to return\n        if (result.actionData) {\n            return Object.values(result.actionData)[0];\n        }\n        if (result.loaderData) {\n            var _result$activeDeferre;\n            let data = Object.values(result.loaderData)[0];\n            if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n                data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n            }\n            return data;\n        }\n        return undefined;\n    }\n    async function queryImpl(request, location, matches, requestContext, routeMatch) {\n        invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n        try {\n            if (isMutationMethod(request.method.toLowerCase())) {\n                let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\n                return result;\n            }\n            let result = await loadRouteData(request, matches, requestContext, routeMatch);\n            return isResponse(result) ? result : _extends({}, result, {\n                actionData: null,\n                actionHeaders: {}\n            });\n        } catch (e) {\n            // If the user threw/returned a Response in callLoaderOrAction, we throw\n            // it to bail out and then return or throw here based on whether the user\n            // returned or threw\n            if (isQueryRouteResponse(e)) {\n                if (e.type === ResultType.error) {\n                    throw e.response;\n                }\n                return e.response;\n            }\n            // Redirects are always returned since they don't propagate to catch\n            // boundaries\n            if (isRedirectResponse(e)) {\n                return e;\n            }\n            throw e;\n        }\n    }\n    async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n        let result;\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: actionMatch.route.id\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: ResultType.error,\n                error\n            };\n        } else {\n            result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath, {\n                isStaticRequest: true,\n                isRouteRequest,\n                requestContext\n            });\n            if (request.signal.aborted) {\n                let method = isRouteRequest ? \"queryRoute\" : \"query\";\n                throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n            }\n        }\n        if (isRedirectResult(result)) {\n            // Uhhhh - this should never happen, we should always throw these from\n            // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n            // can get back on the \"throw all redirect responses\" train here should\n            // this ever happen :/\n            throw new Response(null, {\n                status: result.status,\n                headers: {\n                    Location: result.location\n                }\n            });\n        }\n        if (isDeferredResult(result)) {\n            let error = getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: ResultType.error,\n                error\n            };\n        }\n        if (isRouteRequest) {\n            // Note: This should only be non-Response values if we get here, since\n            // isRouteRequest should throw any Response received in callLoaderOrAction\n            if (isErrorResult(result)) {\n                throw result.error;\n            }\n            return {\n                matches: [\n                    actionMatch\n                ],\n                loaderData: {},\n                actionData: {\n                    [actionMatch.route.id]: result.data\n                },\n                errors: null,\n                // Note: statusCode + headers are unused here since queryRoute will\n                // return the raw Response or value\n                statusCode: 200,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        if (isErrorResult(result)) {\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            let context = await loadRouteData(request, matches, requestContext, undefined, {\n                [boundaryMatch.route.id]: result.error\n            });\n            // action status codes take precedence over loader status codes\n            return _extends({}, context, {\n                statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n                actionData: null,\n                actionHeaders: _extends({}, result.headers ? {\n                    [actionMatch.route.id]: result.headers\n                } : {})\n            });\n        }\n        // Create a GET request for the loaders\n        let loaderRequest = new Request(request.url, {\n            headers: request.headers,\n            redirect: request.redirect,\n            signal: request.signal\n        });\n        let context = await loadRouteData(loaderRequest, matches, requestContext);\n        return _extends({}, context, result.statusCode ? {\n            statusCode: result.statusCode\n        } : {}, {\n            actionData: {\n                [actionMatch.route.id]: result.data\n            },\n            actionHeaders: _extends({}, result.headers ? {\n                [actionMatch.route.id]: result.headers\n            } : {})\n        });\n    }\n    async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n        let isRouteRequest = routeMatch != null;\n        // Short circuit if we have no loaders to run (queryRoute())\n        if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n            throw getInternalRouterError(400, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: routeMatch == null ? void 0 : routeMatch.route.id\n            });\n        }\n        let requestMatches = routeMatch ? [\n            routeMatch\n        ] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n        let matchesToLoad = requestMatches.filter((m)=>m.route.loader || m.route.lazy);\n        // Short circuit if we have no loaders to run (query())\n        if (matchesToLoad.length === 0) {\n            return {\n                matches,\n                // Add a null for all matched routes for proper revalidation on the client\n                loaderData: matches.reduce((acc, m)=>Object.assign(acc, {\n                        [m.route.id]: null\n                    }), {}),\n                errors: pendingActionError || null,\n                statusCode: 200,\n                loaderHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        let results = await Promise.all([\n            ...matchesToLoad.map((match)=>callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, future.v7_relativeSplatPath, {\n                    isStaticRequest: true,\n                    isRouteRequest,\n                    requestContext\n                }))\n        ]);\n        if (request.signal.aborted) {\n            let method = isRouteRequest ? \"queryRoute\" : \"query\";\n            throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n        }\n        // Process and commit output from loaders\n        let activeDeferreds = new Map();\n        let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n        // Add a null for any non-loader matches for proper revalidation on the client\n        let executedLoaders = new Set(matchesToLoad.map((match)=>match.route.id));\n        matches.forEach((match)=>{\n            if (!executedLoaders.has(match.route.id)) {\n                context.loaderData[match.route.id] = null;\n            }\n        });\n        return _extends({}, context, {\n            matches,\n            activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n        });\n    }\n    return {\n        dataRoutes,\n        query,\n        queryRoute\n    };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */ function getStaticContextFromError(routes, context, error) {\n    let newContext = _extends({}, context, {\n        statusCode: 500,\n        errors: {\n            [context._deepestRenderedBoundaryId || routes[0].id]: error\n        }\n    });\n    return newContext;\n}\nfunction isSubmissionNavigation(opts) {\n    return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {\n    let contextualMatches;\n    let activeRouteMatch;\n    if (fromRouteId) {\n        // Grab matches up to the calling route so our route-relative logic is\n        // relative to the correct source route\n        contextualMatches = [];\n        for (let match of matches){\n            contextualMatches.push(match);\n            if (match.route.id === fromRouteId) {\n                activeRouteMatch = match;\n                break;\n            }\n        }\n    } else {\n        contextualMatches = matches;\n        activeRouteMatch = matches[matches.length - 1];\n    }\n    // Resolve the relative path\n    let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n    // When `to` is not specified we inherit search/hash from the current\n    // location, unlike when to=\".\" and we just inherit the path.\n    // See https://github.com/remix-run/remix/issues/927\n    if (to == null) {\n        path.search = location.search;\n        path.hash = location.hash;\n    }\n    // Add an ?index param for matched index routes if we don't already have one\n    if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    // If we're operating within a basename, prepend it to the pathname.  If\n    // this is a root navigation, then just use the raw basename which allows\n    // the basename to have full control over the presence of a trailing slash\n    // on root actions\n    if (prependBasename && basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n            basename,\n            path.pathname\n        ]);\n    }\n    return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n    // Return location verbatim on non-submission navigations\n    if (!opts || !isSubmissionNavigation(opts)) {\n        return {\n            path\n        };\n    }\n    if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n        return {\n            path,\n            error: getInternalRouterError(405, {\n                method: opts.formMethod\n            })\n        };\n    }\n    let getInvalidBodyError = ()=>({\n            path,\n            error: getInternalRouterError(400, {\n                type: \"invalid-body\"\n            })\n        });\n    // Create a Submission on non-GET navigations\n    let rawFormMethod = opts.formMethod || \"get\";\n    let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n    let formAction = stripHashFromPath(path);\n    if (opts.body !== undefined) {\n        if (opts.formEncType === \"text/plain\") {\n            // text only support POST/PUT/PATCH/DELETE submissions\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce((acc, _ref3)=>{\n                let [name, value] = _ref3;\n                return \"\" + acc + name + \"=\" + value + \"\\n\";\n            }, \"\") : String(opts.body);\n            return {\n                path,\n                submission: {\n                    formMethod,\n                    formAction,\n                    formEncType: opts.formEncType,\n                    formData: undefined,\n                    json: undefined,\n                    text\n                }\n            };\n        } else if (opts.formEncType === \"application/json\") {\n            // json only supports POST/PUT/PATCH/DELETE submissions\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            try {\n                let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n                return {\n                    path,\n                    submission: {\n                        formMethod,\n                        formAction,\n                        formEncType: opts.formEncType,\n                        formData: undefined,\n                        json,\n                        text: undefined\n                    }\n                };\n            } catch (e) {\n                return getInvalidBodyError();\n            }\n        }\n    }\n    invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n    let searchParams;\n    let formData;\n    if (opts.formData) {\n        searchParams = convertFormDataToSearchParams(opts.formData);\n        formData = opts.formData;\n    } else if (opts.body instanceof FormData) {\n        searchParams = convertFormDataToSearchParams(opts.body);\n        formData = opts.body;\n    } else if (opts.body instanceof URLSearchParams) {\n        searchParams = opts.body;\n        formData = convertSearchParamsToFormData(searchParams);\n    } else if (opts.body == null) {\n        searchParams = new URLSearchParams();\n        formData = new FormData();\n    } else {\n        try {\n            searchParams = new URLSearchParams(opts.body);\n            formData = convertSearchParamsToFormData(searchParams);\n        } catch (e) {\n            return getInvalidBodyError();\n        }\n    }\n    let submission = {\n        formMethod,\n        formAction,\n        formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n        formData,\n        json: undefined,\n        text: undefined\n    };\n    if (isMutationMethod(submission.formMethod)) {\n        return {\n            path,\n            submission\n        };\n    }\n    // Flatten submission onto URLSearchParams for GET submissions\n    let parsedPath = parsePath(path);\n    // On GET navigation submissions we can drop the ?index param from the\n    // resulting location since all loaders will run.  But fetcher GET submissions\n    // only run a single loader so we need to preserve any incoming ?index params\n    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n        searchParams.append(\"index\", \"\");\n    }\n    parsedPath.search = \"?\" + searchParams;\n    return {\n        path: createPath(parsedPath),\n        submission\n    };\n}\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n    let boundaryMatches = matches;\n    if (boundaryId) {\n        let index = matches.findIndex((m)=>m.route.id === boundaryId);\n        if (index >= 0) {\n            boundaryMatches = matches.slice(0, index);\n        }\n    }\n    return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isInitialLoad, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n    let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n    let currentUrl = history.createURL(state.location);\n    let nextUrl = history.createURL(location);\n    // Pick navigation matches that are net-new or qualify for revalidation\n    let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n    let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n    let navigationMatches = boundaryMatches.filter((match, index)=>{\n        let { route } = match;\n        if (route.lazy) {\n            // We haven't loaded this route yet so we don't know if it's got a loader!\n            return true;\n        }\n        if (route.loader == null) {\n            return false;\n        }\n        if (isInitialLoad) {\n            if (route.loader.hydrate) {\n                return true;\n            }\n            return state.loaderData[route.id] === undefined && // Don't re-run if the loader ran and threw an error\n            (!state.errors || state.errors[route.id] === undefined);\n        }\n        // Always call the loader on new route instances and pending defer cancellations\n        if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id)=>id === match.route.id)) {\n            return true;\n        }\n        // This is the default implementation for when we revalidate.  If the route\n        // provides it's own implementation, then we give them full control but\n        // provide this value so they can leverage it if needed after they check\n        // their own specific use cases\n        let currentRouteMatch = state.matches[index];\n        let nextRouteMatch = match;\n        return shouldRevalidateLoader(match, _extends({\n            currentUrl,\n            currentParams: currentRouteMatch.params,\n            nextUrl,\n            nextParams: nextRouteMatch.params\n        }, submission, {\n            actionResult,\n            defaultShouldRevalidate: // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n            isRevalidationRequired || // Clicked the same link, resubmitted a GET form\n            currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n            currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n        }));\n    });\n    // Pick fetcher.loads that need to be revalidated\n    let revalidatingFetchers = [];\n    fetchLoadMatches.forEach((f, key)=>{\n        // Don't revalidate:\n        //  - on initial load (shouldn't be any fetchers then anyway)\n        //  - if fetcher won't be present in the subsequent render\n        //    - no longer matches the URL (v7_fetcherPersist=false)\n        //    - was unmounted but persisted due to v7_fetcherPersist=true\n        if (isInitialLoad || !matches.some((m)=>m.route.id === f.routeId) || deletedFetchers.has(key)) {\n            return;\n        }\n        let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n        // If the fetcher path no longer matches, push it in with null matches so\n        // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n        // currently only a use-case for Remix HMR where the route tree can change\n        // at runtime and remove a route previously loaded via a fetcher\n        if (!fetcherMatches) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: null,\n                match: null,\n                controller: null\n            });\n            return;\n        }\n        // Revalidating fetchers are decoupled from the route matches since they\n        // load from a static href.  They revalidate based on explicit revalidation\n        // (submission, useRevalidator, or X-Remix-Revalidate)\n        let fetcher = state.fetchers.get(key);\n        let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n        let shouldRevalidate = false;\n        if (fetchRedirectIds.has(key)) {\n            // Never trigger a revalidation of an actively redirecting fetcher\n            shouldRevalidate = false;\n        } else if (cancelledFetcherLoads.includes(key)) {\n            // Always revalidate if the fetcher was cancelled\n            shouldRevalidate = true;\n        } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\n            // If the fetcher hasn't ever completed loading yet, then this isn't a\n            // revalidation, it would just be a brand new load if an explicit\n            // revalidation is required\n            shouldRevalidate = isRevalidationRequired;\n        } else {\n            // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n            // to explicit revalidations only\n            shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n                currentUrl,\n                currentParams: state.matches[state.matches.length - 1].params,\n                nextUrl,\n                nextParams: matches[matches.length - 1].params\n            }, submission, {\n                actionResult,\n                defaultShouldRevalidate: isRevalidationRequired\n            }));\n        }\n        if (shouldRevalidate) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: fetcherMatches,\n                match: fetcherMatch,\n                controller: new AbortController()\n            });\n        }\n    });\n    return [\n        navigationMatches,\n        revalidatingFetchers\n    ];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n    let isNew = // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n    // Handle the case that we don't have data for a re-used route, potentially\n    // from a prior error or from a cancelled pending deferred\n    let isMissingData = currentLoaderData[match.route.id] === undefined;\n    // Always load if this is a net-new route or we don't yet have data\n    return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n    let currentPath = currentMatch.route.path;\n    return(// param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]);\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n    if (loaderMatch.route.shouldRevalidate) {\n        let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n        if (typeof routeChoice === \"boolean\") {\n            return routeChoice;\n        }\n    }\n    return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */ async function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n    if (!route.lazy) {\n        return;\n    }\n    let lazyRoute = await route.lazy();\n    // If the lazy route function was executed and removed by another parallel\n    // call then we can return - first lazy() to finish wins because the return\n    // value of lazy is expected to be static\n    if (!route.lazy) {\n        return;\n    }\n    let routeToUpdate = manifest[route.id];\n    invariant(routeToUpdate, \"No route found in manifest\");\n    // Update the route in place.  This should be safe because there's no way\n    // we could yet be sitting on this route as we can't get there without\n    // resolving lazy() first.\n    //\n    // This is different than the HMR \"update\" use-case where we may actively be\n    // on the route being updated.  The main concern boils down to \"does this\n    // mutation affect any ongoing navigations or any current state.matches\n    // values?\".  If not, it should be safe to update in place.\n    let routeUpdates = {};\n    for(let lazyRouteProperty in lazyRoute){\n        let staticRouteValue = routeToUpdate[lazyRouteProperty];\n        let isPropertyStaticallyDefined = staticRouteValue !== undefined && // This property isn't static since it should always be updated based\n        // on the route updates\n        lazyRouteProperty !== \"hasErrorBoundary\";\n        warning(!isPropertyStaticallyDefined, 'Route \"' + routeToUpdate.id + '\" has a static property \"' + lazyRouteProperty + '\" ' + \"defined but its lazy function is also returning a value for this property. \" + ('The lazy route property \"' + lazyRouteProperty + '\" will be ignored.'));\n        if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n            routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n        }\n    }\n    // Mutate the route with the provided updates.  Do this first so we pass\n    // the updated version to mapRouteProperties\n    Object.assign(routeToUpdate, routeUpdates);\n    // Mutate the `hasErrorBoundary` property on the route based on the route\n    // updates and remove the `lazy` function so we don't resolve the lazy\n    // route again.\n    Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n        lazy: undefined\n    }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, v7_relativeSplatPath, opts) {\n    if (opts === void 0) {\n        opts = {};\n    }\n    let resultType;\n    let result;\n    let onReject;\n    let runHandler = (handler)=>{\n        // Setup a promise we can race against so that abort signals short circuit\n        let reject;\n        let abortPromise = new Promise((_, r)=>reject = r);\n        onReject = ()=>reject();\n        request.signal.addEventListener(\"abort\", onReject);\n        return Promise.race([\n            handler({\n                request,\n                params: match.params,\n                context: opts.requestContext\n            }),\n            abortPromise\n        ]);\n    };\n    try {\n        let handler = match.route[type];\n        if (match.route.lazy) {\n            if (handler) {\n                // Run statically defined handler in parallel with lazy()\n                let handlerError;\n                let values = await Promise.all([\n                    // If the handler throws, don't let it immediately bubble out,\n                    // since we need to let the lazy() execution finish so we know if this\n                    // route has a boundary that can handle the error\n                    runHandler(handler).catch((e)=>{\n                        handlerError = e;\n                    }),\n                    loadLazyRouteModule(match.route, mapRouteProperties, manifest)\n                ]);\n                if (handlerError) {\n                    throw handlerError;\n                }\n                result = values[0];\n            } else {\n                // Load lazy route module, then run any returned handler\n                await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n                handler = match.route[type];\n                if (handler) {\n                    // Handler still run even if we got interrupted to maintain consistency\n                    // with un-abortable behavior of handler execution on non-lazy or\n                    // previously-lazy-loaded routes\n                    result = await runHandler(handler);\n                } else if (type === \"action\") {\n                    let url = new URL(request.url);\n                    let pathname = url.pathname + url.search;\n                    throw getInternalRouterError(405, {\n                        method: request.method,\n                        pathname,\n                        routeId: match.route.id\n                    });\n                } else {\n                    // lazy() route has no loader to run.  Short circuit here so we don't\n                    // hit the invariant below that errors on returning undefined.\n                    return {\n                        type: ResultType.data,\n                        data: undefined\n                    };\n                }\n            }\n        } else if (!handler) {\n            let url = new URL(request.url);\n            let pathname = url.pathname + url.search;\n            throw getInternalRouterError(404, {\n                pathname\n            });\n        } else {\n            result = await runHandler(handler);\n        }\n        invariant(result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + ('\"' + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n    } catch (e) {\n        resultType = ResultType.error;\n        result = e;\n    } finally{\n        if (onReject) {\n            request.signal.removeEventListener(\"abort\", onReject);\n        }\n    }\n    if (isResponse(result)) {\n        let status = result.status;\n        // Process redirects\n        if (redirectStatusCodes.has(status)) {\n            let location = result.headers.get(\"Location\");\n            invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n            // Support relative routing in internal redirects\n            if (!ABSOLUTE_URL_REGEX.test(location)) {\n                location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location, v7_relativeSplatPath);\n            } else if (!opts.isStaticRequest) {\n                // Strip off the protocol+origin for same-origin + same-basename absolute\n                // redirects. If this is a static request, we can let it go back to the\n                // browser as-is\n                let currentUrl = new URL(request.url);\n                let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n                let isSameBasename = stripBasename(url.pathname, basename) != null;\n                if (url.origin === currentUrl.origin && isSameBasename) {\n                    location = url.pathname + url.search + url.hash;\n                }\n            }\n            // Don't process redirects in the router during static requests requests.\n            // Instead, throw the Response and let the server handle it with an HTTP\n            // redirect.  We also update the Location header in place in this flow so\n            // basename and relative routing is taken into account\n            if (opts.isStaticRequest) {\n                result.headers.set(\"Location\", location);\n                throw result;\n            }\n            return {\n                type: ResultType.redirect,\n                status,\n                location,\n                revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n                reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null\n            };\n        }\n        // For SSR single-route requests, we want to hand Responses back directly\n        // without unwrapping.  We do this with the QueryRouteResponse wrapper\n        // interface so we can know whether it was returned or thrown\n        if (opts.isRouteRequest) {\n            let queryRouteResponse = {\n                type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n                response: result\n            };\n            throw queryRouteResponse;\n        }\n        let data;\n        try {\n            let contentType = result.headers.get(\"Content-Type\");\n            // Check between word boundaries instead of startsWith() due to the last\n            // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n            if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n                if (result.body == null) {\n                    data = null;\n                } else {\n                    data = await result.json();\n                }\n            } else {\n                data = await result.text();\n            }\n        } catch (e) {\n            return {\n                type: ResultType.error,\n                error: e\n            };\n        }\n        if (resultType === ResultType.error) {\n            return {\n                type: resultType,\n                error: new ErrorResponseImpl(status, result.statusText, data),\n                headers: result.headers\n            };\n        }\n        return {\n            type: ResultType.data,\n            data,\n            statusCode: result.status,\n            headers: result.headers\n        };\n    }\n    if (resultType === ResultType.error) {\n        return {\n            type: resultType,\n            error: result\n        };\n    }\n    if (isDeferredData(result)) {\n        var _result$init, _result$init2;\n        return {\n            type: ResultType.deferred,\n            deferredData: result,\n            statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n            headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n        };\n    }\n    return {\n        type: ResultType.data,\n        data: result\n    };\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n    let url = history.createURL(stripHashFromPath(location)).toString();\n    let init = {\n        signal\n    };\n    if (submission && isMutationMethod(submission.formMethod)) {\n        let { formMethod, formEncType } = submission;\n        // Didn't think we needed this but it turns out unlike other methods, patch\n        // won't be properly normalized to uppercase and results in a 405 error.\n        // See: https://fetch.spec.whatwg.org/#concept-method\n        init.method = formMethod.toUpperCase();\n        if (formEncType === \"application/json\") {\n            init.headers = new Headers({\n                \"Content-Type\": formEncType\n            });\n            init.body = JSON.stringify(submission.json);\n        } else if (formEncType === \"text/plain\") {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = submission.text;\n        } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = convertFormDataToSearchParams(submission.formData);\n        } else {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = submission.formData;\n        }\n    }\n    return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n    let searchParams = new URLSearchParams();\n    for (let [key, value] of formData.entries()){\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n        searchParams.append(key, typeof value === \"string\" ? value : value.name);\n    }\n    return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n    let formData = new FormData();\n    for (let [key, value] of searchParams.entries()){\n        formData.append(key, value);\n    }\n    return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n    // Fill in loaderData/errors from our loaders\n    let loaderData = {};\n    let errors = null;\n    let statusCode;\n    let foundError = false;\n    let loaderHeaders = {};\n    // Process loader results into state.loaderData/state.errors\n    results.forEach((result, index)=>{\n        let id = matchesToLoad[index].route.id;\n        invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n        if (isErrorResult(result)) {\n            // Look upwards from the matched route for the closest ancestor\n            // error boundary, defaulting to the root match\n            let boundaryMatch = findNearestBoundary(matches, id);\n            let error = result.error;\n            // If we have a pending action error, we report it at the highest-route\n            // that throws a loader error, and then clear it out to indicate that\n            // it was consumed\n            if (pendingError) {\n                error = Object.values(pendingError)[0];\n                pendingError = undefined;\n            }\n            errors = errors || {};\n            // Prefer higher error values if lower errors bubble to the same boundary\n            if (errors[boundaryMatch.route.id] == null) {\n                errors[boundaryMatch.route.id] = error;\n            }\n            // Clear our any prior loaderData for the throwing route\n            loaderData[id] = undefined;\n            // Once we find our first (highest) error, we set the status code and\n            // prevent deeper status codes from overriding\n            if (!foundError) {\n                foundError = true;\n                statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        } else {\n            if (isDeferredResult(result)) {\n                activeDeferreds.set(id, result.deferredData);\n                loaderData[id] = result.deferredData.data;\n            } else {\n                loaderData[id] = result.data;\n            }\n            // Error status codes always override success status codes, but if all\n            // loaders are successful we take the deepest status code.\n            if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n                statusCode = result.statusCode;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        }\n    });\n    // If we didn't consume the pending action error (i.e., all loaders\n    // resolved), then consume it here.  Also clear out any loaderData for the\n    // throwing route\n    if (pendingError) {\n        errors = pendingError;\n        loaderData[Object.keys(pendingError)[0]] = undefined;\n    }\n    return {\n        loaderData,\n        errors,\n        statusCode: statusCode || 200,\n        loaderHeaders\n    };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n    let { loaderData, errors } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n    // Process results from our revalidating fetchers\n    for(let index = 0; index < revalidatingFetchers.length; index++){\n        let { key, match, controller } = revalidatingFetchers[index];\n        invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n        let result = fetcherResults[index];\n        // Process fetcher non-redirect errors\n        if (controller && controller.signal.aborted) {\n            continue;\n        } else if (isErrorResult(result)) {\n            let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n            if (!(errors && errors[boundaryMatch.route.id])) {\n                errors = _extends({}, errors, {\n                    [boundaryMatch.route.id]: result.error\n                });\n            }\n            state.fetchers.delete(key);\n        } else if (isRedirectResult(result)) {\n            // Should never get here, redirects should get processed above, but we\n            // keep this to type narrow to a success result in the else\n            invariant(false, \"Unhandled fetcher revalidation redirect\");\n        } else if (isDeferredResult(result)) {\n            // Should never get here, deferred data should be awaited for fetchers\n            // in resolveDeferredResults\n            invariant(false, \"Unhandled fetcher deferred data\");\n        } else {\n            let doneFetcher = getDoneFetcher(result.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    return {\n        loaderData,\n        errors\n    };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n    let mergedLoaderData = _extends({}, newLoaderData);\n    for (let match of matches){\n        let id = match.route.id;\n        if (newLoaderData.hasOwnProperty(id)) {\n            if (newLoaderData[id] !== undefined) {\n                mergedLoaderData[id] = newLoaderData[id];\n            }\n        } else if (loaderData[id] !== undefined && match.route.loader) {\n            // Preserve existing keys not included in newLoaderData and where a loader\n            // wasn't removed by HMR\n            mergedLoaderData[id] = loaderData[id];\n        }\n        if (errors && errors.hasOwnProperty(id)) {\n            break;\n        }\n    }\n    return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m)=>m.route.id === routeId) + 1) : [\n        ...matches\n    ];\n    return eligibleMatches.reverse().find((m)=>m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n    // Prefer a root layout route if present, otherwise shim in a route object\n    let route = routes.length === 1 ? routes[0] : routes.find((r)=>r.index || !r.path || r.path === \"/\") || {\n        id: \"__shim-error-route__\"\n    };\n    return {\n        matches: [\n            {\n                params: {},\n                pathname: \"\",\n                pathnameBase: \"\",\n                route\n            }\n        ],\n        route\n    };\n}\nfunction getInternalRouterError(status, _temp5) {\n    let { pathname, routeId, method, type } = _temp5 === void 0 ? {} : _temp5;\n    let statusText = \"Unknown Server Error\";\n    let errorMessage = \"Unknown @remix-run/router error\";\n    if (status === 400) {\n        statusText = \"Bad Request\";\n        if (method && pathname && routeId) {\n            errorMessage = \"You made a \" + method + ' request to \"' + pathname + '\" but ' + ('did not provide a `loader` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n        } else if (type === \"defer-action\") {\n            errorMessage = \"defer() is not supported in actions\";\n        } else if (type === \"invalid-body\") {\n            errorMessage = \"Unable to encode submission body\";\n        }\n    } else if (status === 403) {\n        statusText = \"Forbidden\";\n        errorMessage = 'Route \"' + routeId + '\" does not match URL \"' + pathname + '\"';\n    } else if (status === 404) {\n        statusText = \"Not Found\";\n        errorMessage = 'No route matches URL \"' + pathname + '\"';\n    } else if (status === 405) {\n        statusText = \"Method Not Allowed\";\n        if (method && pathname && routeId) {\n            errorMessage = \"You made a \" + method.toUpperCase() + ' request to \"' + pathname + '\" but ' + ('did not provide an `action` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n        } else if (method) {\n            errorMessage = 'Invalid request method \"' + method.toUpperCase() + '\"';\n        }\n    }\n    return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n    for(let i = results.length - 1; i >= 0; i--){\n        let result = results[i];\n        if (isRedirectResult(result)) {\n            return {\n                result,\n                idx: i\n            };\n        }\n    }\n}\nfunction stripHashFromPath(path) {\n    let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n    return createPath(_extends({}, parsedPath, {\n        hash: \"\"\n    }));\n}\nfunction isHashChangeOnly(a, b) {\n    if (a.pathname !== b.pathname || a.search !== b.search) {\n        return false;\n    }\n    if (a.hash === \"\") {\n        // /page -> /page#hash\n        return b.hash !== \"\";\n    } else if (a.hash === b.hash) {\n        // /page#hash -> /page#hash\n        return true;\n    } else if (b.hash !== \"\") {\n        // /page#hash -> /page#other\n        return true;\n    }\n    // If the hash is removed the browser will re-perform a request to the server\n    // /page#hash -> /page\n    return false;\n}\nfunction isDeferredResult(result) {\n    return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n    return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n    return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n    let deferred = value;\n    return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n    return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectResponse(result) {\n    if (!isResponse(result)) {\n        return false;\n    }\n    let status = result.status;\n    let location = result.headers.get(\"Location\");\n    return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n    return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);\n}\nfunction isValidMethod(method) {\n    return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n    return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n    for(let index = 0; index < results.length; index++){\n        let result = results[index];\n        let match = matchesToLoad[index];\n        // If we don't have a match, then we can have a deferred result to do\n        // anything with.  This is for revalidating fetchers where the route was\n        // removed during HMR\n        if (!match) {\n            continue;\n        }\n        let currentMatch = currentMatches.find((m)=>m.route.id === match.route.id);\n        let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n        if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n            // Note: we do not have to touch activeDeferreds here since we race them\n            // against the signal in resolveDeferredData and they'll get aborted\n            // there if needed\n            let signal = signals[index];\n            invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n            await resolveDeferredData(result, signal, isFetcher).then((result)=>{\n                if (result) {\n                    results[index] = result || results[index];\n                }\n            });\n        }\n    }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n    if (unwrap === void 0) {\n        unwrap = false;\n    }\n    let aborted = await result.deferredData.resolveData(signal);\n    if (aborted) {\n        return;\n    }\n    if (unwrap) {\n        try {\n            return {\n                type: ResultType.data,\n                data: result.deferredData.unwrappedData\n            };\n        } catch (e) {\n            // Handle any TrackedPromise._error values encountered while unwrapping\n            return {\n                type: ResultType.error,\n                error: e\n            };\n        }\n    }\n    return {\n        type: ResultType.data,\n        data: result.deferredData.data\n    };\n}\nfunction hasNakedIndexQuery(search) {\n    return new URLSearchParams(search).getAll(\"index\").some((v)=>v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n    let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n        // Return the leaf index route when index is present\n        return matches[matches.length - 1];\n    }\n    // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n    // pathless layout routes)\n    let pathMatches = getPathContributingMatches(matches);\n    return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n    let { formMethod, formAction, formEncType, text, formData, json } = navigation;\n    if (!formMethod || !formAction || !formEncType) {\n        return;\n    }\n    if (text != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: undefined,\n            json: undefined,\n            text\n        };\n    } else if (formData != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData,\n            json: undefined,\n            text: undefined\n        };\n    } else if (json !== undefined) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n        };\n    }\n}\nfunction getLoadingNavigation(location, submission) {\n    if (submission) {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text\n        };\n        return navigation;\n    } else {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined\n        };\n        return navigation;\n    }\n}\nfunction getSubmittingNavigation(location, submission) {\n    let navigation = {\n        state: \"submitting\",\n        location,\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text\n    };\n    return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n    if (submission) {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text,\n            data\n        };\n        return fetcher;\n    } else {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined,\n            data\n        };\n        return fetcher;\n    }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n    let fetcher = {\n        state: \"submitting\",\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text,\n        data: existingFetcher ? existingFetcher.data : undefined\n    };\n    return fetcher;\n}\nfunction getDoneFetcher(data) {\n    let fetcher = {\n        state: \"idle\",\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n        json: undefined,\n        text: undefined,\n        data\n    };\n    return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n    try {\n        let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n        if (sessionPositions) {\n            let json = JSON.parse(sessionPositions);\n            for (let [k, v] of Object.entries(json || {})){\n                if (v && Array.isArray(v)) {\n                    transitions.set(k, new Set(v || []));\n                }\n            }\n        }\n    } catch (e) {\n    // no-op, use default empty object\n    }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n    if (transitions.size > 0) {\n        let json = {};\n        for (let [k, v] of transitions){\n            json[k] = [\n                ...v\n            ];\n        }\n        try {\n            _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\n        } catch (error) {\n            warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n        }\n    }\n}\n//#endregion\n //# sourceMappingURL=router.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JvdXRlci9kaXN0L3JvdXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTQTtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFDekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBQ0EsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBRUEsZ0ZBQWdGO0FBQ2hGLDZCQUE2QjtBQUM3QixnRkFBZ0Y7QUFDaEY7O0NBRUMsR0FDRCxJQUFJUTtBQUNILFVBQVVBLE1BQU07SUFDZjs7Ozs7O0dBTUMsR0FDREEsTUFBTSxDQUFDLE1BQU0sR0FBRztJQUNoQjs7OztHQUlDLEdBQ0RBLE1BQU0sQ0FBQyxPQUFPLEdBQUc7SUFDakI7OztHQUdDLEdBQ0RBLE1BQU0sQ0FBQyxVQUFVLEdBQUc7QUFDdEIsR0FBR0EsVUFBV0EsQ0FBQUEsU0FBUyxDQUFDO0FBQ3hCLE1BQU1DLG9CQUFvQjtBQUMxQjs7O0NBR0MsR0FDRCxTQUFTQyxvQkFBb0JDLE9BQU87SUFDbEMsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUsQ0FBQztJQUNiO0lBQ0EsSUFBSSxFQUNGQyxpQkFBaUI7UUFBQztLQUFJLEVBQ3RCQyxZQUFZLEVBQ1pDLFdBQVcsS0FBSyxFQUNqQixHQUFHSDtJQUNKLElBQUlJLFNBQVMscURBQXFEO0lBQ2xFQSxVQUFVSCxlQUFlSSxHQUFHLENBQUMsQ0FBQ0MsT0FBT0MsUUFBVUMscUJBQXFCRixPQUFPLE9BQU9BLFVBQVUsV0FBVyxPQUFPQSxNQUFNRyxLQUFLLEVBQUVGLFVBQVUsSUFBSSxZQUFZRztJQUNySixJQUFJSCxRQUFRSSxXQUFXVCxnQkFBZ0IsT0FBT0UsUUFBUWQsTUFBTSxHQUFHLElBQUlZO0lBQ25FLElBQUlVLFNBQVNmLE9BQU9nQixHQUFHO0lBQ3ZCLElBQUlDLFdBQVc7SUFDZixTQUFTSCxXQUFXSSxDQUFDO1FBQ25CLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDSCxHQUFHLElBQUlYLFFBQVFkLE1BQU0sR0FBRztJQUNuRDtJQUNBLFNBQVM2QjtRQUNQLE9BQU9mLE9BQU8sQ0FBQ0csTUFBTTtJQUN2QjtJQUNBLFNBQVNDLHFCQUFxQlksRUFBRSxFQUFFWCxLQUFLLEVBQUVqQixHQUFHO1FBQzFDLElBQUlpQixVQUFVLEtBQUssR0FBRztZQUNwQkEsUUFBUTtRQUNWO1FBQ0EsSUFBSVksV0FBV0MsZUFBZWxCLFVBQVVlLHFCQUFxQkksUUFBUSxHQUFHLEtBQUtILElBQUlYLE9BQU9qQjtRQUN4RmdDLFFBQVFILFNBQVNFLFFBQVEsQ0FBQ0UsTUFBTSxDQUFDLE9BQU8sS0FBSyw2REFBNkRDLEtBQUtDLFNBQVMsQ0FBQ1A7UUFDekgsT0FBT0M7SUFDVDtJQUNBLFNBQVNPLFdBQVdSLEVBQUU7UUFDcEIsT0FBTyxPQUFPQSxPQUFPLFdBQVdBLEtBQUtTLFdBQVdUO0lBQ2xEO0lBQ0EsSUFBSVUsVUFBVTtRQUNaLElBQUl2QixTQUFRO1lBQ1YsT0FBT0E7UUFDVDtRQUNBLElBQUlLLFVBQVM7WUFDWCxPQUFPQTtRQUNUO1FBQ0EsSUFBSVMsWUFBVztZQUNiLE9BQU9GO1FBQ1Q7UUFDQVM7UUFDQUcsV0FBVVgsRUFBRTtZQUNWLE9BQU8sSUFBSVksSUFBSUosV0FBV1IsS0FBSztRQUNqQztRQUNBYSxnQkFBZWIsRUFBRTtZQUNmLElBQUljLE9BQU8sT0FBT2QsT0FBTyxXQUFXZSxVQUFVZixNQUFNQTtZQUNwRCxPQUFPO2dCQUNMRyxVQUFVVyxLQUFLWCxRQUFRLElBQUk7Z0JBQzNCYSxRQUFRRixLQUFLRSxNQUFNLElBQUk7Z0JBQ3ZCQyxNQUFNSCxLQUFLRyxJQUFJLElBQUk7WUFDckI7UUFDRjtRQUNBQyxNQUFLbEIsRUFBRSxFQUFFWCxLQUFLO1lBQ1pHLFNBQVNmLE9BQU8wQyxJQUFJO1lBQ3BCLElBQUlDLGVBQWVoQyxxQkFBcUJZLElBQUlYO1lBQzVDRixTQUFTO1lBQ1RILFFBQVFxQyxNQUFNLENBQUNsQyxPQUFPSCxRQUFRZCxNQUFNLEVBQUVrRDtZQUN0QyxJQUFJckMsWUFBWVcsVUFBVTtnQkFDeEJBLFNBQVM7b0JBQ1BGO29CQUNBUyxVQUFVbUI7b0JBQ1ZFLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO1FBQ0FDLFNBQVF2QixFQUFFLEVBQUVYLEtBQUs7WUFDZkcsU0FBU2YsT0FBTytDLE9BQU87WUFDdkIsSUFBSUosZUFBZWhDLHFCQUFxQlksSUFBSVg7WUFDNUNMLE9BQU8sQ0FBQ0csTUFBTSxHQUFHaUM7WUFDakIsSUFBSXJDLFlBQVlXLFVBQVU7Z0JBQ3hCQSxTQUFTO29CQUNQRjtvQkFDQVMsVUFBVW1CO29CQUNWRSxPQUFPO2dCQUNUO1lBQ0Y7UUFDRjtRQUNBRyxJQUFHSCxLQUFLO1lBQ045QixTQUFTZixPQUFPZ0IsR0FBRztZQUNuQixJQUFJaUMsWUFBWW5DLFdBQVdKLFFBQVFtQztZQUNuQyxJQUFJRixlQUFlcEMsT0FBTyxDQUFDMEMsVUFBVTtZQUNyQ3ZDLFFBQVF1QztZQUNSLElBQUloQyxVQUFVO2dCQUNaQSxTQUFTO29CQUNQRjtvQkFDQVMsVUFBVW1CO29CQUNWRTtnQkFDRjtZQUNGO1FBQ0Y7UUFDQUssUUFBT0MsRUFBRTtZQUNQbEMsV0FBV2tDO1lBQ1gsT0FBTztnQkFDTGxDLFdBQVc7WUFDYjtRQUNGO0lBQ0Y7SUFDQSxPQUFPZ0I7QUFDVDtBQUNBOzs7Ozs7Q0FNQyxHQUNELFNBQVNtQixxQkFBcUJqRCxPQUFPO0lBQ25DLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVLENBQUM7SUFDYjtJQUNBLFNBQVNrRCxzQkFBc0JDLE9BQU0sRUFBRUMsYUFBYTtRQUNsRCxJQUFJLEVBQ0Y3QixRQUFRLEVBQ1JhLE1BQU0sRUFDTkMsSUFBSSxFQUNMLEdBQUdjLFFBQU85QixRQUFRO1FBQ25CLE9BQU9DLGVBQWUsSUFBSTtZQUN4QkM7WUFDQWE7WUFDQUM7UUFDRixHQUNBLCtEQUErRDtRQUMvRGUsY0FBYzNDLEtBQUssSUFBSTJDLGNBQWMzQyxLQUFLLENBQUM0QyxHQUFHLElBQUksTUFBTUQsY0FBYzNDLEtBQUssSUFBSTJDLGNBQWMzQyxLQUFLLENBQUNqQixHQUFHLElBQUk7SUFDNUc7SUFDQSxTQUFTOEQsa0JBQWtCSCxPQUFNLEVBQUUvQixFQUFFO1FBQ25DLE9BQU8sT0FBT0EsT0FBTyxXQUFXQSxLQUFLUyxXQUFXVDtJQUNsRDtJQUNBLE9BQU9tQyxtQkFBbUJMLHVCQUF1QkksbUJBQW1CLE1BQU10RDtBQUM1RTtBQUNBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTd0Qsa0JBQWtCeEQsT0FBTztJQUNoQyxJQUFJQSxZQUFZLEtBQUssR0FBRztRQUN0QkEsVUFBVSxDQUFDO0lBQ2I7SUFDQSxTQUFTeUQsbUJBQW1CTixPQUFNLEVBQUVDLGFBQWE7UUFDL0MsSUFBSSxFQUNGN0IsV0FBVyxHQUFHLEVBQ2RhLFNBQVMsRUFBRSxFQUNYQyxPQUFPLEVBQUUsRUFDVixHQUFHRixVQUFVZ0IsUUFBTzlCLFFBQVEsQ0FBQ2dCLElBQUksQ0FBQ3FCLE1BQU0sQ0FBQztRQUMxQyw2RUFBNkU7UUFDN0UsdUVBQXVFO1FBQ3ZFLDRFQUE0RTtRQUM1RSwyRUFBMkU7UUFDM0UsNEVBQTRFO1FBQzVFLGdFQUFnRTtRQUNoRSxJQUFJLENBQUNuQyxTQUFTb0MsVUFBVSxDQUFDLFFBQVEsQ0FBQ3BDLFNBQVNvQyxVQUFVLENBQUMsTUFBTTtZQUMxRHBDLFdBQVcsTUFBTUE7UUFDbkI7UUFDQSxPQUFPRCxlQUFlLElBQUk7WUFDeEJDO1lBQ0FhO1lBQ0FDO1FBQ0YsR0FDQSwrREFBK0Q7UUFDL0RlLGNBQWMzQyxLQUFLLElBQUkyQyxjQUFjM0MsS0FBSyxDQUFDNEMsR0FBRyxJQUFJLE1BQU1ELGNBQWMzQyxLQUFLLElBQUkyQyxjQUFjM0MsS0FBSyxDQUFDakIsR0FBRyxJQUFJO0lBQzVHO0lBQ0EsU0FBU29FLGVBQWVULE9BQU0sRUFBRS9CLEVBQUU7UUFDaEMsSUFBSXlDLE9BQU9WLFFBQU9XLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDO1FBQ3pDLElBQUlDLE9BQU87UUFDWCxJQUFJSCxRQUFRQSxLQUFLSSxZQUFZLENBQUMsU0FBUztZQUNyQyxJQUFJQyxNQUFNZixRQUFPOUIsUUFBUSxDQUFDMkMsSUFBSTtZQUM5QixJQUFJRyxZQUFZRCxJQUFJRSxPQUFPLENBQUM7WUFDNUJKLE9BQU9HLGNBQWMsQ0FBQyxJQUFJRCxNQUFNQSxJQUFJRyxLQUFLLENBQUMsR0FBR0Y7UUFDL0M7UUFDQSxPQUFPSCxPQUFPLE1BQU8sUUFBTzVDLE9BQU8sV0FBV0EsS0FBS1MsV0FBV1QsR0FBRTtJQUNsRTtJQUNBLFNBQVNrRCxxQkFBcUJqRCxRQUFRLEVBQUVELEVBQUU7UUFDeENJLFFBQVFILFNBQVNFLFFBQVEsQ0FBQ0UsTUFBTSxDQUFDLE9BQU8sS0FBSywrREFBK0RDLEtBQUtDLFNBQVMsQ0FBQ1AsTUFBTTtJQUNuSTtJQUNBLE9BQU9tQyxtQkFBbUJFLG9CQUFvQkcsZ0JBQWdCVSxzQkFBc0J0RTtBQUN0RjtBQUNBLFNBQVN1RSxVQUFVQyxLQUFLLEVBQUVDLE9BQU87SUFDL0IsSUFBSUQsVUFBVSxTQUFTQSxVQUFVLFFBQVEsT0FBT0EsVUFBVSxhQUFhO1FBQ3JFLE1BQU0sSUFBSUUsTUFBTUQ7SUFDbEI7QUFDRjtBQUNBLFNBQVNqRCxRQUFRbUQsSUFBSSxFQUFFRixPQUFPO0lBQzVCLElBQUksQ0FBQ0UsTUFBTTtRQUNULHNDQUFzQztRQUN0QyxJQUFJLE9BQU9DLFlBQVksYUFBYUEsUUFBUUMsSUFBSSxDQUFDSjtRQUNqRCxJQUFJO1lBQ0YsZ0NBQWdDO1lBQ2hDLEVBQUU7WUFDRixnRUFBZ0U7WUFDaEUsK0RBQStEO1lBQy9ELDhEQUE4RDtZQUM5RCxNQUFNLElBQUlDLE1BQU1EO1FBQ2hCLG9DQUFvQztRQUN0QyxFQUFFLE9BQU9LLEdBQUcsQ0FBQztJQUNmO0FBQ0Y7QUFDQSxTQUFTQztJQUNQLE9BQU8vRCxLQUFLZ0UsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSXZCLE1BQU0sQ0FBQyxHQUFHO0FBQzlDO0FBQ0E7O0NBRUMsR0FDRCxTQUFTd0IsZ0JBQWdCN0QsUUFBUSxFQUFFZCxLQUFLO0lBQ3RDLE9BQU87UUFDTDhDLEtBQUtoQyxTQUFTWixLQUFLO1FBQ25CakIsS0FBSzZCLFNBQVM3QixHQUFHO1FBQ2pCMkYsS0FBSzVFO0lBQ1A7QUFDRjtBQUNBOztDQUVDLEdBQ0QsU0FBU2UsZUFBZThELE9BQU8sRUFBRWhFLEVBQUUsRUFBRVgsS0FBSyxFQUFFakIsR0FBRztJQUM3QyxJQUFJaUIsVUFBVSxLQUFLLEdBQUc7UUFDcEJBLFFBQVE7SUFDVjtJQUNBLElBQUlZLFdBQVd0QyxTQUFTO1FBQ3RCd0MsVUFBVSxPQUFPNkQsWUFBWSxXQUFXQSxVQUFVQSxRQUFRN0QsUUFBUTtRQUNsRWEsUUFBUTtRQUNSQyxNQUFNO0lBQ1IsR0FBRyxPQUFPakIsT0FBTyxXQUFXZSxVQUFVZixNQUFNQSxJQUFJO1FBQzlDWDtRQUNBLDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUseUVBQXlFO1FBQ3pFLCtFQUErRTtRQUMvRWpCLEtBQUs0QixNQUFNQSxHQUFHNUIsR0FBRyxJQUFJQSxPQUFPdUY7SUFDOUI7SUFDQSxPQUFPMUQ7QUFDVDtBQUNBOztDQUVDLEdBQ0QsU0FBU1EsV0FBV3dELElBQUk7SUFDdEIsSUFBSSxFQUNGOUQsV0FBVyxHQUFHLEVBQ2RhLFNBQVMsRUFBRSxFQUNYQyxPQUFPLEVBQUUsRUFDVixHQUFHZ0Q7SUFDSixJQUFJakQsVUFBVUEsV0FBVyxLQUFLYixZQUFZYSxPQUFPWCxNQUFNLENBQUMsT0FBTyxNQUFNVyxTQUFTLE1BQU1BO0lBQ3BGLElBQUlDLFFBQVFBLFNBQVMsS0FBS2QsWUFBWWMsS0FBS1osTUFBTSxDQUFDLE9BQU8sTUFBTVksT0FBTyxNQUFNQTtJQUM1RSxPQUFPZDtBQUNUO0FBQ0E7O0NBRUMsR0FDRCxTQUFTWSxVQUFVRCxJQUFJO0lBQ3JCLElBQUlvRCxhQUFhLENBQUM7SUFDbEIsSUFBSXBELE1BQU07UUFDUixJQUFJaUMsWUFBWWpDLEtBQUtrQyxPQUFPLENBQUM7UUFDN0IsSUFBSUQsYUFBYSxHQUFHO1lBQ2xCbUIsV0FBV2pELElBQUksR0FBR0gsS0FBS3dCLE1BQU0sQ0FBQ1M7WUFDOUJqQyxPQUFPQSxLQUFLd0IsTUFBTSxDQUFDLEdBQUdTO1FBQ3hCO1FBQ0EsSUFBSW9CLGNBQWNyRCxLQUFLa0MsT0FBTyxDQUFDO1FBQy9CLElBQUltQixlQUFlLEdBQUc7WUFDcEJELFdBQVdsRCxNQUFNLEdBQUdGLEtBQUt3QixNQUFNLENBQUM2QjtZQUNoQ3JELE9BQU9BLEtBQUt3QixNQUFNLENBQUMsR0FBRzZCO1FBQ3hCO1FBQ0EsSUFBSXJELE1BQU07WUFDUm9ELFdBQVcvRCxRQUFRLEdBQUdXO1FBQ3hCO0lBQ0Y7SUFDQSxPQUFPb0Q7QUFDVDtBQUNBLFNBQVMvQixtQkFBbUJpQyxXQUFXLEVBQUU1RCxVQUFVLEVBQUU2RCxnQkFBZ0IsRUFBRXpGLE9BQU87SUFDNUUsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUsQ0FBQztJQUNiO0lBQ0EsSUFBSSxFQUNGbUQsUUFBQUEsVUFBU1csU0FBUzRCLFdBQVcsRUFDN0J2RixXQUFXLEtBQUssRUFDakIsR0FBR0g7SUFDSixJQUFJb0QsZ0JBQWdCRCxRQUFPckIsT0FBTztJQUNsQyxJQUFJbEIsU0FBU2YsT0FBT2dCLEdBQUc7SUFDdkIsSUFBSUMsV0FBVztJQUNmLElBQUlQLFFBQVFvRjtJQUNaLHlFQUF5RTtJQUN6RSwyRUFBMkU7SUFDM0UsMERBQTBEO0lBQzFELElBQUlwRixTQUFTLE1BQU07UUFDakJBLFFBQVE7UUFDUjZDLGNBQWN3QyxZQUFZLENBQUM3RyxTQUFTLENBQUMsR0FBR3FFLGNBQWMzQyxLQUFLLEVBQUU7WUFDM0QwRSxLQUFLNUU7UUFDUCxJQUFJO0lBQ047SUFDQSxTQUFTb0Y7UUFDUCxJQUFJbEYsUUFBUTJDLGNBQWMzQyxLQUFLLElBQUk7WUFDakMwRSxLQUFLO1FBQ1A7UUFDQSxPQUFPMUUsTUFBTTBFLEdBQUc7SUFDbEI7SUFDQSxTQUFTVTtRQUNQakYsU0FBU2YsT0FBT2dCLEdBQUc7UUFDbkIsSUFBSWlDLFlBQVk2QztRQUNoQixJQUFJakQsUUFBUUksYUFBYSxPQUFPLE9BQU9BLFlBQVl2QztRQUNuREEsUUFBUXVDO1FBQ1IsSUFBSWhDLFVBQVU7WUFDWkEsU0FBUztnQkFDUEY7Z0JBQ0FTLFVBQVVTLFFBQVFULFFBQVE7Z0JBQzFCcUI7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxTQUFTSixLQUFLbEIsRUFBRSxFQUFFWCxLQUFLO1FBQ3JCRyxTQUFTZixPQUFPMEMsSUFBSTtRQUNwQixJQUFJbEIsV0FBV0MsZUFBZVEsUUFBUVQsUUFBUSxFQUFFRCxJQUFJWDtRQUNwRCxJQUFJZ0Ysa0JBQWtCQSxpQkFBaUJwRSxVQUFVRDtRQUNqRGIsUUFBUW9GLGFBQWE7UUFDckIsSUFBSUcsZUFBZVosZ0JBQWdCN0QsVUFBVWQ7UUFDN0MsSUFBSTJELE1BQU1wQyxRQUFRRixVQUFVLENBQUNQO1FBQzdCLDhEQUE4RDtRQUM5RCxJQUFJO1lBQ0YrQixjQUFjMkMsU0FBUyxDQUFDRCxjQUFjLElBQUk1QjtRQUM1QyxFQUFFLE9BQU84QixPQUFPO1lBQ2QsMEVBQTBFO1lBQzFFLHFFQUFxRTtZQUNyRSx1R0FBdUc7WUFDdkcsMEZBQTBGO1lBQzFGLElBQUlBLGlCQUFpQkMsZ0JBQWdCRCxNQUFNRSxJQUFJLEtBQUssa0JBQWtCO2dCQUNwRSxNQUFNRjtZQUNSO1lBQ0EsMERBQTBEO1lBQzFELDJEQUEyRDtZQUMzRDdDLFFBQU85QixRQUFRLENBQUNwQyxNQUFNLENBQUNpRjtRQUN6QjtRQUNBLElBQUkvRCxZQUFZVyxVQUFVO1lBQ3hCQSxTQUFTO2dCQUNQRjtnQkFDQVMsVUFBVVMsUUFBUVQsUUFBUTtnQkFDMUJxQixPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBQ0EsU0FBU0MsUUFBUXZCLEVBQUUsRUFBRVgsS0FBSztRQUN4QkcsU0FBU2YsT0FBTytDLE9BQU87UUFDdkIsSUFBSXZCLFdBQVdDLGVBQWVRLFFBQVFULFFBQVEsRUFBRUQsSUFBSVg7UUFDcEQsSUFBSWdGLGtCQUFrQkEsaUJBQWlCcEUsVUFBVUQ7UUFDakRiLFFBQVFvRjtRQUNSLElBQUlHLGVBQWVaLGdCQUFnQjdELFVBQVVkO1FBQzdDLElBQUkyRCxNQUFNcEMsUUFBUUYsVUFBVSxDQUFDUDtRQUM3QitCLGNBQWN3QyxZQUFZLENBQUNFLGNBQWMsSUFBSTVCO1FBQzdDLElBQUkvRCxZQUFZVyxVQUFVO1lBQ3hCQSxTQUFTO2dCQUNQRjtnQkFDQVMsVUFBVVMsUUFBUVQsUUFBUTtnQkFDMUJxQixPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBQ0EsU0FBU1gsVUFBVVgsRUFBRTtRQUNuQix5RUFBeUU7UUFDekUsd0VBQXdFO1FBQ3hFLDBEQUEwRDtRQUMxRCxJQUFJeUMsT0FBT1YsUUFBTzlCLFFBQVEsQ0FBQzhFLE1BQU0sS0FBSyxTQUFTaEQsUUFBTzlCLFFBQVEsQ0FBQzhFLE1BQU0sR0FBR2hELFFBQU85QixRQUFRLENBQUMyQyxJQUFJO1FBQzVGLElBQUlBLE9BQU8sT0FBTzVDLE9BQU8sV0FBV0EsS0FBS1MsV0FBV1Q7UUFDcERtRCxVQUFVVixNQUFNLHdFQUF3RUc7UUFDeEYsT0FBTyxJQUFJaEMsSUFBSWdDLE1BQU1IO0lBQ3ZCO0lBQ0EsSUFBSS9CLFVBQVU7UUFDWixJQUFJbEIsVUFBUztZQUNYLE9BQU9BO1FBQ1Q7UUFDQSxJQUFJUyxZQUFXO1lBQ2IsT0FBT21FLFlBQVlyQyxTQUFRQztRQUM3QjtRQUNBTCxRQUFPQyxFQUFFO1lBQ1AsSUFBSWxDLFVBQVU7Z0JBQ1osTUFBTSxJQUFJNEQsTUFBTTtZQUNsQjtZQUNBdkIsUUFBT2lELGdCQUFnQixDQUFDdEcsbUJBQW1CK0Y7WUFDM0MvRSxXQUFXa0M7WUFDWCxPQUFPO2dCQUNMRyxRQUFPa0QsbUJBQW1CLENBQUN2RyxtQkFBbUIrRjtnQkFDOUMvRSxXQUFXO1lBQ2I7UUFDRjtRQUNBYyxZQUFXUixFQUFFO1lBQ1gsT0FBT1EsV0FBV3VCLFNBQVEvQjtRQUM1QjtRQUNBVztRQUNBRSxnQkFBZWIsRUFBRTtZQUNmLHVEQUF1RDtZQUN2RCxJQUFJOEMsTUFBTW5DLFVBQVVYO1lBQ3BCLE9BQU87Z0JBQ0xHLFVBQVUyQyxJQUFJM0MsUUFBUTtnQkFDdEJhLFFBQVE4QixJQUFJOUIsTUFBTTtnQkFDbEJDLE1BQU02QixJQUFJN0IsSUFBSTtZQUNoQjtRQUNGO1FBQ0FDO1FBQ0FLO1FBQ0FFLElBQUc5QixDQUFDO1lBQ0YsT0FBT3FDLGNBQWNQLEVBQUUsQ0FBQzlCO1FBQzFCO0lBQ0Y7SUFDQSxPQUFPZTtBQUNUO0FBQ0EsWUFBWTtBQUVaLElBQUl3RTtBQUNILFVBQVVBLFVBQVU7SUFDbkJBLFVBQVUsQ0FBQyxPQUFPLEdBQUc7SUFDckJBLFVBQVUsQ0FBQyxXQUFXLEdBQUc7SUFDekJBLFVBQVUsQ0FBQyxXQUFXLEdBQUc7SUFDekJBLFVBQVUsQ0FBQyxRQUFRLEdBQUc7QUFDeEIsR0FBR0EsY0FBZUEsQ0FBQUEsYUFBYSxDQUFDO0FBQ2hDLE1BQU1DLHFCQUFxQixJQUFJQyxJQUFJO0lBQUM7SUFBUTtJQUFpQjtJQUFRO0lBQU07SUFBUztDQUFXO0FBQy9GLFNBQVNDLGFBQWFDLEtBQUs7SUFDekIsT0FBT0EsTUFBTW5HLEtBQUssS0FBSztBQUN6QjtBQUNBLCtFQUErRTtBQUMvRSwwREFBMEQ7QUFDMUQsU0FBU29HLDBCQUEwQkMsTUFBTSxFQUFFQyxrQkFBa0IsRUFBRUMsVUFBVSxFQUFFQyxRQUFRO0lBQ2pGLElBQUlELGVBQWUsS0FBSyxHQUFHO1FBQ3pCQSxhQUFhLEVBQUU7SUFDakI7SUFDQSxJQUFJQyxhQUFhLEtBQUssR0FBRztRQUN2QkEsV0FBVyxDQUFDO0lBQ2Q7SUFDQSxPQUFPSCxPQUFPdkcsR0FBRyxDQUFDLENBQUNxRyxPQUFPbkc7UUFDeEIsSUFBSXlHLFdBQVc7ZUFBSUY7WUFBWXZHO1NBQU07UUFDckMsSUFBSTBHLEtBQUssT0FBT1AsTUFBTU8sRUFBRSxLQUFLLFdBQVdQLE1BQU1PLEVBQUUsR0FBR0QsU0FBU0UsSUFBSSxDQUFDO1FBQ2pFM0MsVUFBVW1DLE1BQU1uRyxLQUFLLEtBQUssUUFBUSxDQUFDbUcsTUFBTVMsUUFBUSxFQUFFO1FBQ25ENUMsVUFBVSxDQUFDd0MsUUFBUSxDQUFDRSxHQUFHLEVBQUUsdUNBQXdDQSxLQUFLLGVBQWdCO1FBQ3RGLElBQUlSLGFBQWFDLFFBQVE7WUFDdkIsSUFBSVUsYUFBYXJJLFNBQVMsQ0FBQyxHQUFHMkgsT0FBT0csbUJBQW1CSCxRQUFRO2dCQUM5RE87WUFDRjtZQUNBRixRQUFRLENBQUNFLEdBQUcsR0FBR0c7WUFDZixPQUFPQTtRQUNULE9BQU87WUFDTCxJQUFJQyxvQkFBb0J0SSxTQUFTLENBQUMsR0FBRzJILE9BQU9HLG1CQUFtQkgsUUFBUTtnQkFDckVPO2dCQUNBRSxVQUFVekc7WUFDWjtZQUNBcUcsUUFBUSxDQUFDRSxHQUFHLEdBQUdJO1lBQ2YsSUFBSVgsTUFBTVMsUUFBUSxFQUFFO2dCQUNsQkUsa0JBQWtCRixRQUFRLEdBQUdSLDBCQUEwQkQsTUFBTVMsUUFBUSxFQUFFTixvQkFBb0JHLFVBQVVEO1lBQ3ZHO1lBQ0EsT0FBT007UUFDVDtJQUNGO0FBQ0Y7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU0MsWUFBWVYsTUFBTSxFQUFFVyxXQUFXLEVBQUVDLFFBQVE7SUFDaEQsSUFBSUEsYUFBYSxLQUFLLEdBQUc7UUFDdkJBLFdBQVc7SUFDYjtJQUNBLElBQUluRyxXQUFXLE9BQU9rRyxnQkFBZ0IsV0FBV3BGLFVBQVVvRixlQUFlQTtJQUMxRSxJQUFJaEcsV0FBV2tHLGNBQWNwRyxTQUFTRSxRQUFRLElBQUksS0FBS2lHO0lBQ3ZELElBQUlqRyxZQUFZLE1BQU07UUFDcEIsT0FBTztJQUNUO0lBQ0EsSUFBSW1HLFdBQVdDLGNBQWNmO0lBQzdCZ0Isa0JBQWtCRjtJQUNsQixJQUFJRyxVQUFVO0lBQ2QsSUFBSyxJQUFJekksSUFBSSxHQUFHeUksV0FBVyxRQUFRekksSUFBSXNJLFNBQVNwSSxNQUFNLEVBQUUsRUFBRUYsRUFBRztRQUMzRHlJLFVBQVVDLGlCQUFpQkosUUFBUSxDQUFDdEksRUFBRSxFQUN0Qyx1RUFBdUU7UUFDdkUsc0VBQXNFO1FBQ3RFLG9FQUFvRTtRQUNwRSxzRUFBc0U7UUFDdEUscUVBQXFFO1FBQ3JFLGlCQUFpQjtRQUNqQjJJLGdCQUFnQnhHO0lBQ2xCO0lBQ0EsT0FBT3NHO0FBQ1Q7QUFDQSxTQUFTRywyQkFBMkJDLEtBQUssRUFBRUMsVUFBVTtJQUNuRCxJQUFJLEVBQ0Z4QixLQUFLLEVBQ0xuRixRQUFRLEVBQ1I0RyxNQUFNLEVBQ1AsR0FBR0Y7SUFDSixPQUFPO1FBQ0xoQixJQUFJUCxNQUFNTyxFQUFFO1FBQ1oxRjtRQUNBNEc7UUFDQUMsTUFBTUYsVUFBVSxDQUFDeEIsTUFBTU8sRUFBRSxDQUFDO1FBQzFCb0IsUUFBUTNCLE1BQU0yQixNQUFNO0lBQ3RCO0FBQ0Y7QUFDQSxTQUFTVixjQUFjZixNQUFNLEVBQUVjLFFBQVEsRUFBRVksV0FBVyxFQUFFeEIsVUFBVTtJQUM5RCxJQUFJWSxhQUFhLEtBQUssR0FBRztRQUN2QkEsV0FBVyxFQUFFO0lBQ2Y7SUFDQSxJQUFJWSxnQkFBZ0IsS0FBSyxHQUFHO1FBQzFCQSxjQUFjLEVBQUU7SUFDbEI7SUFDQSxJQUFJeEIsZUFBZSxLQUFLLEdBQUc7UUFDekJBLGFBQWE7SUFDZjtJQUNBLElBQUl5QixlQUFlLENBQUM3QixPQUFPbkcsT0FBT2lJO1FBQ2hDLElBQUlDLE9BQU87WUFDVEQsY0FBY0EsaUJBQWlCOUgsWUFBWWdHLE1BQU14RSxJQUFJLElBQUksS0FBS3NHO1lBQzlERSxlQUFlaEMsTUFBTWdDLGFBQWEsS0FBSztZQUN2Q0MsZUFBZXBJO1lBQ2ZtRztRQUNGO1FBQ0EsSUFBSStCLEtBQUtELFlBQVksQ0FBQzdFLFVBQVUsQ0FBQyxNQUFNO1lBQ3JDWSxVQUFVa0UsS0FBS0QsWUFBWSxDQUFDN0UsVUFBVSxDQUFDbUQsYUFBYSwwQkFBMkIyQixLQUFLRCxZQUFZLEdBQUcseUJBQTJCLE9BQU8xQixhQUFhLCtDQUErQyxJQUFLO1lBQ3RNMkIsS0FBS0QsWUFBWSxHQUFHQyxLQUFLRCxZQUFZLENBQUNuRSxLQUFLLENBQUN5QyxXQUFXeEgsTUFBTTtRQUMvRDtRQUNBLElBQUk0QyxPQUFPMEcsVUFBVTtZQUFDOUI7WUFBWTJCLEtBQUtELFlBQVk7U0FBQztRQUNwRCxJQUFJSyxhQUFhUCxZQUFZUSxNQUFNLENBQUNMO1FBQ3BDLDZFQUE2RTtRQUM3RSx5RUFBeUU7UUFDekUsMkJBQTJCO1FBQzNCLElBQUkvQixNQUFNUyxRQUFRLElBQUlULE1BQU1TLFFBQVEsQ0FBQzdILE1BQU0sR0FBRyxHQUFHO1lBQy9DaUYsVUFDQSxpREFBaUQ7WUFDakQsbUJBQW1CO1lBQ25CbUMsTUFBTW5HLEtBQUssS0FBSyxNQUFNLDREQUE2RCx3Q0FBd0MyQixPQUFPLElBQUk7WUFDdEl5RixjQUFjakIsTUFBTVMsUUFBUSxFQUFFTyxVQUFVbUIsWUFBWTNHO1FBQ3REO1FBQ0EsMkVBQTJFO1FBQzNFLG9FQUFvRTtRQUNwRSxJQUFJd0UsTUFBTXhFLElBQUksSUFBSSxRQUFRLENBQUN3RSxNQUFNbkcsS0FBSyxFQUFFO1lBQ3RDO1FBQ0Y7UUFDQW1ILFNBQVNwRixJQUFJLENBQUM7WUFDWko7WUFDQTZHLE9BQU9DLGFBQWE5RyxNQUFNd0UsTUFBTW5HLEtBQUs7WUFDckNzSTtRQUNGO0lBQ0Y7SUFDQWpDLE9BQU9xQyxPQUFPLENBQUMsQ0FBQ3ZDLE9BQU9uRztRQUNyQixJQUFJMkk7UUFDSix5Q0FBeUM7UUFDekMsSUFBSXhDLE1BQU14RSxJQUFJLEtBQUssTUFBTSxDQUFFLEVBQUNnSCxjQUFjeEMsTUFBTXhFLElBQUksS0FBSyxRQUFRZ0gsWUFBWUMsUUFBUSxDQUFDLElBQUcsR0FBSTtZQUMzRlosYUFBYTdCLE9BQU9uRztRQUN0QixPQUFPO1lBQ0wsS0FBSyxJQUFJNkksWUFBWUMsd0JBQXdCM0MsTUFBTXhFLElBQUksRUFBRztnQkFDeERxRyxhQUFhN0IsT0FBT25HLE9BQU82STtZQUM3QjtRQUNGO0lBQ0Y7SUFDQSxPQUFPMUI7QUFDVDtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRCxTQUFTMkIsd0JBQXdCbkgsSUFBSTtJQUNuQyxJQUFJb0gsV0FBV3BILEtBQUtxSCxLQUFLLENBQUM7SUFDMUIsSUFBSUQsU0FBU2hLLE1BQU0sS0FBSyxHQUFHLE9BQU8sRUFBRTtJQUNwQyxJQUFJLENBQUNrSyxPQUFPLEdBQUdDLEtBQUssR0FBR0g7SUFDdkIsdURBQXVEO0lBQ3ZELElBQUlJLGFBQWFGLE1BQU1HLFFBQVEsQ0FBQztJQUNoQyw4REFBOEQ7SUFDOUQsSUFBSUMsV0FBV0osTUFBTTdHLE9BQU8sQ0FBQyxPQUFPO0lBQ3BDLElBQUk4RyxLQUFLbkssTUFBTSxLQUFLLEdBQUc7UUFDckIsd0RBQXdEO1FBQ3hELGdHQUFnRztRQUNoRyxPQUFPb0ssYUFBYTtZQUFDRTtZQUFVO1NBQUcsR0FBRztZQUFDQTtTQUFTO0lBQ2pEO0lBQ0EsSUFBSUMsZUFBZVIsd0JBQXdCSSxLQUFLdkMsSUFBSSxDQUFDO0lBQ3JELElBQUk0QyxTQUFTLEVBQUU7SUFDZix3RUFBd0U7SUFDeEUsNkVBQTZFO0lBQzdFLDBFQUEwRTtJQUMxRSw2RUFBNkU7SUFDN0UsNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSw2QkFBNkI7SUFDN0JBLE9BQU94SCxJQUFJLElBQUl1SCxhQUFheEosR0FBRyxDQUFDMEosQ0FBQUEsVUFBV0EsWUFBWSxLQUFLSCxXQUFXO1lBQUNBO1lBQVVHO1NBQVEsQ0FBQzdDLElBQUksQ0FBQztJQUNoRyxxRUFBcUU7SUFDckUsSUFBSXdDLFlBQVk7UUFDZEksT0FBT3hILElBQUksSUFBSXVIO0lBQ2pCO0lBQ0EsMERBQTBEO0lBQzFELE9BQU9DLE9BQU96SixHQUFHLENBQUMrSSxDQUFBQSxXQUFZbEgsS0FBS3lCLFVBQVUsQ0FBQyxRQUFReUYsYUFBYSxLQUFLLE1BQU1BO0FBQ2hGO0FBQ0EsU0FBU3hCLGtCQUFrQkYsUUFBUTtJQUNqQ0EsU0FBU3NDLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFbEIsS0FBSyxLQUFLbUIsRUFBRW5CLEtBQUssR0FBR21CLEVBQUVuQixLQUFLLEdBQUdrQixFQUFFbEIsS0FBSyxDQUFDLHFCQUFxQjtXQUNuRm9CLGVBQWVGLEVBQUVwQixVQUFVLENBQUN4SSxHQUFHLENBQUNvSSxDQUFBQSxPQUFRQSxLQUFLRSxhQUFhLEdBQUd1QixFQUFFckIsVUFBVSxDQUFDeEksR0FBRyxDQUFDb0ksQ0FBQUEsT0FBUUEsS0FBS0UsYUFBYTtBQUM1RztBQUNBLE1BQU15QixVQUFVO0FBQ2hCLE1BQU1DLHNCQUFzQjtBQUM1QixNQUFNQyxrQkFBa0I7QUFDeEIsTUFBTUMsb0JBQW9CO0FBQzFCLE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxlQUFlLENBQUM7QUFDdEIsTUFBTUMsVUFBVUMsQ0FBQUEsSUFBS0EsTUFBTTtBQUMzQixTQUFTM0IsYUFBYTlHLElBQUksRUFBRTNCLEtBQUs7SUFDL0IsSUFBSStJLFdBQVdwSCxLQUFLcUgsS0FBSyxDQUFDO0lBQzFCLElBQUlxQixlQUFldEIsU0FBU2hLLE1BQU07SUFDbEMsSUFBSWdLLFNBQVN1QixJQUFJLENBQUNILFVBQVU7UUFDMUJFLGdCQUFnQkg7SUFDbEI7SUFDQSxJQUFJbEssT0FBTztRQUNUcUssZ0JBQWdCTjtJQUNsQjtJQUNBLE9BQU9oQixTQUFTd0IsTUFBTSxDQUFDSCxDQUFBQSxJQUFLLENBQUNELFFBQVFDLElBQUlJLE1BQU0sQ0FBQyxDQUFDaEMsT0FBT2lDLFVBQVlqQyxRQUFTcUIsQ0FBQUEsUUFBUWEsSUFBSSxDQUFDRCxXQUFXWCxzQkFBc0JXLFlBQVksS0FBS1Qsb0JBQW9CQyxrQkFBaUIsR0FBSUk7QUFDdkw7QUFDQSxTQUFTVCxlQUFlRixDQUFDLEVBQUVDLENBQUM7SUFDMUIsSUFBSWdCLFdBQVdqQixFQUFFM0ssTUFBTSxLQUFLNEssRUFBRTVLLE1BQU0sSUFBSTJLLEVBQUU1RixLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUc4RyxLQUFLLENBQUMsQ0FBQ3BLLEdBQUczQixJQUFNMkIsTUFBTW1KLENBQUMsQ0FBQzlLLEVBQUU7SUFDakYsT0FBTzhMLFdBQ1AseUVBQXlFO0lBQ3pFLDJFQUEyRTtJQUMzRSwyRUFBMkU7SUFDM0UsbUJBQW1CO0lBQ25CakIsQ0FBQyxDQUFDQSxFQUFFM0ssTUFBTSxHQUFHLEVBQUUsR0FBRzRLLENBQUMsQ0FBQ0EsRUFBRTVLLE1BQU0sR0FBRyxFQUFFLEdBQ2pDLHlFQUF5RTtJQUN6RSx3QkFBd0I7SUFDeEI7QUFDRjtBQUNBLFNBQVN3SSxpQkFBaUJzRCxNQUFNLEVBQUU3SixRQUFRO0lBQ3hDLElBQUksRUFDRnNILFVBQVUsRUFDWCxHQUFHdUM7SUFDSixJQUFJQyxnQkFBZ0IsQ0FBQztJQUNyQixJQUFJQyxrQkFBa0I7SUFDdEIsSUFBSXpELFVBQVUsRUFBRTtJQUNoQixJQUFLLElBQUl6SSxJQUFJLEdBQUdBLElBQUl5SixXQUFXdkosTUFBTSxFQUFFLEVBQUVGLEVBQUc7UUFDMUMsSUFBSXFKLE9BQU9JLFVBQVUsQ0FBQ3pKLEVBQUU7UUFDeEIsSUFBSW1NLE1BQU1uTSxNQUFNeUosV0FBV3ZKLE1BQU0sR0FBRztRQUNwQyxJQUFJa00sb0JBQW9CRixvQkFBb0IsTUFBTS9KLFdBQVdBLFNBQVM4QyxLQUFLLENBQUNpSCxnQkFBZ0JoTSxNQUFNLEtBQUs7UUFDdkcsSUFBSTJJLFFBQVF3RCxVQUFVO1lBQ3BCdkosTUFBTXVHLEtBQUtELFlBQVk7WUFDdkJFLGVBQWVELEtBQUtDLGFBQWE7WUFDakM2QztRQUNGLEdBQUdDO1FBQ0gsSUFBSSxDQUFDdkQsT0FBTyxPQUFPO1FBQ25CakosT0FBT0MsTUFBTSxDQUFDb00sZUFBZXBELE1BQU1FLE1BQU07UUFDekMsSUFBSXpCLFFBQVErQixLQUFLL0IsS0FBSztRQUN0Qm1CLFFBQVF2RixJQUFJLENBQUM7WUFDWCxnQ0FBZ0M7WUFDaEM2RixRQUFRa0Q7WUFDUjlKLFVBQVVxSCxVQUFVO2dCQUFDMEM7Z0JBQWlCckQsTUFBTTFHLFFBQVE7YUFBQztZQUNyRG1LLGNBQWNDLGtCQUFrQi9DLFVBQVU7Z0JBQUMwQztnQkFBaUJyRCxNQUFNeUQsWUFBWTthQUFDO1lBQy9FaEY7UUFDRjtRQUNBLElBQUl1QixNQUFNeUQsWUFBWSxLQUFLLEtBQUs7WUFDOUJKLGtCQUFrQjFDLFVBQVU7Z0JBQUMwQztnQkFBaUJyRCxNQUFNeUQsWUFBWTthQUFDO1FBQ25FO0lBQ0Y7SUFDQSxPQUFPN0Q7QUFDVDtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTK0QsYUFBYUMsWUFBWSxFQUFFMUQsTUFBTTtJQUN4QyxJQUFJQSxXQUFXLEtBQUssR0FBRztRQUNyQkEsU0FBUyxDQUFDO0lBQ1o7SUFDQSxJQUFJakcsT0FBTzJKO0lBQ1gsSUFBSTNKLEtBQUt5SCxRQUFRLENBQUMsUUFBUXpILFNBQVMsT0FBTyxDQUFDQSxLQUFLeUgsUUFBUSxDQUFDLE9BQU87UUFDOURuSSxRQUFRLE9BQU8saUJBQWtCVSxPQUFPLHFDQUF1QyxPQUFPQSxLQUFLUyxPQUFPLENBQUMsT0FBTyxRQUFRLG1DQUFtQyxJQUFLLHFFQUFzRSx1Q0FBdUNULEtBQUtTLE9BQU8sQ0FBQyxPQUFPLFFBQVEsSUFBSTtRQUN2U1QsT0FBT0EsS0FBS1MsT0FBTyxDQUFDLE9BQU87SUFDN0I7SUFDQSwrREFBK0Q7SUFDL0QsTUFBTW1KLFNBQVM1SixLQUFLeUIsVUFBVSxDQUFDLE9BQU8sTUFBTTtJQUM1QyxNQUFNaEMsWUFBWW9LLENBQUFBLElBQUtBLEtBQUssT0FBTyxLQUFLLE9BQU9BLE1BQU0sV0FBV0EsSUFBSUMsT0FBT0Q7SUFDM0UsTUFBTXpDLFdBQVdwSCxLQUFLcUgsS0FBSyxDQUFDLE9BQU9sSixHQUFHLENBQUMsQ0FBQzJLLFNBQVN6SyxPQUFPMEw7UUFDdEQsTUFBTUMsZ0JBQWdCM0wsVUFBVTBMLE1BQU0zTSxNQUFNLEdBQUc7UUFDL0MsZ0RBQWdEO1FBQ2hELElBQUk0TSxpQkFBaUJsQixZQUFZLEtBQUs7WUFDcEMsTUFBTW1CLE9BQU87WUFDYixrQkFBa0I7WUFDbEIsT0FBT3hLLFVBQVV3RyxNQUFNLENBQUNnRSxLQUFLO1FBQy9CO1FBQ0EsTUFBTUMsV0FBV3BCLFFBQVEvQyxLQUFLLENBQUM7UUFDL0IsSUFBSW1FLFVBQVU7WUFDWixNQUFNLEdBQUc1TSxLQUFLNk0sU0FBUyxHQUFHRDtZQUMxQixJQUFJRSxRQUFRbkUsTUFBTSxDQUFDM0ksSUFBSTtZQUN2QitFLFVBQVU4SCxhQUFhLE9BQU9DLFNBQVMsTUFBTSxlQUFnQjlNLE1BQU07WUFDbkUsT0FBT21DLFVBQVUySztRQUNuQjtRQUNBLDREQUE0RDtRQUM1RCxPQUFPdEIsUUFBUXJJLE9BQU8sQ0FBQyxRQUFRO0lBQ2pDLEVBQ0Esd0JBQXdCO0tBQ3ZCbUksTUFBTSxDQUFDRSxDQUFBQSxVQUFXLENBQUMsQ0FBQ0E7SUFDckIsT0FBT2MsU0FBU3hDLFNBQVNwQyxJQUFJLENBQUM7QUFDaEM7QUFDQTs7Ozs7Q0FLQyxHQUNELFNBQVN1RSxVQUFVYyxPQUFPLEVBQUVoTCxRQUFRO0lBQ2xDLElBQUksT0FBT2dMLFlBQVksVUFBVTtRQUMvQkEsVUFBVTtZQUNSckssTUFBTXFLO1lBQ043RCxlQUFlO1lBQ2Y2QyxLQUFLO1FBQ1A7SUFDRjtJQUNBLElBQUksQ0FBQ2lCLFNBQVNDLGVBQWUsR0FBR0MsWUFBWUgsUUFBUXJLLElBQUksRUFBRXFLLFFBQVE3RCxhQUFhLEVBQUU2RCxRQUFRaEIsR0FBRztJQUM1RixJQUFJdEQsUUFBUTFHLFNBQVMwRyxLQUFLLENBQUN1RTtJQUMzQixJQUFJLENBQUN2RSxPQUFPLE9BQU87SUFDbkIsSUFBSXFELGtCQUFrQnJELEtBQUssQ0FBQyxFQUFFO0lBQzlCLElBQUl5RCxlQUFlSixnQkFBZ0IzSSxPQUFPLENBQUMsV0FBVztJQUN0RCxJQUFJZ0ssZ0JBQWdCMUUsTUFBTTVELEtBQUssQ0FBQztJQUNoQyxJQUFJOEQsU0FBU3NFLGVBQWUxQixNQUFNLENBQUMsQ0FBQzZCLE1BQU12SCxNQUFNOUU7UUFDOUMsSUFBSSxFQUNGc00sU0FBUyxFQUNUbkQsVUFBVSxFQUNYLEdBQUdyRTtRQUNKLHFFQUFxRTtRQUNyRSxxRUFBcUU7UUFDckUsSUFBSXdILGNBQWMsS0FBSztZQUNyQixJQUFJQyxhQUFhSCxhQUFhLENBQUNwTSxNQUFNLElBQUk7WUFDekNtTCxlQUFlSixnQkFBZ0JqSCxLQUFLLENBQUMsR0FBR2lILGdCQUFnQmhNLE1BQU0sR0FBR3dOLFdBQVd4TixNQUFNLEVBQUVxRCxPQUFPLENBQUMsV0FBVztRQUN6RztRQUNBLE1BQU02QixRQUFRbUksYUFBYSxDQUFDcE0sTUFBTTtRQUNsQyxJQUFJbUosY0FBYyxDQUFDbEYsT0FBTztZQUN4Qm9JLElBQUksQ0FBQ0MsVUFBVSxHQUFHbk07UUFDcEIsT0FBTztZQUNMa00sSUFBSSxDQUFDQyxVQUFVLEdBQUdFLHlCQUF5QnZJLFNBQVMsSUFBSXFJO1FBQzFEO1FBQ0EsT0FBT0Q7SUFDVCxHQUFHLENBQUM7SUFDSixPQUFPO1FBQ0x6RTtRQUNBNUcsVUFBVStKO1FBQ1ZJO1FBQ0FhO0lBQ0Y7QUFDRjtBQUNBLFNBQVNHLFlBQVl4SyxJQUFJLEVBQUV3RyxhQUFhLEVBQUU2QyxHQUFHO0lBQzNDLElBQUk3QyxrQkFBa0IsS0FBSyxHQUFHO1FBQzVCQSxnQkFBZ0I7SUFDbEI7SUFDQSxJQUFJNkMsUUFBUSxLQUFLLEdBQUc7UUFDbEJBLE1BQU07SUFDUjtJQUNBL0osUUFBUVUsU0FBUyxPQUFPLENBQUNBLEtBQUt5SCxRQUFRLENBQUMsUUFBUXpILEtBQUt5SCxRQUFRLENBQUMsT0FBTyxpQkFBa0J6SCxPQUFPLHFDQUF1QyxPQUFPQSxLQUFLUyxPQUFPLENBQUMsT0FBTyxRQUFRLG1DQUFtQyxJQUFLLHFFQUFzRSx1Q0FBdUNULEtBQUtTLE9BQU8sQ0FBQyxPQUFPLFFBQVEsSUFBSTtJQUM1VixJQUFJd0YsU0FBUyxFQUFFO0lBQ2YsSUFBSTZFLGVBQWUsTUFBTTlLLEtBQUtTLE9BQU8sQ0FBQyxXQUFXLElBQUksa0RBQWtEO0tBQ3RHQSxPQUFPLENBQUMsUUFBUSxLQUFLLCtCQUErQjtLQUNwREEsT0FBTyxDQUFDLHNCQUFzQixRQUFRLDZCQUE2QjtLQUNuRUEsT0FBTyxDQUFDLHFCQUFxQixDQUFDc0ssR0FBR0osV0FBV25EO1FBQzNDdkIsT0FBTzdGLElBQUksQ0FBQztZQUNWdUs7WUFDQW5ELFlBQVlBLGNBQWM7UUFDNUI7UUFDQSxPQUFPQSxhQUFhLGlCQUFpQjtJQUN2QztJQUNBLElBQUl4SCxLQUFLeUgsUUFBUSxDQUFDLE1BQU07UUFDdEJ4QixPQUFPN0YsSUFBSSxDQUFDO1lBQ1Z1SyxXQUFXO1FBQ2I7UUFDQUcsZ0JBQWdCOUssU0FBUyxPQUFPQSxTQUFTLE9BQU8sUUFBUSxxREFBcUQ7V0FDM0cscUJBQXFCLHFDQUFxQztJQUM5RCxPQUFPLElBQUlxSixLQUFLO1FBQ2Qsb0RBQW9EO1FBQ3BEeUIsZ0JBQWdCO0lBQ2xCLE9BQU8sSUFBSTlLLFNBQVMsTUFBTUEsU0FBUyxLQUFLO1FBQ3RDLDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUsNEVBQTRFO1FBQzVFLHlFQUF5RTtRQUN6RSx3RUFBd0U7UUFDeEUsOERBQThEO1FBQzlELHlEQUF5RDtRQUN6RDhLLGdCQUFnQjtJQUNsQjtJQUNBLElBQUlSLFVBQVUsSUFBSVUsT0FBT0YsY0FBY3RFLGdCQUFnQmhJLFlBQVk7SUFDbkUsT0FBTztRQUFDOEw7UUFBU3JFO0tBQU87QUFDMUI7QUFDQSxTQUFTSixnQkFBZ0J2RCxLQUFLO0lBQzVCLElBQUk7UUFDRixPQUFPMkksVUFBVTNJO0lBQ25CLEVBQUUsT0FBT3dCLE9BQU87UUFDZHhFLFFBQVEsT0FBTyxtQkFBb0JnRCxRQUFRLCtDQUFnRCxrRUFBbUUsZ0JBQWV3QixRQUFRLElBQUc7UUFDeEwsT0FBT3hCO0lBQ1Q7QUFDRjtBQUNBLFNBQVN1SSx5QkFBeUJ2SSxLQUFLLEVBQUVxSSxTQUFTO0lBQ2hELElBQUk7UUFDRixPQUFPTyxtQkFBbUI1STtJQUM1QixFQUFFLE9BQU93QixPQUFPO1FBQ2R4RSxRQUFRLE9BQU8sa0NBQW1DcUwsWUFBWSxrQ0FBb0MsbUJBQW1CckksUUFBUSxnREFBZ0QsSUFBTSxzQ0FBcUN3QixRQUFRLElBQUc7UUFDbk8sT0FBT3hCO0lBQ1Q7QUFDRjtBQUNBOztDQUVDLEdBQ0QsU0FBU2lELGNBQWNsRyxRQUFRLEVBQUVpRyxRQUFRO0lBQ3ZDLElBQUlBLGFBQWEsS0FBSyxPQUFPakc7SUFDN0IsSUFBSSxDQUFDQSxTQUFTOEwsV0FBVyxHQUFHMUosVUFBVSxDQUFDNkQsU0FBUzZGLFdBQVcsS0FBSztRQUM5RCxPQUFPO0lBQ1Q7SUFDQSw2RUFBNkU7SUFDN0UsaUVBQWlFO0lBQ2pFLElBQUlDLGFBQWE5RixTQUFTbUMsUUFBUSxDQUFDLE9BQU9uQyxTQUFTbEksTUFBTSxHQUFHLElBQUlrSSxTQUFTbEksTUFBTTtJQUMvRSxJQUFJaU8sV0FBV2hNLFNBQVNFLE1BQU0sQ0FBQzZMO0lBQy9CLElBQUlDLFlBQVlBLGFBQWEsS0FBSztRQUNoQyx5Q0FBeUM7UUFDekMsT0FBTztJQUNUO0lBQ0EsT0FBT2hNLFNBQVM4QyxLQUFLLENBQUNpSixlQUFlO0FBQ3ZDO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVNFLFlBQVlwTSxFQUFFLEVBQUVxTSxZQUFZO0lBQ25DLElBQUlBLGlCQUFpQixLQUFLLEdBQUc7UUFDM0JBLGVBQWU7SUFDakI7SUFDQSxJQUFJLEVBQ0ZsTSxVQUFVbU0sVUFBVSxFQUNwQnRMLFNBQVMsRUFBRSxFQUNYQyxPQUFPLEVBQUUsRUFDVixHQUFHLE9BQU9qQixPQUFPLFdBQVdlLFVBQVVmLE1BQU1BO0lBQzdDLElBQUlHLFdBQVdtTSxhQUFhQSxXQUFXL0osVUFBVSxDQUFDLE9BQU8rSixhQUFhQyxnQkFBZ0JELFlBQVlELGdCQUFnQkE7SUFDbEgsT0FBTztRQUNMbE07UUFDQWEsUUFBUXdMLGdCQUFnQnhMO1FBQ3hCQyxNQUFNd0wsY0FBY3hMO0lBQ3RCO0FBQ0Y7QUFDQSxTQUFTc0wsZ0JBQWdCbkYsWUFBWSxFQUFFaUYsWUFBWTtJQUNqRCxJQUFJbkUsV0FBV21FLGFBQWE5SyxPQUFPLENBQUMsUUFBUSxJQUFJNEcsS0FBSyxDQUFDO0lBQ3RELElBQUl1RSxtQkFBbUJ0RixhQUFhZSxLQUFLLENBQUM7SUFDMUN1RSxpQkFBaUI3RSxPQUFPLENBQUMrQixDQUFBQTtRQUN2QixJQUFJQSxZQUFZLE1BQU07WUFDcEIsdURBQXVEO1lBQ3ZELElBQUkxQixTQUFTaEssTUFBTSxHQUFHLEdBQUdnSyxTQUFTeUUsR0FBRztRQUN2QyxPQUFPLElBQUkvQyxZQUFZLEtBQUs7WUFDMUIxQixTQUFTaEgsSUFBSSxDQUFDMEk7UUFDaEI7SUFDRjtJQUNBLE9BQU8xQixTQUFTaEssTUFBTSxHQUFHLElBQUlnSyxTQUFTcEMsSUFBSSxDQUFDLE9BQU87QUFDcEQ7QUFDQSxTQUFTOEcsb0JBQW9CQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFak0sSUFBSTtJQUNsRCxPQUFPLHVCQUF1QitMLE9BQU8seUNBQTBDLFVBQVNDLFFBQVEsY0FBY3hNLEtBQUtDLFNBQVMsQ0FBQ08sUUFBUSxvQ0FBbUMsSUFBTSxVQUFTaU0sT0FBTywwREFBeUQsSUFBSztBQUM5UDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsU0FBU0MsMkJBQTJCdkcsT0FBTztJQUN6QyxPQUFPQSxRQUFRaUQsTUFBTSxDQUFDLENBQUM3QyxPQUFPMUgsUUFBVUEsVUFBVSxLQUFLMEgsTUFBTXZCLEtBQUssQ0FBQ3hFLElBQUksSUFBSStGLE1BQU12QixLQUFLLENBQUN4RSxJQUFJLENBQUM1QyxNQUFNLEdBQUc7QUFDdkc7QUFDQSx3RUFBd0U7QUFDeEUsb0RBQW9EO0FBQ3BELFNBQVMrTyxvQkFBb0J4RyxPQUFPLEVBQUV5RyxvQkFBb0I7SUFDeEQsSUFBSUMsY0FBY0gsMkJBQTJCdkc7SUFDN0MsMkVBQTJFO0lBQzNFLHdEQUF3RDtJQUN4RCxpRkFBaUY7SUFDakYsSUFBSXlHLHNCQUFzQjtRQUN4QixPQUFPQyxZQUFZbE8sR0FBRyxDQUFDLENBQUM0SCxPQUFPOUMsTUFBUUEsUUFBUTBDLFFBQVF2SSxNQUFNLEdBQUcsSUFBSTJJLE1BQU0xRyxRQUFRLEdBQUcwRyxNQUFNeUQsWUFBWTtJQUN6RztJQUNBLE9BQU82QyxZQUFZbE8sR0FBRyxDQUFDNEgsQ0FBQUEsUUFBU0EsTUFBTXlELFlBQVk7QUFDcEQ7QUFDQTs7Q0FFQyxHQUNELFNBQVM4QyxVQUFVQyxLQUFLLEVBQUVDLGNBQWMsRUFBRUMsZ0JBQWdCLEVBQUVDLGNBQWM7SUFDeEUsSUFBSUEsbUJBQW1CLEtBQUssR0FBRztRQUM3QkEsaUJBQWlCO0lBQ25CO0lBQ0EsSUFBSXhOO0lBQ0osSUFBSSxPQUFPcU4sVUFBVSxVQUFVO1FBQzdCck4sS0FBS2UsVUFBVXNNO0lBQ2pCLE9BQU87UUFDTHJOLEtBQUtyQyxTQUFTLENBQUMsR0FBRzBQO1FBQ2xCbEssVUFBVSxDQUFDbkQsR0FBR0csUUFBUSxJQUFJLENBQUNILEdBQUdHLFFBQVEsQ0FBQzRILFFBQVEsQ0FBQyxNQUFNNkUsb0JBQW9CLEtBQUssWUFBWSxVQUFVNU07UUFDckdtRCxVQUFVLENBQUNuRCxHQUFHRyxRQUFRLElBQUksQ0FBQ0gsR0FBR0csUUFBUSxDQUFDNEgsUUFBUSxDQUFDLE1BQU02RSxvQkFBb0IsS0FBSyxZQUFZLFFBQVE1TTtRQUNuR21ELFVBQVUsQ0FBQ25ELEdBQUdnQixNQUFNLElBQUksQ0FBQ2hCLEdBQUdnQixNQUFNLENBQUMrRyxRQUFRLENBQUMsTUFBTTZFLG9CQUFvQixLQUFLLFVBQVUsUUFBUTVNO0lBQy9GO0lBQ0EsSUFBSXlOLGNBQWNKLFVBQVUsTUFBTXJOLEdBQUdHLFFBQVEsS0FBSztJQUNsRCxJQUFJbU0sYUFBYW1CLGNBQWMsTUFBTXpOLEdBQUdHLFFBQVE7SUFDaEQsSUFBSXVOO0lBQ0osdUVBQXVFO0lBQ3ZFLEVBQUU7SUFDRiw2RUFBNkU7SUFDN0UsMEVBQTBFO0lBQzFFLDJFQUEyRTtJQUMzRSw4RUFBOEU7SUFDOUUsNkVBQTZFO0lBQzdFLDhFQUE4RTtJQUM5RSxtRUFBbUU7SUFDbkUsSUFBSXBCLGNBQWMsTUFBTTtRQUN0Qm9CLE9BQU9IO0lBQ1QsT0FBTztRQUNMLElBQUlJLHFCQUFxQkwsZUFBZXBQLE1BQU0sR0FBRztRQUNqRCxxRUFBcUU7UUFDckUsdUVBQXVFO1FBQ3ZFLHVFQUF1RTtRQUN2RSxrQ0FBa0M7UUFDbEMsSUFBSSxDQUFDc1Asa0JBQWtCbEIsV0FBVy9KLFVBQVUsQ0FBQyxPQUFPO1lBQ2xELElBQUlxTCxhQUFhdEIsV0FBV25FLEtBQUssQ0FBQztZQUNsQyxNQUFPeUYsVUFBVSxDQUFDLEVBQUUsS0FBSyxLQUFNO2dCQUM3QkEsV0FBV0MsS0FBSztnQkFDaEJGLHNCQUFzQjtZQUN4QjtZQUNBM04sR0FBR0csUUFBUSxHQUFHeU4sV0FBVzlILElBQUksQ0FBQztRQUNoQztRQUNBNEgsT0FBT0Msc0JBQXNCLElBQUlMLGNBQWMsQ0FBQ0ssbUJBQW1CLEdBQUc7SUFDeEU7SUFDQSxJQUFJN00sT0FBT3NMLFlBQVlwTSxJQUFJME47SUFDM0Isd0VBQXdFO0lBQ3hFLElBQUlJLDJCQUEyQnhCLGNBQWNBLGVBQWUsT0FBT0EsV0FBVy9ELFFBQVEsQ0FBQztJQUN2Rix1RUFBdUU7SUFDdkUsSUFBSXdGLDBCQUEwQixDQUFDTixlQUFlbkIsZUFBZSxHQUFFLEtBQU1pQixpQkFBaUJoRixRQUFRLENBQUM7SUFDL0YsSUFBSSxDQUFDekgsS0FBS1gsUUFBUSxDQUFDb0ksUUFBUSxDQUFDLFFBQVN1RixDQUFBQSw0QkFBNEJDLHVCQUFzQixHQUFJO1FBQ3pGak4sS0FBS1gsUUFBUSxJQUFJO0lBQ25CO0lBQ0EsT0FBT1c7QUFDVDtBQUNBOztDQUVDLEdBQ0QsU0FBU2tOLGNBQWNoTyxFQUFFO0lBQ3ZCLHNEQUFzRDtJQUN0RCxPQUFPQSxPQUFPLE1BQU1BLEdBQUdHLFFBQVEsS0FBSyxLQUFLLE1BQU0sT0FBT0gsT0FBTyxXQUFXZSxVQUFVZixJQUFJRyxRQUFRLEdBQUdILEdBQUdHLFFBQVE7QUFDOUc7QUFDQTs7Q0FFQyxHQUNELE1BQU1xSCxZQUFZeUcsQ0FBQUEsUUFBU0EsTUFBTW5JLElBQUksQ0FBQyxLQUFLdkUsT0FBTyxDQUFDLFVBQVU7QUFDN0Q7O0NBRUMsR0FDRCxNQUFNZ0osb0JBQW9CcEssQ0FBQUEsV0FBWUEsU0FBU29CLE9BQU8sQ0FBQyxRQUFRLElBQUlBLE9BQU8sQ0FBQyxRQUFRO0FBQ25GOztDQUVDLEdBQ0QsTUFBTWlMLGtCQUFrQnhMLENBQUFBLFNBQVUsQ0FBQ0EsVUFBVUEsV0FBVyxNQUFNLEtBQUtBLE9BQU91QixVQUFVLENBQUMsT0FBT3ZCLFNBQVMsTUFBTUE7QUFDM0c7O0NBRUMsR0FDRCxNQUFNeUwsZ0JBQWdCeEwsQ0FBQUEsT0FBUSxDQUFDQSxRQUFRQSxTQUFTLE1BQU0sS0FBS0EsS0FBS3NCLFVBQVUsQ0FBQyxPQUFPdEIsT0FBTyxNQUFNQTtBQUMvRjs7O0NBR0MsR0FDRCxNQUFNaU4sT0FBTyxTQUFTQSxLQUFLbEgsSUFBSSxFQUFFbUgsSUFBSTtJQUNuQyxJQUFJQSxTQUFTLEtBQUssR0FBRztRQUNuQkEsT0FBTyxDQUFDO0lBQ1Y7SUFDQSxJQUFJQyxlQUFlLE9BQU9ELFNBQVMsV0FBVztRQUM1Q0UsUUFBUUY7SUFDVixJQUFJQTtJQUNKLElBQUlHLFVBQVUsSUFBSUMsUUFBUUgsYUFBYUUsT0FBTztJQUM5QyxJQUFJLENBQUNBLFFBQVFFLEdBQUcsQ0FBQyxpQkFBaUI7UUFDaENGLFFBQVFHLEdBQUcsQ0FBQyxnQkFBZ0I7SUFDOUI7SUFDQSxPQUFPLElBQUlDLFNBQVNwTyxLQUFLQyxTQUFTLENBQUN5RyxPQUFPckosU0FBUyxDQUFDLEdBQUd5USxjQUFjO1FBQ25FRTtJQUNGO0FBQ0Y7QUFDQSxNQUFNSyw2QkFBNkJyTDtBQUFPO0FBQzFDLE1BQU1zTDtJQTBCSkMsYUFBYXpRLEdBQUcsRUFBRWdGLEtBQUssRUFBRTtRQUN2QixJQUFJLENBQUVBLENBQUFBLGlCQUFpQjBMLE9BQU0sR0FBSTtZQUMvQixPQUFPMUw7UUFDVDtRQUNBLElBQUksQ0FBQzJMLFlBQVksQ0FBQzdOLElBQUksQ0FBQzlDO1FBQ3ZCLElBQUksQ0FBQzRRLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDN1E7UUFDeEIsK0RBQStEO1FBQy9ELHlDQUF5QztRQUN6QyxJQUFJOFEsVUFBVUosUUFBUUssSUFBSSxDQUFDO1lBQUMvTDtZQUFPLElBQUksQ0FBQ2dNLFlBQVk7U0FBQyxFQUFFQyxJQUFJLENBQUNySSxDQUFBQSxPQUFRLElBQUksQ0FBQ3NJLFFBQVEsQ0FBQ0osU0FBUzlRLEtBQUtrQixXQUFXMEgsT0FBT3BDLENBQUFBLFFBQVMsSUFBSSxDQUFDMEssUUFBUSxDQUFDSixTQUFTOVEsS0FBS3dHO1FBQ3ZKLHVFQUF1RTtRQUN2RSxvQ0FBb0M7UUFDcENzSyxRQUFRSyxLQUFLLENBQUMsS0FBTztRQUNyQjNSLE9BQU80UixjQUFjLENBQUNOLFNBQVMsWUFBWTtZQUN6Q08sS0FBSyxJQUFNO1FBQ2I7UUFDQSxPQUFPUDtJQUNUO0lBQ0FJLFNBQVNKLE9BQU8sRUFBRTlRLEdBQUcsRUFBRXdHLEtBQUssRUFBRW9DLElBQUksRUFBRTtRQUNsQyxJQUFJLElBQUksQ0FBQzBJLFVBQVUsQ0FBQ0MsTUFBTSxDQUFDQyxPQUFPLElBQUloTCxpQkFBaUIrSixzQkFBc0I7WUFDM0UsSUFBSSxDQUFDa0IsbUJBQW1CO1lBQ3hCalMsT0FBTzRSLGNBQWMsQ0FBQ04sU0FBUyxVQUFVO2dCQUN2Q08sS0FBSyxJQUFNN0s7WUFDYjtZQUNBLE9BQU9rSyxRQUFRZ0IsTUFBTSxDQUFDbEw7UUFDeEI7UUFDQSxJQUFJLENBQUNvSyxjQUFjLENBQUNlLE1BQU0sQ0FBQzNSO1FBQzNCLElBQUksSUFBSSxDQUFDNFIsSUFBSSxFQUFFO1lBQ2IseUJBQXlCO1lBQ3pCLElBQUksQ0FBQ0gsbUJBQW1CO1FBQzFCO1FBQ0EsbUZBQW1GO1FBQ25GLDZDQUE2QztRQUM3QyxJQUFJakwsVUFBVXRGLGFBQWEwSCxTQUFTMUgsV0FBVztZQUM3QyxJQUFJMlEsaUJBQWlCLElBQUkzTSxNQUFNLDRCQUE2QmxGLE1BQU0sMkNBQTRDO1lBQzlHUixPQUFPNFIsY0FBYyxDQUFDTixTQUFTLFVBQVU7Z0JBQ3ZDTyxLQUFLLElBQU1RO1lBQ2I7WUFDQSxJQUFJLENBQUNDLElBQUksQ0FBQyxPQUFPOVI7WUFDakIsT0FBTzBRLFFBQVFnQixNQUFNLENBQUNHO1FBQ3hCO1FBQ0EsSUFBSWpKLFNBQVMxSCxXQUFXO1lBQ3RCMUIsT0FBTzRSLGNBQWMsQ0FBQ04sU0FBUyxVQUFVO2dCQUN2Q08sS0FBSyxJQUFNN0s7WUFDYjtZQUNBLElBQUksQ0FBQ3NMLElBQUksQ0FBQyxPQUFPOVI7WUFDakIsT0FBTzBRLFFBQVFnQixNQUFNLENBQUNsTDtRQUN4QjtRQUNBaEgsT0FBTzRSLGNBQWMsQ0FBQ04sU0FBUyxTQUFTO1lBQ3RDTyxLQUFLLElBQU16STtRQUNiO1FBQ0EsSUFBSSxDQUFDa0osSUFBSSxDQUFDLE9BQU85UjtRQUNqQixPQUFPNEk7SUFDVDtJQUNBa0osS0FBS04sT0FBTyxFQUFFTyxVQUFVLEVBQUU7UUFDeEIsSUFBSSxDQUFDQyxXQUFXLENBQUN2SSxPQUFPLENBQUN3SSxDQUFBQSxhQUFjQSxXQUFXVCxTQUFTTztJQUM3RDtJQUNBRyxVQUFVMU8sRUFBRSxFQUFFO1FBQ1osSUFBSSxDQUFDd08sV0FBVyxDQUFDbkIsR0FBRyxDQUFDck47UUFDckIsT0FBTyxJQUFNLElBQUksQ0FBQ3dPLFdBQVcsQ0FBQ0wsTUFBTSxDQUFDbk87SUFDdkM7SUFDQTJPLFNBQVM7UUFDUCxJQUFJLENBQUNiLFVBQVUsQ0FBQ2MsS0FBSztRQUNyQixJQUFJLENBQUN4QixjQUFjLENBQUNuSCxPQUFPLENBQUMsQ0FBQzRJLEdBQUdDLElBQU0sSUFBSSxDQUFDMUIsY0FBYyxDQUFDZSxNQUFNLENBQUNXO1FBQ2pFLElBQUksQ0FBQ1IsSUFBSSxDQUFDO0lBQ1o7SUFDQSxNQUFNUyxZQUFZaEIsTUFBTSxFQUFFO1FBQ3hCLElBQUlDLFVBQVU7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDSSxJQUFJLEVBQUU7WUFDZCxJQUFJWSxVQUFVLElBQU0sSUFBSSxDQUFDTCxNQUFNO1lBQy9CWixPQUFPM0ssZ0JBQWdCLENBQUMsU0FBUzRMO1lBQ2pDaEIsVUFBVSxNQUFNLElBQUlkLFFBQVErQixDQUFBQTtnQkFDMUIsSUFBSSxDQUFDUCxTQUFTLENBQUNWLENBQUFBO29CQUNiRCxPQUFPMUssbUJBQW1CLENBQUMsU0FBUzJMO29CQUNwQyxJQUFJaEIsV0FBVyxJQUFJLENBQUNJLElBQUksRUFBRTt3QkFDeEJhLFFBQVFqQjtvQkFDVjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxPQUFPQTtJQUNUO0lBQ0EsSUFBSUksT0FBTztRQUNULE9BQU8sSUFBSSxDQUFDaEIsY0FBYyxDQUFDOEIsSUFBSSxLQUFLO0lBQ3RDO0lBQ0EsSUFBSUMsZ0JBQWdCO1FBQ2xCNU4sVUFBVSxJQUFJLENBQUM2RCxJQUFJLEtBQUssUUFBUSxJQUFJLENBQUNnSixJQUFJLEVBQUU7UUFDM0MsT0FBT3BTLE9BQU9vQixPQUFPLENBQUMsSUFBSSxDQUFDZ0ksSUFBSSxFQUFFMkMsTUFBTSxDQUFDLENBQUNxSCxLQUFLQztZQUM1QyxJQUFJLENBQUM3UyxLQUFLZ0YsTUFBTSxHQUFHNk47WUFDbkIsT0FBT3JULE9BQU9DLE1BQU0sQ0FBQ21ULEtBQUs7Z0JBQ3hCLENBQUM1UyxJQUFJLEVBQUU4UyxxQkFBcUI5TjtZQUM5QjtRQUNGLEdBQUcsQ0FBQztJQUNOO0lBQ0EsSUFBSStOLGNBQWM7UUFDaEIsT0FBT0MsTUFBTTFELElBQUksQ0FBQyxJQUFJLENBQUNzQixjQUFjO0lBQ3ZDO0lBeEhBcUMsWUFBWXJLLElBQUksRUFBRW9ILFlBQVksQ0FBRTtRQUM5QixJQUFJLENBQUNZLGNBQWMsR0FBRyxJQUFJNUo7UUFDMUIsSUFBSSxDQUFDZ0wsV0FBVyxHQUFHLElBQUloTDtRQUN2QixJQUFJLENBQUMySixZQUFZLEdBQUcsRUFBRTtRQUN0QjVMLFVBQVU2RCxRQUFRLE9BQU9BLFNBQVMsWUFBWSxDQUFDb0ssTUFBTUUsT0FBTyxDQUFDdEssT0FBTztRQUNwRSx3RUFBd0U7UUFDeEUsZUFBZTtRQUNmLElBQUk4STtRQUNKLElBQUksQ0FBQ1YsWUFBWSxHQUFHLElBQUlOLFFBQVEsQ0FBQ2pELEdBQUcwRixJQUFNekIsU0FBU3lCO1FBQ25ELElBQUksQ0FBQzdCLFVBQVUsR0FBRyxJQUFJOEI7UUFDdEIsSUFBSVosVUFBVSxJQUFNZCxPQUFPLElBQUluQixxQkFBcUI7UUFDcEQsSUFBSSxDQUFDa0IsbUJBQW1CLEdBQUcsSUFBTSxJQUFJLENBQUNILFVBQVUsQ0FBQ0MsTUFBTSxDQUFDMUssbUJBQW1CLENBQUMsU0FBUzJMO1FBQ3JGLElBQUksQ0FBQ2xCLFVBQVUsQ0FBQ0MsTUFBTSxDQUFDM0ssZ0JBQWdCLENBQUMsU0FBUzRMO1FBQ2pELElBQUksQ0FBQzVKLElBQUksR0FBR3BKLE9BQU9vQixPQUFPLENBQUNnSSxNQUFNMkMsTUFBTSxDQUFDLENBQUNxSCxLQUFLUztZQUM1QyxJQUFJLENBQUNyVCxLQUFLZ0YsTUFBTSxHQUFHcU87WUFDbkIsT0FBTzdULE9BQU9DLE1BQU0sQ0FBQ21ULEtBQUs7Z0JBQ3hCLENBQUM1UyxJQUFJLEVBQUUsSUFBSSxDQUFDeVEsWUFBWSxDQUFDelEsS0FBS2dGO1lBQ2hDO1FBQ0YsR0FBRyxDQUFDO1FBQ0osSUFBSSxJQUFJLENBQUM0TSxJQUFJLEVBQUU7WUFDYixvQ0FBb0M7WUFDcEMsSUFBSSxDQUFDSCxtQkFBbUI7UUFDMUI7UUFDQSxJQUFJLENBQUMxQixJQUFJLEdBQUdDO0lBQ2Q7QUFpR0Y7QUFDQSxTQUFTc0QsaUJBQWlCdE8sS0FBSztJQUM3QixPQUFPQSxpQkFBaUIwTCxXQUFXMUwsTUFBTXVPLFFBQVEsS0FBSztBQUN4RDtBQUNBLFNBQVNULHFCQUFxQjlOLEtBQUs7SUFDakMsSUFBSSxDQUFDc08saUJBQWlCdE8sUUFBUTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsSUFBSUEsTUFBTXdPLE1BQU0sRUFBRTtRQUNoQixNQUFNeE8sTUFBTXdPLE1BQU07SUFDcEI7SUFDQSxPQUFPeE8sTUFBTXlPLEtBQUs7QUFDcEI7QUFDQSxNQUFNQyxRQUFRLFNBQVNBLE1BQU05SyxJQUFJLEVBQUVtSCxJQUFJO0lBQ3JDLElBQUlBLFNBQVMsS0FBSyxHQUFHO1FBQ25CQSxPQUFPLENBQUM7SUFDVjtJQUNBLElBQUlDLGVBQWUsT0FBT0QsU0FBUyxXQUFXO1FBQzVDRSxRQUFRRjtJQUNWLElBQUlBO0lBQ0osT0FBTyxJQUFJUyxhQUFhNUgsTUFBTW9IO0FBQ2hDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTTJELFdBQVcsU0FBU0EsU0FBU2pQLEdBQUcsRUFBRXFMLElBQUk7SUFDMUMsSUFBSUEsU0FBUyxLQUFLLEdBQUc7UUFDbkJBLE9BQU87SUFDVDtJQUNBLElBQUlDLGVBQWVEO0lBQ25CLElBQUksT0FBT0MsaUJBQWlCLFVBQVU7UUFDcENBLGVBQWU7WUFDYkMsUUFBUUQ7UUFDVjtJQUNGLE9BQU8sSUFBSSxPQUFPQSxhQUFhQyxNQUFNLEtBQUssYUFBYTtRQUNyREQsYUFBYUMsTUFBTSxHQUFHO0lBQ3hCO0lBQ0EsSUFBSUMsVUFBVSxJQUFJQyxRQUFRSCxhQUFhRSxPQUFPO0lBQzlDQSxRQUFRRyxHQUFHLENBQUMsWUFBWTNMO0lBQ3hCLE9BQU8sSUFBSTRMLFNBQVMsTUFBTS9RLFNBQVMsQ0FBQyxHQUFHeVEsY0FBYztRQUNuREU7SUFDRjtBQUNGO0FBQ0E7Ozs7Q0FJQyxHQUNELE1BQU0wRCxtQkFBbUIsQ0FBQ2xQLEtBQUtxTDtJQUM3QixJQUFJOEQsV0FBV0YsU0FBU2pQLEtBQUtxTDtJQUM3QjhELFNBQVMzRCxPQUFPLENBQUNHLEdBQUcsQ0FBQywyQkFBMkI7SUFDaEQsT0FBT3dEO0FBQ1Q7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsTUFBTUM7SUFDSmIsWUFBWWhELE1BQU0sRUFBRThELFVBQVUsRUFBRW5MLElBQUksRUFBRW9MLFFBQVEsQ0FBRTtRQUM5QyxJQUFJQSxhQUFhLEtBQUssR0FBRztZQUN2QkEsV0FBVztRQUNiO1FBQ0EsSUFBSSxDQUFDL0QsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQzhELFVBQVUsR0FBR0EsY0FBYztRQUNoQyxJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSXBMLGdCQUFnQjFELE9BQU87WUFDekIsSUFBSSxDQUFDMEQsSUFBSSxHQUFHQSxLQUFLbkQsUUFBUTtZQUN6QixJQUFJLENBQUNlLEtBQUssR0FBR29DO1FBQ2YsT0FBTztZQUNMLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtRQUNkO0lBQ0Y7QUFDRjtBQUNBOzs7Q0FHQyxHQUNELFNBQVNxTCxxQkFBcUJ6TixLQUFLO0lBQ2pDLE9BQU9BLFNBQVMsUUFBUSxPQUFPQSxNQUFNeUosTUFBTSxLQUFLLFlBQVksT0FBT3pKLE1BQU11TixVQUFVLEtBQUssWUFBWSxPQUFPdk4sTUFBTXdOLFFBQVEsS0FBSyxhQUFhLFVBQVV4TjtBQUN2SjtBQUVBLE1BQU0wTiwwQkFBMEI7SUFBQztJQUFRO0lBQU87SUFBUztDQUFTO0FBQ2xFLE1BQU1DLHVCQUF1QixJQUFJbk4sSUFBSWtOO0FBQ3JDLE1BQU1FLHlCQUF5QjtJQUFDO09BQVVGO0NBQXdCO0FBQ2xFLE1BQU1HLHNCQUFzQixJQUFJck4sSUFBSW9OO0FBQ3BDLE1BQU1FLHNCQUFzQixJQUFJdE4sSUFBSTtJQUFDO0lBQUs7SUFBSztJQUFLO0lBQUs7Q0FBSTtBQUM3RCxNQUFNdU4sb0NBQW9DLElBQUl2TixJQUFJO0lBQUM7SUFBSztDQUFJO0FBQzVELE1BQU13TixrQkFBa0I7SUFDdEJ2VCxPQUFPO0lBQ1BZLFVBQVVYO0lBQ1Z1VCxZQUFZdlQ7SUFDWndULFlBQVl4VDtJQUNaeVQsYUFBYXpUO0lBQ2IwVCxVQUFVMVQ7SUFDVjRPLE1BQU01TztJQUNOMlQsTUFBTTNUO0FBQ1I7QUFDQSxNQUFNNFQsZUFBZTtJQUNuQjdULE9BQU87SUFDUDJILE1BQU0xSDtJQUNOdVQsWUFBWXZUO0lBQ1p3VCxZQUFZeFQ7SUFDWnlULGFBQWF6VDtJQUNiMFQsVUFBVTFUO0lBQ1Y0TyxNQUFNNU87SUFDTjJULE1BQU0zVDtBQUNSO0FBQ0EsTUFBTTZULGVBQWU7SUFDbkI5VCxPQUFPO0lBQ1ArVCxTQUFTOVQ7SUFDVCtULE9BQU8vVDtJQUNQVyxVQUFVWDtBQUNaO0FBQ0EsTUFBTWdVLHFCQUFxQjtBQUMzQixNQUFNQyw0QkFBNEJqTyxDQUFBQSxRQUFVO1FBQzFDa08sa0JBQWtCQyxRQUFRbk8sTUFBTWtPLGdCQUFnQjtJQUNsRDtBQUNBLE1BQU1FLDBCQUEwQjtBQUNoQyxZQUFZO0FBQ1osZ0ZBQWdGO0FBQ2hGLHNCQUFzQjtBQUN0QixnRkFBZ0Y7QUFDaEY7O0NBRUMsR0FDRCxTQUFTQyxhQUFheEYsSUFBSTtJQUN4QixNQUFNeUYsZUFBZXpGLEtBQUtwTSxNQUFNLEdBQUdvTSxLQUFLcE0sTUFBTSxHQUFHLEtBQTZCLEdBQUdBLFNBQVN6QyxDQUFTQTtJQUNuRyxNQUFNdVUsWUFBWSxPQUFPRCxpQkFBaUIsZUFBZSxPQUFPQSxhQUFhbFIsUUFBUSxLQUFLLGVBQWUsT0FBT2tSLGFBQWFsUixRQUFRLENBQUNvUixhQUFhLEtBQUs7SUFDeEosTUFBTUMsV0FBVyxDQUFDRjtJQUNsQjFRLFVBQVVnTCxLQUFLM0ksTUFBTSxDQUFDdEgsTUFBTSxHQUFHLEdBQUc7SUFDbEMsSUFBSXVIO0lBQ0osSUFBSTBJLEtBQUsxSSxrQkFBa0IsRUFBRTtRQUMzQkEscUJBQXFCMEksS0FBSzFJLGtCQUFrQjtJQUM5QyxPQUFPLElBQUkwSSxLQUFLNkYsbUJBQW1CLEVBQUU7UUFDbkMsMkVBQTJFO1FBQzNFLElBQUlBLHNCQUFzQjdGLEtBQUs2RixtQkFBbUI7UUFDbER2TyxxQkFBcUJILENBQUFBLFFBQVU7Z0JBQzdCa08sa0JBQWtCUSxvQkFBb0IxTztZQUN4QztJQUNGLE9BQU87UUFDTEcscUJBQXFCOE47SUFDdkI7SUFDQSxxQkFBcUI7SUFDckIsSUFBSTVOLFdBQVcsQ0FBQztJQUNoQixxQ0FBcUM7SUFDckMsSUFBSXNPLGFBQWExTywwQkFBMEI0SSxLQUFLM0ksTUFBTSxFQUFFQyxvQkFBb0JuRyxXQUFXcUc7SUFDdkYsSUFBSXVPO0lBQ0osSUFBSTlOLFdBQVcrSCxLQUFLL0gsUUFBUSxJQUFJO0lBQ2hDLCtCQUErQjtJQUMvQixJQUFJK04sU0FBU3hXLFNBQVM7UUFDcEJ5VyxtQkFBbUI7UUFDbkJDLHdCQUF3QjtRQUN4QkMscUJBQXFCO1FBQ3JCQyxvQkFBb0I7UUFDcEJySCxzQkFBc0I7SUFDeEIsR0FBR2lCLEtBQUtnRyxNQUFNO0lBQ2QsK0JBQStCO0lBQy9CLElBQUlLLGtCQUFrQjtJQUN0Qiw2REFBNkQ7SUFDN0QsSUFBSXBFLGNBQWMsSUFBSWhMO0lBQ3RCLGlGQUFpRjtJQUNqRixJQUFJcVAsdUJBQXVCO0lBQzNCLDhEQUE4RDtJQUM5RCxJQUFJQywwQkFBMEI7SUFDOUIsOERBQThEO0lBQzlELElBQUlDLG9CQUFvQjtJQUN4Qiw4RUFBOEU7SUFDOUUsNEVBQTRFO0lBQzVFLDRFQUE0RTtJQUM1RSx1Q0FBdUM7SUFDdkMsZ0ZBQWdGO0lBQ2hGLDBDQUEwQztJQUMxQyxJQUFJQyx3QkFBd0J6RyxLQUFLMEcsYUFBYSxJQUFJO0lBQ2xELElBQUlDLGlCQUFpQjVPLFlBQVkrTixZQUFZOUYsS0FBS3pOLE9BQU8sQ0FBQ1QsUUFBUSxFQUFFbUc7SUFDcEUsSUFBSTJPLGdCQUFnQjtJQUNwQixJQUFJRCxrQkFBa0IsTUFBTTtRQUMxQixrRUFBa0U7UUFDbEUsMkNBQTJDO1FBQzNDLElBQUlsUSxRQUFRb1EsdUJBQXVCLEtBQUs7WUFDdEM3VSxVQUFVZ08sS0FBS3pOLE9BQU8sQ0FBQ1QsUUFBUSxDQUFDRSxRQUFRO1FBQzFDO1FBQ0EsSUFBSSxFQUNGc0csT0FBTyxFQUNQbkIsS0FBSyxFQUNOLEdBQUcyUCx1QkFBdUJoQjtRQUMzQmEsaUJBQWlCck87UUFDakJzTyxnQkFBZ0I7WUFDZCxDQUFDelAsTUFBTU8sRUFBRSxDQUFDLEVBQUVqQjtRQUNkO0lBQ0Y7SUFDQSxJQUFJc1E7SUFDSixJQUFJQyxnQkFBZ0JMLGVBQWVyTCxJQUFJLENBQUMyTCxDQUFBQSxJQUFLQSxFQUFFOVAsS0FBSyxDQUFDK1AsSUFBSTtJQUN6RCxJQUFJQyxhQUFhUixlQUFlckwsSUFBSSxDQUFDMkwsQ0FBQUEsSUFBS0EsRUFBRTlQLEtBQUssQ0FBQ2lRLE1BQU07SUFDeEQsSUFBSUosZUFBZTtRQUNqQiw0RUFBNEU7UUFDNUUscUVBQXFFO1FBQ3JFRCxjQUFjO0lBQ2hCLE9BQU8sSUFBSSxDQUFDSSxZQUFZO1FBQ3RCLHdEQUF3RDtRQUN4REosY0FBYztJQUNoQixPQUFPLElBQUlmLE9BQU9HLG1CQUFtQixFQUFFO1FBQ3JDLHdFQUF3RTtRQUN4RSw0RUFBNEU7UUFDNUUscUNBQXFDO1FBQ3JDLElBQUl4TixhQUFhcUgsS0FBSzBHLGFBQWEsR0FBRzFHLEtBQUswRyxhQUFhLENBQUMvTixVQUFVLEdBQUc7UUFDdEUsSUFBSTBPLFNBQVNySCxLQUFLMEcsYUFBYSxHQUFHMUcsS0FBSzBHLGFBQWEsQ0FBQ1csTUFBTSxHQUFHO1FBQzlETixjQUFjSixlQUFlL0ssS0FBSyxDQUFDcUwsQ0FBQUEsSUFBS0EsRUFBRTlQLEtBQUssQ0FBQ2lRLE1BQU0sSUFBSUgsRUFBRTlQLEtBQUssQ0FBQ2lRLE1BQU0sQ0FBQ0UsT0FBTyxLQUFLLFFBQVMzTyxDQUFBQSxjQUFjQSxVQUFVLENBQUNzTyxFQUFFOVAsS0FBSyxDQUFDTyxFQUFFLENBQUMsS0FBS3ZHLGFBQWFrVyxVQUFVQSxNQUFNLENBQUNKLEVBQUU5UCxLQUFLLENBQUNPLEVBQUUsQ0FBQyxLQUFLdkcsU0FBUTtJQUMvTCxPQUFPO1FBQ0wsd0VBQXdFO1FBQ3hFLG1EQUFtRDtRQUNuRDRWLGNBQWMvRyxLQUFLMEcsYUFBYSxJQUFJO0lBQ3RDO0lBQ0EsSUFBSWE7SUFDSixJQUFJclcsUUFBUTtRQUNWc1csZUFBZXhILEtBQUt6TixPQUFPLENBQUNsQixNQUFNO1FBQ2xDUyxVQUFVa08sS0FBS3pOLE9BQU8sQ0FBQ1QsUUFBUTtRQUMvQndHLFNBQVNxTztRQUNUSTtRQUNBVSxZQUFZaEQ7UUFDWiwwREFBMEQ7UUFDMURpRCx1QkFBdUIxSCxLQUFLMEcsYUFBYSxJQUFJLE9BQU8sUUFBUTtRQUM1RGlCLG9CQUFvQjtRQUNwQkMsY0FBYztRQUNkalAsWUFBWXFILEtBQUswRyxhQUFhLElBQUkxRyxLQUFLMEcsYUFBYSxDQUFDL04sVUFBVSxJQUFJLENBQUM7UUFDcEVrUCxZQUFZN0gsS0FBSzBHLGFBQWEsSUFBSTFHLEtBQUswRyxhQUFhLENBQUNtQixVQUFVLElBQUk7UUFDbkVSLFFBQVFySCxLQUFLMEcsYUFBYSxJQUFJMUcsS0FBSzBHLGFBQWEsQ0FBQ1csTUFBTSxJQUFJVDtRQUMzRGtCLFVBQVUsSUFBSUM7UUFDZEMsVUFBVSxJQUFJRDtJQUNoQjtJQUNBLDBEQUEwRDtJQUMxRCx5RUFBeUU7SUFDekUsSUFBSUUsZ0JBQWdCM1gsT0FBT2dCLEdBQUc7SUFDOUIsMEVBQTBFO0lBQzFFLGVBQWU7SUFDZixJQUFJNFcsNEJBQTRCO0lBQ2hDLDRDQUE0QztJQUM1QyxJQUFJQztJQUNKLHFFQUFxRTtJQUNyRSxJQUFJQywrQkFBK0I7SUFDbkMsNkRBQTZEO0lBQzdELElBQUlDLHlCQUF5QixJQUFJTjtJQUNqQyx3RUFBd0U7SUFDeEUsSUFBSU8sOEJBQThCO0lBQ2xDLG1FQUFtRTtJQUNuRSx5Q0FBeUM7SUFDekMsSUFBSUMsOEJBQThCO0lBQ2xDLCtEQUErRDtJQUMvRCw0Q0FBNEM7SUFDNUMsc0JBQXNCO0lBQ3RCLHdDQUF3QztJQUN4QyxJQUFJQyx5QkFBeUI7SUFDN0IsMEVBQTBFO0lBQzFFLCtDQUErQztJQUMvQyxJQUFJQywwQkFBMEIsRUFBRTtJQUNoQyw2RUFBNkU7SUFDN0UsNkNBQTZDO0lBQzdDLElBQUlDLHdCQUF3QixFQUFFO0lBQzlCLDhDQUE4QztJQUM5QyxJQUFJQyxtQkFBbUIsSUFBSVo7SUFDM0IsdURBQXVEO0lBQ3ZELElBQUlhLHFCQUFxQjtJQUN6Qiw0RUFBNEU7SUFDNUUsNkVBQTZFO0lBQzdFLGFBQWE7SUFDYixJQUFJQywwQkFBMEIsQ0FBQztJQUMvQixvRUFBb0U7SUFDcEUsSUFBSUMsaUJBQWlCLElBQUlmO0lBQ3pCLCtDQUErQztJQUMvQyxJQUFJZ0IsbUJBQW1CLElBQUk5UjtJQUMzQiw2REFBNkQ7SUFDN0QsSUFBSStSLG1CQUFtQixJQUFJakI7SUFDM0Isc0VBQXNFO0lBQ3RFLElBQUlrQixpQkFBaUIsSUFBSWxCO0lBQ3pCLHNFQUFzRTtJQUN0RSwwREFBMEQ7SUFDMUQsSUFBSW1CLGtCQUFrQixJQUFJalM7SUFDMUIsaUVBQWlFO0lBQ2pFLDBFQUEwRTtJQUMxRSx3RUFBd0U7SUFDeEUsaURBQWlEO0lBQ2pELElBQUlrUyxrQkFBa0IsSUFBSXBCO0lBQzFCLDBFQUEwRTtJQUMxRSxrREFBa0Q7SUFDbEQsSUFBSXFCLG1CQUFtQixJQUFJckI7SUFDM0IsNkVBQTZFO0lBQzdFLDhFQUE4RTtJQUM5RSxJQUFJc0IsMEJBQTBCO0lBQzlCLDBFQUEwRTtJQUMxRSwyQ0FBMkM7SUFDM0Msa0RBQWtEO0lBQ2xELFNBQVNDO1FBQ1Asb0ZBQW9GO1FBQ3BGLG1FQUFtRTtRQUNuRWpELGtCQUFrQnJHLEtBQUt6TixPQUFPLENBQUNpQixNQUFNLENBQUNzQyxDQUFBQTtZQUNwQyxJQUFJLEVBQ0Z6RSxRQUFRbVcsYUFBYSxFQUNyQjFWLFFBQVEsRUFDUnFCLEtBQUssRUFDTixHQUFHMkM7WUFDSiwrREFBK0Q7WUFDL0QseUJBQXlCO1lBQ3pCLElBQUl1VCx5QkFBeUI7Z0JBQzNCQSwwQkFBMEI7Z0JBQzFCO1lBQ0Y7WUFDQXBYLFFBQVFtWCxpQkFBaUJ6RyxJQUFJLEtBQUssS0FBS3hQLFNBQVMsTUFBTSx1RUFBdUUsMkVBQTJFLDBFQUEwRSw0RUFBNEUsb0VBQW9FO1lBQ2xhLElBQUlvVyxhQUFhQyxzQkFBc0I7Z0JBQ3JDQyxpQkFBaUJ2WSxNQUFNWSxRQUFRO2dCQUMvQm1CLGNBQWNuQjtnQkFDZDBWO1lBQ0Y7WUFDQSxJQUFJK0IsY0FBY3BXLFNBQVMsTUFBTTtnQkFDL0IseUVBQXlFO2dCQUN6RWtXLDBCQUEwQjtnQkFDMUJySixLQUFLek4sT0FBTyxDQUFDZSxFQUFFLENBQUNILFFBQVEsQ0FBQztnQkFDekIsdUNBQXVDO2dCQUN2Q3VXLGNBQWNILFlBQVk7b0JBQ3hCclksT0FBTztvQkFDUFk7b0JBQ0FtVDt3QkFDRXlFLGNBQWNILFlBQVk7NEJBQ3hCclksT0FBTzs0QkFDUCtULFNBQVM5VDs0QkFDVCtULE9BQU8vVDs0QkFDUFc7d0JBQ0Y7d0JBQ0EsZ0RBQWdEO3dCQUNoRGtPLEtBQUt6TixPQUFPLENBQUNlLEVBQUUsQ0FBQ0g7b0JBQ2xCO29CQUNBK1I7d0JBQ0UsSUFBSThDLFdBQVcsSUFBSUQsSUFBSTdXLE1BQU04VyxRQUFRO3dCQUNyQ0EsU0FBUzFILEdBQUcsQ0FBQ2lKLFlBQVl2RTt3QkFDekIyRSxZQUFZOzRCQUNWM0I7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0E7WUFDRjtZQUNBLE9BQU80QixnQkFBZ0JwQyxlQUFlMVY7UUFDeEM7UUFDQSxJQUFJNFQsV0FBVztZQUNiLGlFQUFpRTtZQUNqRSxvREFBb0Q7WUFDcERtRSwwQkFBMEJwRSxjQUFjNEM7WUFDeEMsSUFBSXlCLDBCQUEwQixJQUFNQywwQkFBMEJ0RSxjQUFjNEM7WUFDNUU1QyxhQUFhNU8sZ0JBQWdCLENBQUMsWUFBWWlUO1lBQzFDeEIsOEJBQThCLElBQU03QyxhQUFhM08sbUJBQW1CLENBQUMsWUFBWWdUO1FBQ25GO1FBQ0EsNEVBQTRFO1FBQzVFLDJFQUEyRTtRQUMzRSw4RUFBOEU7UUFDOUUsNkVBQTZFO1FBQzdFLG9CQUFvQjtRQUNwQixJQUFJLENBQUM1WSxNQUFNNlYsV0FBVyxFQUFFO1lBQ3RCNkMsZ0JBQWdCdFosT0FBT2dCLEdBQUcsRUFBRUosTUFBTVksUUFBUSxFQUFFO2dCQUMxQ2tZLGtCQUFrQjtZQUNwQjtRQUNGO1FBQ0EsT0FBT3pDO0lBQ1Q7SUFDQSwwQ0FBMEM7SUFDMUMsU0FBUzBDO1FBQ1AsSUFBSTVELGlCQUFpQjtZQUNuQkE7UUFDRjtRQUNBLElBQUlpQyw2QkFBNkI7WUFDL0JBO1FBQ0Y7UUFDQXJHLFlBQVlpSSxLQUFLO1FBQ2pCL0IsK0JBQStCQSw0QkFBNEI5RixLQUFLO1FBQ2hFblIsTUFBTTRXLFFBQVEsQ0FBQ3BPLE9BQU8sQ0FBQyxDQUFDZ0UsR0FBR3pOLE1BQVFrYSxjQUFjbGE7UUFDakRpQixNQUFNOFcsUUFBUSxDQUFDdE8sT0FBTyxDQUFDLENBQUNnRSxHQUFHek4sTUFBUW1hLGNBQWNuYTtJQUNuRDtJQUNBLDRDQUE0QztJQUM1QyxTQUFTa1MsVUFBVTFPLEVBQUU7UUFDbkJ3TyxZQUFZbkIsR0FBRyxDQUFDck47UUFDaEIsT0FBTyxJQUFNd08sWUFBWUwsTUFBTSxDQUFDbk87SUFDbEM7SUFDQSxnRUFBZ0U7SUFDaEUsU0FBU2tXLFlBQVlVLFFBQVEsRUFBRUMsSUFBSTtRQUNqQyxJQUFJQSxTQUFTLEtBQUssR0FBRztZQUNuQkEsT0FBTyxDQUFDO1FBQ1Y7UUFDQXBaLFFBQVExQixTQUFTLENBQUMsR0FBRzBCLE9BQU9tWjtRQUM1Qix3RUFBd0U7UUFDeEUsaUJBQWlCO1FBQ2pCLElBQUlFLG9CQUFvQixFQUFFO1FBQzFCLElBQUlDLHNCQUFzQixFQUFFO1FBQzVCLElBQUl4RSxPQUFPQyxpQkFBaUIsRUFBRTtZQUM1Qi9VLE1BQU00VyxRQUFRLENBQUNwTyxPQUFPLENBQUMsQ0FBQytRLFNBQVN4YTtnQkFDL0IsSUFBSXdhLFFBQVF2WixLQUFLLEtBQUssUUFBUTtvQkFDNUIsSUFBSWdZLGdCQUFnQjdJLEdBQUcsQ0FBQ3BRLE1BQU07d0JBQzVCLG1EQUFtRDt3QkFDbkR1YSxvQkFBb0J6WCxJQUFJLENBQUM5QztvQkFDM0IsT0FBTzt3QkFDTCxvRUFBb0U7d0JBQ3BFLHlCQUF5Qjt3QkFDekJzYSxrQkFBa0J4WCxJQUFJLENBQUM5QztvQkFDekI7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsdUVBQXVFO1FBQ3ZFLDRFQUE0RTtRQUM1RSw0RUFBNEU7UUFDNUU7ZUFBSWdTO1NBQVksQ0FBQ3ZJLE9BQU8sQ0FBQ3dJLENBQUFBLGFBQWNBLFdBQVdoUixPQUFPO2dCQUN2RGdZLGlCQUFpQnNCO2dCQUNqQkUsNkJBQTZCSixLQUFLSyxrQkFBa0I7Z0JBQ3BEQyxvQkFBb0JOLEtBQUtPLFNBQVMsS0FBSztZQUN6QztRQUNBLCtFQUErRTtRQUMvRSxJQUFJN0UsT0FBT0MsaUJBQWlCLEVBQUU7WUFDNUJzRSxrQkFBa0I3USxPQUFPLENBQUN6SixDQUFBQSxNQUFPaUIsTUFBTTRXLFFBQVEsQ0FBQ2xHLE1BQU0sQ0FBQzNSO1lBQ3ZEdWEsb0JBQW9COVEsT0FBTyxDQUFDekosQ0FBQUEsTUFBT2thLGNBQWNsYTtRQUNuRDtJQUNGO0lBQ0EsbUZBQW1GO0lBQ25GLHVFQUF1RTtJQUN2RSxpQ0FBaUM7SUFDakMscURBQXFEO0lBQ3JELHlDQUF5QztJQUN6QyxTQUFTNmEsbUJBQW1CaFosUUFBUSxFQUFFdVksUUFBUSxFQUFFVSxLQUFLO1FBQ25ELElBQUlDLGlCQUFpQkM7UUFDckIsSUFBSSxFQUNGSixTQUFTLEVBQ1YsR0FBR0UsVUFBVSxLQUFLLElBQUksQ0FBQyxJQUFJQTtRQUM1QixtREFBbUQ7UUFDbkQsOENBQThDO1FBQzlDLHFEQUFxRDtRQUNyRCwrREFBK0Q7UUFDL0QsOERBQThEO1FBQzlELElBQUlHLGlCQUFpQmhhLE1BQU0yVyxVQUFVLElBQUksUUFBUTNXLE1BQU11VyxVQUFVLENBQUMvQyxVQUFVLElBQUksUUFBUXlHLGlCQUFpQmphLE1BQU11VyxVQUFVLENBQUMvQyxVQUFVLEtBQUt4VCxNQUFNdVcsVUFBVSxDQUFDdlcsS0FBSyxLQUFLLGFBQWEsQ0FBQyxDQUFDOFosa0JBQWtCbFosU0FBU1osS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJOFosZ0JBQWdCSSxXQUFXLE1BQU07UUFDelEsSUFBSXZEO1FBQ0osSUFBSXdDLFNBQVN4QyxVQUFVLEVBQUU7WUFDdkIsSUFBSXBZLE9BQU80YixJQUFJLENBQUNoQixTQUFTeEMsVUFBVSxFQUFFOVgsTUFBTSxHQUFHLEdBQUc7Z0JBQy9DOFgsYUFBYXdDLFNBQVN4QyxVQUFVO1lBQ2xDLE9BQU87Z0JBQ0wsb0VBQW9FO2dCQUNwRUEsYUFBYTtZQUNmO1FBQ0YsT0FBTyxJQUFJcUQsZ0JBQWdCO1lBQ3pCLCtEQUErRDtZQUMvRHJELGFBQWEzVyxNQUFNMlcsVUFBVTtRQUMvQixPQUFPO1lBQ0wsc0RBQXNEO1lBQ3REQSxhQUFhO1FBQ2Y7UUFDQSw4REFBOEQ7UUFDOUQsSUFBSWxQLGFBQWEwUixTQUFTMVIsVUFBVSxHQUFHMlMsZ0JBQWdCcGEsTUFBTXlILFVBQVUsRUFBRTBSLFNBQVMxUixVQUFVLEVBQUUwUixTQUFTL1IsT0FBTyxJQUFJLEVBQUUsRUFBRStSLFNBQVNoRCxNQUFNLElBQUluVyxNQUFNeUgsVUFBVTtRQUN6Six1RUFBdUU7UUFDdkUsd0JBQXdCO1FBQ3hCLElBQUlxUCxXQUFXOVcsTUFBTThXLFFBQVE7UUFDN0IsSUFBSUEsU0FBU3JGLElBQUksR0FBRyxHQUFHO1lBQ3JCcUYsV0FBVyxJQUFJRCxJQUFJQztZQUNuQkEsU0FBU3RPLE9BQU8sQ0FBQyxDQUFDZ0UsR0FBRzZFLElBQU15RixTQUFTMUgsR0FBRyxDQUFDaUMsR0FBR3lDO1FBQzdDO1FBQ0EsbUVBQW1FO1FBQ25FLDhDQUE4QztRQUM5QyxJQUFJMkMscUJBQXFCTyw4QkFBOEIsUUFBUWhYLE1BQU11VyxVQUFVLENBQUMvQyxVQUFVLElBQUksUUFBUXlHLGlCQUFpQmphLE1BQU11VyxVQUFVLENBQUMvQyxVQUFVLEtBQUssQ0FBQyxDQUFDdUcsbUJBQW1CblosU0FBU1osS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJK1osaUJBQWlCRyxXQUFXLE1BQU07UUFDalAsSUFBSXJGLG9CQUFvQjtZQUN0QkQsYUFBYUM7WUFDYkEscUJBQXFCNVU7UUFDdkI7UUFDQSxJQUFJb1g7YUFBb0MsSUFBSU4sa0JBQWtCM1gsT0FBT2dCLEdBQUc7YUFBUyxJQUFJMlcsa0JBQWtCM1gsT0FBTzBDLElBQUksRUFBRTtZQUNsSGdOLEtBQUt6TixPQUFPLENBQUNRLElBQUksQ0FBQ2pCLFVBQVVBLFNBQVNaLEtBQUs7UUFDNUMsT0FBTyxJQUFJK1csa0JBQWtCM1gsT0FBTytDLE9BQU8sRUFBRTtZQUMzQzJNLEtBQUt6TixPQUFPLENBQUNhLE9BQU8sQ0FBQ3RCLFVBQVVBLFNBQVNaLEtBQUs7UUFDL0M7UUFDQSxJQUFJeVo7UUFDSiw2RUFBNkU7UUFDN0UsSUFBSTFDLGtCQUFrQjNYLE9BQU9nQixHQUFHLEVBQUU7WUFDaEMsdUVBQXVFO1lBQ3ZFLElBQUlpYSxhQUFhbEQsdUJBQXVCL0csR0FBRyxDQUFDcFEsTUFBTVksUUFBUSxDQUFDRSxRQUFRO1lBQ25FLElBQUl1WixjQUFjQSxXQUFXbEwsR0FBRyxDQUFDdk8sU0FBU0UsUUFBUSxHQUFHO2dCQUNuRDJZLHFCQUFxQjtvQkFDbkJsQixpQkFBaUJ2WSxNQUFNWSxRQUFRO29CQUMvQm1CLGNBQWNuQjtnQkFDaEI7WUFDRixPQUFPLElBQUl1Vyx1QkFBdUJoSSxHQUFHLENBQUN2TyxTQUFTRSxRQUFRLEdBQUc7Z0JBQ3hELHdFQUF3RTtnQkFDeEUsa0VBQWtFO2dCQUNsRTJZLHFCQUFxQjtvQkFDbkJsQixpQkFBaUIzWDtvQkFDakJtQixjQUFjL0IsTUFBTVksUUFBUTtnQkFDOUI7WUFDRjtRQUNGLE9BQU8sSUFBSXNXLDhCQUE4QjtZQUN2QywrQ0FBK0M7WUFDL0MsSUFBSW9ELFVBQVVuRCx1QkFBdUIvRyxHQUFHLENBQUNwUSxNQUFNWSxRQUFRLENBQUNFLFFBQVE7WUFDaEUsSUFBSXdaLFNBQVM7Z0JBQ1hBLFFBQVExSyxHQUFHLENBQUNoUCxTQUFTRSxRQUFRO1lBQy9CLE9BQU87Z0JBQ0x3WixVQUFVLElBQUl2VSxJQUFJO29CQUFDbkYsU0FBU0UsUUFBUTtpQkFBQztnQkFDckNxVyx1QkFBdUIvSCxHQUFHLENBQUNwUCxNQUFNWSxRQUFRLENBQUNFLFFBQVEsRUFBRXdaO1lBQ3REO1lBQ0FiLHFCQUFxQjtnQkFDbkJsQixpQkFBaUJ2WSxNQUFNWSxRQUFRO2dCQUMvQm1CLGNBQWNuQjtZQUNoQjtRQUNGO1FBQ0E2WCxZQUFZbmEsU0FBUyxDQUFDLEdBQUc2YSxVQUFVO1lBQ2pDeEM7WUFDQWxQO1lBQ0E2TyxlQUFlUztZQUNmblc7WUFDQWlWLGFBQWE7WUFDYlUsWUFBWWhEO1lBQ1ptRCxjQUFjO1lBQ2RGLHVCQUF1QitELHVCQUF1QjNaLFVBQVV1WSxTQUFTL1IsT0FBTyxJQUFJcEgsTUFBTW9ILE9BQU87WUFDekZxUDtZQUNBSztRQUNGLElBQUk7WUFDRjJDO1lBQ0FFLFdBQVdBLGNBQWM7UUFDM0I7UUFDQSxpQ0FBaUM7UUFDakM1QyxnQkFBZ0IzWCxPQUFPZ0IsR0FBRztRQUMxQjRXLDRCQUE0QjtRQUM1QkUsK0JBQStCO1FBQy9CRyw4QkFBOEI7UUFDOUJDLHlCQUF5QjtRQUN6QkMsMEJBQTBCLEVBQUU7UUFDNUJDLHdCQUF3QixFQUFFO0lBQzVCO0lBQ0EsNEVBQTRFO0lBQzVFLHNDQUFzQztJQUN0QyxlQUFlZ0QsU0FBUzdaLEVBQUUsRUFBRXlZLElBQUk7UUFDOUIsSUFBSSxPQUFPelksT0FBTyxVQUFVO1lBQzFCbU8sS0FBS3pOLE9BQU8sQ0FBQ2UsRUFBRSxDQUFDekI7WUFDaEI7UUFDRjtRQUNBLElBQUk4WixpQkFBaUJDLFlBQVkxYSxNQUFNWSxRQUFRLEVBQUVaLE1BQU1vSCxPQUFPLEVBQUVMLFVBQVUrTixPQUFPSSxrQkFBa0IsRUFBRXZVLElBQUltVSxPQUFPakgsb0JBQW9CLEVBQUV1TCxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLdUIsV0FBVyxFQUFFdkIsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS3dCLFFBQVE7UUFDck4sSUFBSSxFQUNGblosSUFBSSxFQUNKb1osVUFBVSxFQUNWdFYsS0FBSyxFQUNOLEdBQUd1Vix5QkFBeUJoRyxPQUFPRSxzQkFBc0IsRUFBRSxPQUFPeUYsZ0JBQWdCckI7UUFDbkYsSUFBSWIsa0JBQWtCdlksTUFBTVksUUFBUTtRQUNwQyxJQUFJbUIsZUFBZWxCLGVBQWViLE1BQU1ZLFFBQVEsRUFBRWEsTUFBTTJYLFFBQVFBLEtBQUtwWixLQUFLO1FBQzFFLDZFQUE2RTtRQUM3RSx5RUFBeUU7UUFDekUsMEVBQTBFO1FBQzFFLDJFQUEyRTtRQUMzRSxrQ0FBa0M7UUFDbEMrQixlQUFlekQsU0FBUyxDQUFDLEdBQUd5RCxjQUFjK00sS0FBS3pOLE9BQU8sQ0FBQ0csY0FBYyxDQUFDTztRQUN0RSxJQUFJZ1osY0FBYzNCLFFBQVFBLEtBQUtsWCxPQUFPLElBQUksT0FBT2tYLEtBQUtsWCxPQUFPLEdBQUdqQztRQUNoRSxJQUFJcVcsZ0JBQWdCbFgsT0FBTzBDLElBQUk7UUFDL0IsSUFBSWlaLGdCQUFnQixNQUFNO1lBQ3hCekUsZ0JBQWdCbFgsT0FBTytDLE9BQU87UUFDaEMsT0FBTyxJQUFJNFksZ0JBQWdCO2FBQWMsSUFBSUYsY0FBYyxRQUFRWixpQkFBaUJZLFdBQVdySCxVQUFVLEtBQUtxSCxXQUFXcEgsVUFBVSxLQUFLelQsTUFBTVksUUFBUSxDQUFDRSxRQUFRLEdBQUdkLE1BQU1ZLFFBQVEsQ0FBQ2UsTUFBTSxFQUFFO1lBQ3ZMLHVFQUF1RTtZQUN2RSx1RUFBdUU7WUFDdkUsb0VBQW9FO1lBQ3BFLHFFQUFxRTtZQUNyRTJVLGdCQUFnQmxYLE9BQU8rQyxPQUFPO1FBQ2hDO1FBQ0EsSUFBSXNVLHFCQUFxQjJDLFFBQVEsd0JBQXdCQSxPQUFPQSxLQUFLM0Msa0JBQWtCLEtBQUssT0FBT3hXO1FBQ25HLElBQUkwWixZQUFZLENBQUNQLFFBQVFBLEtBQUtNLGtCQUFrQixNQUFNO1FBQ3RELElBQUlyQixhQUFhQyxzQkFBc0I7WUFDckNDO1lBQ0F4VztZQUNBdVU7UUFDRjtRQUNBLElBQUkrQixZQUFZO1lBQ2QsdUNBQXVDO1lBQ3ZDRyxjQUFjSCxZQUFZO2dCQUN4QnJZLE9BQU87Z0JBQ1BZLFVBQVVtQjtnQkFDVmdTO29CQUNFeUUsY0FBY0gsWUFBWTt3QkFDeEJyWSxPQUFPO3dCQUNQK1QsU0FBUzlUO3dCQUNUK1QsT0FBTy9UO3dCQUNQVyxVQUFVbUI7b0JBQ1o7b0JBQ0EsbUNBQW1DO29CQUNuQ3lZLFNBQVM3WixJQUFJeVk7Z0JBQ2Y7Z0JBQ0FwRjtvQkFDRSxJQUFJOEMsV0FBVyxJQUFJRCxJQUFJN1csTUFBTThXLFFBQVE7b0JBQ3JDQSxTQUFTMUgsR0FBRyxDQUFDaUosWUFBWXZFO29CQUN6QjJFLFlBQVk7d0JBQ1YzQjtvQkFDRjtnQkFDRjtZQUNGO1lBQ0E7UUFDRjtRQUNBLE9BQU8sTUFBTTRCLGdCQUFnQnBDLGVBQWV2VSxjQUFjO1lBQ3hEOFk7WUFDQSx5RUFBeUU7WUFDekUsMkRBQTJEO1lBQzNERyxjQUFjelY7WUFDZGtSO1lBQ0F2VSxTQUFTa1gsUUFBUUEsS0FBS2xYLE9BQU87WUFDN0IrWSxzQkFBc0I3QixRQUFRQSxLQUFLOEIsdUJBQXVCO1lBQzFEdkI7UUFDRjtJQUNGO0lBQ0EsNkVBQTZFO0lBQzdFLHlFQUF5RTtJQUN6RSx1Q0FBdUM7SUFDdkMsU0FBU3dCO1FBQ1BDO1FBQ0EzQyxZQUFZO1lBQ1YvQixjQUFjO1FBQ2hCO1FBQ0Esd0VBQXdFO1FBQ3hFLDZFQUE2RTtRQUM3RSxJQUFJMVcsTUFBTXVXLFVBQVUsQ0FBQ3ZXLEtBQUssS0FBSyxjQUFjO1lBQzNDO1FBQ0Y7UUFDQSw4RUFBOEU7UUFDOUUsNEVBQTRFO1FBQzVFLCtCQUErQjtRQUMvQixJQUFJQSxNQUFNdVcsVUFBVSxDQUFDdlcsS0FBSyxLQUFLLFFBQVE7WUFDckMwWSxnQkFBZ0IxWSxNQUFNc1csYUFBYSxFQUFFdFcsTUFBTVksUUFBUSxFQUFFO2dCQUNuRHlhLGdDQUFnQztZQUNsQztZQUNBO1FBQ0Y7UUFDQSxxRUFBcUU7UUFDckUsNEVBQTRFO1FBQzVFLCtFQUErRTtRQUMvRTNDLGdCQUFnQjNCLGlCQUFpQi9XLE1BQU1zVyxhQUFhLEVBQUV0VyxNQUFNdVcsVUFBVSxDQUFDM1YsUUFBUSxFQUFFO1lBQy9FMGEsb0JBQW9CdGIsTUFBTXVXLFVBQVU7UUFDdEM7SUFDRjtJQUNBLDZFQUE2RTtJQUM3RSxrRkFBa0Y7SUFDbEYsYUFBYTtJQUNiLGVBQWVtQyxnQkFBZ0JwQyxhQUFhLEVBQUUxVixRQUFRLEVBQUV3WSxJQUFJO1FBQzFELDJFQUEyRTtRQUMzRSx3RUFBd0U7UUFDeEUsNENBQTRDO1FBQzVDbkMsK0JBQStCQSw0QkFBNEI5RixLQUFLO1FBQ2hFOEYsOEJBQThCO1FBQzlCRixnQkFBZ0JUO1FBQ2hCZSw4QkFBOEIsQ0FBQytCLFFBQVFBLEtBQUtpQyw4QkFBOEIsTUFBTTtRQUNoRix5RUFBeUU7UUFDekUseURBQXlEO1FBQ3pERSxtQkFBbUJ2YixNQUFNWSxRQUFRLEVBQUVaLE1BQU1vSCxPQUFPO1FBQ2hENFAsNEJBQTRCLENBQUNvQyxRQUFRQSxLQUFLM0Msa0JBQWtCLE1BQU07UUFDbEVTLCtCQUErQixDQUFDa0MsUUFBUUEsS0FBSzZCLG9CQUFvQixNQUFNO1FBQ3ZFLElBQUlPLGNBQWMzRyxzQkFBc0JEO1FBQ3hDLElBQUk2RyxvQkFBb0JyQyxRQUFRQSxLQUFLa0Msa0JBQWtCO1FBQ3ZELElBQUlsVSxVQUFVUCxZQUFZMlUsYUFBYTVhLFVBQVVtRztRQUNqRCxJQUFJNFMsWUFBWSxDQUFDUCxRQUFRQSxLQUFLTyxTQUFTLE1BQU07UUFDN0MsMEVBQTBFO1FBQzFFLElBQUksQ0FBQ3ZTLFNBQVM7WUFDWixJQUFJN0IsUUFBUW9RLHVCQUF1QixLQUFLO2dCQUN0QzdVLFVBQVVGLFNBQVNFLFFBQVE7WUFDN0I7WUFDQSxJQUFJLEVBQ0ZzRyxTQUFTc1UsZUFBZSxFQUN4QnpWLEtBQUssRUFDTixHQUFHMlAsdUJBQXVCNEY7WUFDM0IscUVBQXFFO1lBQ3JFRztZQUNBL0IsbUJBQW1CaFosVUFBVTtnQkFDM0J3RyxTQUFTc1U7Z0JBQ1RqVSxZQUFZLENBQUM7Z0JBQ2IwTyxRQUFRO29CQUNOLENBQUNsUSxNQUFNTyxFQUFFLENBQUMsRUFBRWpCO2dCQUNkO1lBQ0YsR0FBRztnQkFDRG9VO1lBQ0Y7WUFDQTtRQUNGO1FBQ0EscUVBQXFFO1FBQ3JFLHVCQUF1QjtRQUN2QixFQUFFO1FBQ0YsMEVBQTBFO1FBQzFFLGdGQUFnRjtRQUNoRiw4Q0FBOEM7UUFDOUMsSUFBSTNaLE1BQU02VixXQUFXLElBQUksQ0FBQ3lCLDBCQUEwQnNFLGlCQUFpQjViLE1BQU1ZLFFBQVEsRUFBRUEsYUFBYSxDQUFFd1ksQ0FBQUEsUUFBUUEsS0FBS3lCLFVBQVUsSUFBSVosaUJBQWlCYixLQUFLeUIsVUFBVSxDQUFDckgsVUFBVSxJQUFJO1lBQzVLb0csbUJBQW1CaFosVUFBVTtnQkFDM0J3RztZQUNGLEdBQUc7Z0JBQ0R1UztZQUNGO1lBQ0E7UUFDRjtRQUNBLGtEQUFrRDtRQUNsRDFDLDhCQUE4QixJQUFJOUU7UUFDbEMsSUFBSTBKLFVBQVVDLHdCQUF3QmhOLEtBQUt6TixPQUFPLEVBQUVULFVBQVVxVyw0QkFBNEIzRyxNQUFNLEVBQUU4SSxRQUFRQSxLQUFLeUIsVUFBVTtRQUN6SCxJQUFJa0I7UUFDSixJQUFJZjtRQUNKLElBQUk1QixRQUFRQSxLQUFLNEIsWUFBWSxFQUFFO1lBQzdCLDBFQUEwRTtZQUMxRSx1RUFBdUU7WUFDdkUseUVBQXlFO1lBQ3pFLCtDQUErQztZQUMvQ0EsZUFBZTtnQkFDYixDQUFDZ0Isb0JBQW9CNVUsU0FBU25CLEtBQUssQ0FBQ08sRUFBRSxDQUFDLEVBQUU0UyxLQUFLNEIsWUFBWTtZQUM1RDtRQUNGLE9BQU8sSUFBSTVCLFFBQVFBLEtBQUt5QixVQUFVLElBQUlaLGlCQUFpQmIsS0FBS3lCLFVBQVUsQ0FBQ3JILFVBQVUsR0FBRztZQUNsRixrREFBa0Q7WUFDbEQsSUFBSXlJLGVBQWUsTUFBTUMsYUFBYUwsU0FBU2piLFVBQVV3WSxLQUFLeUIsVUFBVSxFQUFFelQsU0FBUztnQkFDakZsRixTQUFTa1gsS0FBS2xYLE9BQU87Z0JBQ3JCeVg7WUFDRjtZQUNBLElBQUlzQyxhQUFhRSxjQUFjLEVBQUU7Z0JBQy9CO1lBQ0Y7WUFDQUosb0JBQW9CRSxhQUFhRixpQkFBaUI7WUFDbERmLGVBQWVpQixhQUFhRyxrQkFBa0I7WUFDOUNYLG9CQUFvQlkscUJBQXFCemIsVUFBVXdZLEtBQUt5QixVQUFVO1lBQ2xFbEIsWUFBWTtZQUNaLHVDQUF1QztZQUN2Q2tDLFVBQVUsSUFBSVMsUUFBUVQsUUFBUXBZLEdBQUcsRUFBRTtnQkFDakM2TSxRQUFRdUwsUUFBUXZMLE1BQU07WUFDeEI7UUFDRjtRQUNBLGVBQWU7UUFDZixJQUFJLEVBQ0Y2TCxjQUFjLEVBQ2QxVSxVQUFVLEVBQ1YwTyxNQUFNLEVBQ1AsR0FBRyxNQUFNb0csY0FBY1YsU0FBU2piLFVBQVV3RyxTQUFTcVUsbUJBQW1CckMsUUFBUUEsS0FBS3lCLFVBQVUsRUFBRXpCLFFBQVFBLEtBQUtvRCxpQkFBaUIsRUFBRXBELFFBQVFBLEtBQUtsWCxPQUFPLEVBQUVrWCxRQUFRQSxLQUFLTixnQkFBZ0IsS0FBSyxNQUFNYSxXQUFXb0MsbUJBQW1CZjtRQUM1TixJQUFJbUIsZ0JBQWdCO1lBQ2xCO1FBQ0Y7UUFDQSwwRUFBMEU7UUFDMUUsMkVBQTJFO1FBQzNFLDREQUE0RDtRQUM1RGxGLDhCQUE4QjtRQUM5QjJDLG1CQUFtQmhaLFVBQVV0QyxTQUFTO1lBQ3BDOEk7UUFDRixHQUFHMlUsb0JBQW9CO1lBQ3JCcEYsWUFBWW9GO1FBQ2QsSUFBSSxDQUFDLEdBQUc7WUFDTnRVO1lBQ0EwTztRQUNGO0lBQ0Y7SUFDQSwyRUFBMkU7SUFDM0UsbUJBQW1CO0lBQ25CLGVBQWUrRixhQUFhTCxPQUFPLEVBQUVqYixRQUFRLEVBQUVpYSxVQUFVLEVBQUV6VCxPQUFPLEVBQUVnUyxJQUFJO1FBQ3RFLElBQUlBLFNBQVMsS0FBSyxHQUFHO1lBQ25CQSxPQUFPLENBQUM7UUFDVjtRQUNBZ0M7UUFDQSwrQkFBK0I7UUFDL0IsSUFBSTdFLGFBQWFrRyx3QkFBd0I3YixVQUFVaWE7UUFDbkRwQyxZQUFZO1lBQ1ZsQztRQUNGLEdBQUc7WUFDRG9ELFdBQVdQLEtBQUtPLFNBQVMsS0FBSztRQUNoQztRQUNBLHFDQUFxQztRQUNyQyxJQUFJdFE7UUFDSixJQUFJcVQsY0FBY0MsZUFBZXZWLFNBQVN4RztRQUMxQyxJQUFJLENBQUM4YixZQUFZelcsS0FBSyxDQUFDOUYsTUFBTSxJQUFJLENBQUN1YyxZQUFZelcsS0FBSyxDQUFDK1AsSUFBSSxFQUFFO1lBQ3hEM00sU0FBUztnQkFDUHVULE1BQU0vVyxXQUFXTixLQUFLO2dCQUN0QkEsT0FBT29RLHVCQUF1QixLQUFLO29CQUNqQ2tILFFBQVFoQixRQUFRZ0IsTUFBTTtvQkFDdEIvYixVQUFVRixTQUFTRSxRQUFRO29CQUMzQmdjLFNBQVNKLFlBQVl6VyxLQUFLLENBQUNPLEVBQUU7Z0JBQy9CO1lBQ0Y7UUFDRixPQUFPO1lBQ0w2QyxTQUFTLE1BQU0wVCxtQkFBbUIsVUFBVWxCLFNBQVNhLGFBQWF0VixTQUFTZCxVQUFVRixvQkFBb0JXLFVBQVUrTixPQUFPakgsb0JBQW9CO1lBQzlJLElBQUlnTyxRQUFRdkwsTUFBTSxDQUFDQyxPQUFPLEVBQUU7Z0JBQzFCLE9BQU87b0JBQ0w0TCxnQkFBZ0I7Z0JBQ2xCO1lBQ0Y7UUFDRjtRQUNBLElBQUlhLGlCQUFpQjNULFNBQVM7WUFDNUIsSUFBSW5IO1lBQ0osSUFBSWtYLFFBQVFBLEtBQUtsWCxPQUFPLElBQUksTUFBTTtnQkFDaENBLFVBQVVrWCxLQUFLbFgsT0FBTztZQUN4QixPQUFPO2dCQUNMLHFFQUFxRTtnQkFDckUsdUVBQXVFO2dCQUN2RSxzQkFBc0I7Z0JBQ3RCQSxVQUFVbUgsT0FBT3pJLFFBQVEsS0FBS1osTUFBTVksUUFBUSxDQUFDRSxRQUFRLEdBQUdkLE1BQU1ZLFFBQVEsQ0FBQ2UsTUFBTTtZQUMvRTtZQUNBLE1BQU1zYix3QkFBd0JqZCxPQUFPcUosUUFBUTtnQkFDM0N3UjtnQkFDQTNZO1lBQ0Y7WUFDQSxPQUFPO2dCQUNMaWEsZ0JBQWdCO1lBQ2xCO1FBQ0Y7UUFDQSxJQUFJZSxjQUFjN1QsU0FBUztZQUN6QixxRUFBcUU7WUFDckUsNkRBQTZEO1lBQzdELElBQUk4VCxnQkFBZ0JuQixvQkFBb0I1VSxTQUFTc1YsWUFBWXpXLEtBQUssQ0FBQ08sRUFBRTtZQUNyRSxrRUFBa0U7WUFDbEUsd0VBQXdFO1lBQ3hFLHVFQUF1RTtZQUN2RSxnREFBZ0Q7WUFDaEQsSUFBSSxDQUFDNFMsUUFBUUEsS0FBS2xYLE9BQU8sTUFBTSxNQUFNO2dCQUNuQzZVLGdCQUFnQjNYLE9BQU8wQyxJQUFJO1lBQzdCO1lBQ0EsT0FBTztnQkFDTCx5RUFBeUU7Z0JBQ3pFaWEsbUJBQW1CLENBQUM7Z0JBQ3BCSyxvQkFBb0I7b0JBQ2xCLENBQUNlLGNBQWNsWCxLQUFLLENBQUNPLEVBQUUsQ0FBQyxFQUFFNkMsT0FBTzlELEtBQUs7Z0JBQ3hDO1lBQ0Y7UUFDRjtRQUNBLElBQUk2WCxpQkFBaUIvVCxTQUFTO1lBQzVCLE1BQU1zTSx1QkFBdUIsS0FBSztnQkFDaENpSCxNQUFNO1lBQ1I7UUFDRjtRQUNBLE9BQU87WUFDTGIsbUJBQW1CO2dCQUNqQixDQUFDVyxZQUFZelcsS0FBSyxDQUFDTyxFQUFFLENBQUMsRUFBRTZDLE9BQU8xQixJQUFJO1lBQ3JDO1FBQ0Y7SUFDRjtJQUNBLHlFQUF5RTtJQUN6RSxlQUFlO0lBQ2YsZUFBZTRVLGNBQWNWLE9BQU8sRUFBRWpiLFFBQVEsRUFBRXdHLE9BQU8sRUFBRWtVLGtCQUFrQixFQUFFVCxVQUFVLEVBQUUyQixpQkFBaUIsRUFBRXRhLE9BQU8sRUFBRTRXLGdCQUFnQixFQUFFYSxTQUFTLEVBQUVvQyxpQkFBaUIsRUFBRWYsWUFBWTtRQUMvSyxrRUFBa0U7UUFDbEUsSUFBSVMsb0JBQW9CSCxzQkFBc0JlLHFCQUFxQnpiLFVBQVVpYTtRQUM3RSx5RUFBeUU7UUFDekUsZ0VBQWdFO1FBQ2hFLElBQUl3QyxtQkFBbUJ4QyxjQUFjMkIscUJBQXFCYyw0QkFBNEI3QjtRQUN0RixJQUFJRCxjQUFjM0csc0JBQXNCRDtRQUN4QyxJQUFJLENBQUMySSxlQUFlQyxxQkFBcUIsR0FBR0MsaUJBQWlCM08sS0FBS3pOLE9BQU8sRUFBRXJCLE9BQU9vSCxTQUFTaVcsa0JBQWtCemMsVUFBVWtVLE9BQU9HLG1CQUFtQixJQUFJNkQscUJBQXFCLE1BQU14Qix3QkFBd0JDLHlCQUF5QkMsdUJBQXVCUSxpQkFBaUJGLGtCQUFrQkQsa0JBQWtCMkQsYUFBYXpVLFVBQVVnVixtQkFBbUJmO1FBQ3ZWLHdFQUF3RTtRQUN4RSx3RUFBd0U7UUFDeEUsbUVBQW1FO1FBQ25FVyxzQkFBc0JtQixDQUFBQSxVQUFXLENBQUUxVixDQUFBQSxXQUFXQSxRQUFRZ0QsSUFBSSxDQUFDMkwsQ0FBQUEsSUFBS0EsRUFBRTlQLEtBQUssQ0FBQ08sRUFBRSxLQUFLc1csUUFBTyxLQUFNUyxpQkFBaUJBLGNBQWNuVCxJQUFJLENBQUMyTCxDQUFBQSxJQUFLQSxFQUFFOVAsS0FBSyxDQUFDTyxFQUFFLEtBQUtzVztRQUNwSm5GLDBCQUEwQixFQUFFRDtRQUM1Qiw2Q0FBNkM7UUFDN0MsSUFBSTZGLGNBQWMxZSxNQUFNLEtBQUssS0FBSzJlLHFCQUFxQjNlLE1BQU0sS0FBSyxHQUFHO1lBQ25FLElBQUk2ZSxrQkFBa0JDO1lBQ3RCL0QsbUJBQW1CaFosVUFBVXRDLFNBQVM7Z0JBQ3BDOEk7Z0JBQ0FLLFlBQVksQ0FBQztnQkFDYixpREFBaUQ7Z0JBQ2pEME8sUUFBUTZFLGdCQUFnQjtZQUMxQixHQUFHZSxvQkFBb0I7Z0JBQ3JCcEYsWUFBWW9GO1lBQ2QsSUFBSSxDQUFDLEdBQUcyQixrQkFBa0I7Z0JBQ3hCOUcsVUFBVSxJQUFJQyxJQUFJN1csTUFBTTRXLFFBQVE7WUFDbEMsSUFBSSxDQUFDLElBQUk7Z0JBQ1ArQztZQUNGO1lBQ0EsT0FBTztnQkFDTHdDLGdCQUFnQjtZQUNsQjtRQUNGO1FBQ0EsMEVBQTBFO1FBQzFFLHdFQUF3RTtRQUN4RSx5RUFBeUU7UUFDekUsK0NBQStDO1FBQy9DLDJFQUEyRTtRQUMzRSxtREFBbUQ7UUFDbkQsSUFBSSxDQUFDOUUsK0JBQWdDLEVBQUN2QyxPQUFPRyxtQkFBbUIsSUFBSSxDQUFDNkQsZ0JBQWUsR0FBSTtZQUN0RjBFLHFCQUFxQmhWLE9BQU8sQ0FBQ29WLENBQUFBO2dCQUMzQixJQUFJckUsVUFBVXZaLE1BQU00VyxRQUFRLENBQUN4RyxHQUFHLENBQUN3TixHQUFHN2UsR0FBRztnQkFDdkMsSUFBSThlLHNCQUFzQkMsa0JBQWtCN2QsV0FBV3NaLFVBQVVBLFFBQVE1UixJQUFJLEdBQUcxSDtnQkFDaEZELE1BQU00VyxRQUFRLENBQUN4SCxHQUFHLENBQUN3TyxHQUFHN2UsR0FBRyxFQUFFOGU7WUFDN0I7WUFDQSxJQUFJbEgsYUFBYW9GLHFCQUFxQi9iLE1BQU0yVyxVQUFVO1lBQ3REOEIsWUFBWW5hLFNBQVM7Z0JBQ25CaVksWUFBWWtGO1lBQ2QsR0FBRzlFLGFBQWFwWSxPQUFPNGIsSUFBSSxDQUFDeEQsWUFBWTlYLE1BQU0sS0FBSyxJQUFJO2dCQUNyRDhYLFlBQVk7WUFDZCxJQUFJO2dCQUNGQTtZQUNGLElBQUksQ0FBQyxHQUFHNkcscUJBQXFCM2UsTUFBTSxHQUFHLElBQUk7Z0JBQ3hDK1gsVUFBVSxJQUFJQyxJQUFJN1csTUFBTTRXLFFBQVE7WUFDbEMsSUFBSSxDQUFDLElBQUk7Z0JBQ1ArQztZQUNGO1FBQ0Y7UUFDQTZELHFCQUFxQmhWLE9BQU8sQ0FBQ29WLENBQUFBO1lBQzNCLElBQUluRyxpQkFBaUJ0SSxHQUFHLENBQUN5TyxHQUFHN2UsR0FBRyxHQUFHO2dCQUNoQ2dmLGFBQWFILEdBQUc3ZSxHQUFHO1lBQ3JCO1lBQ0EsSUFBSTZlLEdBQUd2TixVQUFVLEVBQUU7Z0JBQ2pCLHlFQUF5RTtnQkFDekUsb0VBQW9FO2dCQUNwRSw2QkFBNkI7Z0JBQzdCb0gsaUJBQWlCckksR0FBRyxDQUFDd08sR0FBRzdlLEdBQUcsRUFBRTZlLEdBQUd2TixVQUFVO1lBQzVDO1FBQ0Y7UUFDQSwwREFBMEQ7UUFDMUQsSUFBSTJOLGlDQUFpQyxJQUFNUixxQkFBcUJoVixPQUFPLENBQUN5VixDQUFBQSxJQUFLRixhQUFhRSxFQUFFbGYsR0FBRztRQUMvRixJQUFJa1ksNkJBQTZCO1lBQy9CQSw0QkFBNEIzRyxNQUFNLENBQUMzSyxnQkFBZ0IsQ0FBQyxTQUFTcVk7UUFDL0Q7UUFDQSxJQUFJLEVBQ0ZFLE9BQU8sRUFDUEMsYUFBYSxFQUNiQyxjQUFjLEVBQ2YsR0FBRyxNQUFNQywrQkFBK0JyZSxNQUFNb0gsT0FBTyxFQUFFQSxTQUFTbVcsZUFBZUMsc0JBQXNCM0I7UUFDdEcsSUFBSUEsUUFBUXZMLE1BQU0sQ0FBQ0MsT0FBTyxFQUFFO1lBQzFCLE9BQU87Z0JBQ0w0TCxnQkFBZ0I7WUFDbEI7UUFDRjtRQUNBLHVFQUF1RTtRQUN2RSxpRUFBaUU7UUFDakUsd0RBQXdEO1FBQ3hELElBQUlsRiw2QkFBNkI7WUFDL0JBLDRCQUE0QjNHLE1BQU0sQ0FBQzFLLG1CQUFtQixDQUFDLFNBQVNvWTtRQUNsRTtRQUNBUixxQkFBcUJoVixPQUFPLENBQUNvVixDQUFBQSxLQUFNbkcsaUJBQWlCL0csTUFBTSxDQUFDa04sR0FBRzdlLEdBQUc7UUFDakUsOEVBQThFO1FBQzlFLElBQUkyVCxXQUFXNEwsYUFBYUo7UUFDNUIsSUFBSXhMLFVBQVU7WUFDWixJQUFJQSxTQUFTaE8sR0FBRyxJQUFJNlksY0FBYzFlLE1BQU0sRUFBRTtnQkFDeEMsK0RBQStEO2dCQUMvRCxvRUFBb0U7Z0JBQ3BFLG9CQUFvQjtnQkFDcEIsSUFBSTBmLGFBQWFmLG9CQUFvQixDQUFDOUssU0FBU2hPLEdBQUcsR0FBRzZZLGNBQWMxZSxNQUFNLENBQUMsQ0FBQ0UsR0FBRztnQkFDOUU4WSxpQkFBaUJqSSxHQUFHLENBQUMyTztZQUN2QjtZQUNBLE1BQU10Qix3QkFBd0JqZCxPQUFPMFMsU0FBU3JKLE1BQU0sRUFBRTtnQkFDcERuSDtZQUNGO1lBQ0EsT0FBTztnQkFDTGlhLGdCQUFnQjtZQUNsQjtRQUNGO1FBQ0EseUNBQXlDO1FBQ3pDLElBQUksRUFDRjFVLFVBQVUsRUFDVjBPLE1BQU0sRUFDUCxHQUFHcUksa0JBQWtCeGUsT0FBT29ILFNBQVNtVyxlQUFlWSxlQUFlbkQsY0FBY3dDLHNCQUFzQlksZ0JBQWdCbkc7UUFDeEgsOERBQThEO1FBQzlEQSxnQkFBZ0J6UCxPQUFPLENBQUMsQ0FBQ2lXLGNBQWMzQjtZQUNyQzJCLGFBQWF4TixTQUFTLENBQUNWLENBQUFBO2dCQUNyQixnRUFBZ0U7Z0JBQ2hFLDZDQUE2QztnQkFDN0Msc0VBQXNFO2dCQUN0RSxJQUFJQSxXQUFXa08sYUFBYTlOLElBQUksRUFBRTtvQkFDaENzSCxnQkFBZ0J2SCxNQUFNLENBQUNvTTtnQkFDekI7WUFDRjtRQUNGO1FBQ0EsSUFBSVksa0JBQWtCQztRQUN0QixJQUFJZSxxQkFBcUJDLHFCQUFxQmhIO1FBQzlDLElBQUlpSCx1QkFBdUJsQixtQkFBbUJnQixzQkFBc0JsQixxQkFBcUIzZSxNQUFNLEdBQUc7UUFDbEcsT0FBT1AsU0FBUztZQUNkbUo7WUFDQTBPO1FBQ0YsR0FBR3lJLHVCQUF1QjtZQUN4QmhJLFVBQVUsSUFBSUMsSUFBSTdXLE1BQU00VyxRQUFRO1FBQ2xDLElBQUksQ0FBQztJQUNQO0lBQ0EsMERBQTBEO0lBQzFELFNBQVNpSSxNQUFNOWYsR0FBRyxFQUFFK2QsT0FBTyxFQUFFdlosSUFBSSxFQUFFNlYsSUFBSTtRQUNyQyxJQUFJMUUsVUFBVTtZQUNaLE1BQU0sSUFBSXpRLE1BQU0sOEVBQThFLGlGQUFpRjtRQUNqTDtRQUNBLElBQUl3VCxpQkFBaUJ0SSxHQUFHLENBQUNwUSxNQUFNZ2YsYUFBYWhmO1FBQzVDLElBQUk0YSxZQUFZLENBQUNQLFFBQVFBLEtBQUtNLGtCQUFrQixNQUFNO1FBQ3RELElBQUk4QixjQUFjM0csc0JBQXNCRDtRQUN4QyxJQUFJNkYsaUJBQWlCQyxZQUFZMWEsTUFBTVksUUFBUSxFQUFFWixNQUFNb0gsT0FBTyxFQUFFTCxVQUFVK04sT0FBT0ksa0JBQWtCLEVBQUUzUixNQUFNdVIsT0FBT2pILG9CQUFvQixFQUFFaVAsU0FBUzFELFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUt3QixRQUFRO1FBQ3RMLElBQUl4VCxVQUFVUCxZQUFZMlUsYUFBYWYsZ0JBQWdCMVQ7UUFDdkQsSUFBSSxDQUFDSyxTQUFTO1lBQ1owWCxnQkFBZ0IvZixLQUFLK2QsU0FBU25ILHVCQUF1QixLQUFLO2dCQUN4RDdVLFVBQVUyWjtZQUNaLElBQUk7Z0JBQ0ZkO1lBQ0Y7WUFDQTtRQUNGO1FBQ0EsSUFBSSxFQUNGbFksSUFBSSxFQUNKb1osVUFBVSxFQUNWdFYsS0FBSyxFQUNOLEdBQUd1Vix5QkFBeUJoRyxPQUFPRSxzQkFBc0IsRUFBRSxNQUFNeUYsZ0JBQWdCckI7UUFDbEYsSUFBSTdULE9BQU87WUFDVHVaLGdCQUFnQi9mLEtBQUsrZCxTQUFTdlgsT0FBTztnQkFDbkNvVTtZQUNGO1lBQ0E7UUFDRjtRQUNBLElBQUluUyxRQUFRbVYsZUFBZXZWLFNBQVMzRjtRQUNwQ3VWLDRCQUE0QixDQUFDb0MsUUFBUUEsS0FBSzNDLGtCQUFrQixNQUFNO1FBQ2xFLElBQUlvRSxjQUFjWixpQkFBaUJZLFdBQVdySCxVQUFVLEdBQUc7WUFDekR1TCxvQkFBb0JoZ0IsS0FBSytkLFNBQVNyYixNQUFNK0YsT0FBT0osU0FBU3VTLFdBQVdrQjtZQUNuRTtRQUNGO1FBQ0EseUVBQXlFO1FBQ3pFLGdCQUFnQjtRQUNoQi9DLGlCQUFpQjFJLEdBQUcsQ0FBQ3JRLEtBQUs7WUFDeEIrZDtZQUNBcmI7UUFDRjtRQUNBdWQsb0JBQW9CamdCLEtBQUsrZCxTQUFTcmIsTUFBTStGLE9BQU9KLFNBQVN1UyxXQUFXa0I7SUFDckU7SUFDQSwrRUFBK0U7SUFDL0UsMkJBQTJCO0lBQzNCLGVBQWVrRSxvQkFBb0JoZ0IsR0FBRyxFQUFFK2QsT0FBTyxFQUFFcmIsSUFBSSxFQUFFK0YsS0FBSyxFQUFFeVgsY0FBYyxFQUFFdEYsU0FBUyxFQUFFa0IsVUFBVTtRQUNqR087UUFDQXRELGlCQUFpQnBILE1BQU0sQ0FBQzNSO1FBQ3hCLElBQUksQ0FBQ3lJLE1BQU12QixLQUFLLENBQUM5RixNQUFNLElBQUksQ0FBQ3FILE1BQU12QixLQUFLLENBQUMrUCxJQUFJLEVBQUU7WUFDNUMsSUFBSXpRLFFBQVFvUSx1QkFBdUIsS0FBSztnQkFDdENrSCxRQUFRaEMsV0FBV3JILFVBQVU7Z0JBQzdCMVMsVUFBVVc7Z0JBQ1ZxYixTQUFTQTtZQUNYO1lBQ0FnQyxnQkFBZ0IvZixLQUFLK2QsU0FBU3ZYLE9BQU87Z0JBQ25Db1U7WUFDRjtZQUNBO1FBQ0Y7UUFDQSw4Q0FBOEM7UUFDOUMsSUFBSXVGLGtCQUFrQmxmLE1BQU00VyxRQUFRLENBQUN4RyxHQUFHLENBQUNyUjtRQUN6Q29nQixtQkFBbUJwZ0IsS0FBS3FnQixxQkFBcUJ2RSxZQUFZcUUsa0JBQWtCO1lBQ3pFdkY7UUFDRjtRQUNBLGtDQUFrQztRQUNsQyxJQUFJMEYsa0JBQWtCLElBQUlsTjtRQUMxQixJQUFJbU4sZUFBZXhELHdCQUF3QmhOLEtBQUt6TixPQUFPLEVBQUVJLE1BQU00ZCxnQkFBZ0IvTyxNQUFNLEVBQUV1SztRQUN2RnBELGlCQUFpQnJJLEdBQUcsQ0FBQ3JRLEtBQUtzZ0I7UUFDMUIsSUFBSUUsb0JBQW9CN0g7UUFDeEIsSUFBSThILGVBQWUsTUFBTXpDLG1CQUFtQixVQUFVdUMsY0FBYzlYLE9BQU95WCxnQkFBZ0IzWSxVQUFVRixvQkFBb0JXLFVBQVUrTixPQUFPakgsb0JBQW9CO1FBQzlKLElBQUl5UixhQUFhaFAsTUFBTSxDQUFDQyxPQUFPLEVBQUU7WUFDL0Isc0VBQXNFO1lBQ3RFLHlFQUF5RTtZQUN6RSxJQUFJa0gsaUJBQWlCckgsR0FBRyxDQUFDclIsU0FBU3NnQixpQkFBaUI7Z0JBQ2pENUgsaUJBQWlCL0csTUFBTSxDQUFDM1I7WUFDMUI7WUFDQTtRQUNGO1FBQ0EsMkVBQTJFO1FBQzNFLDBFQUEwRTtRQUMxRSxPQUFPO1FBQ1AsSUFBSStWLE9BQU9DLGlCQUFpQixJQUFJaUQsZ0JBQWdCN0ksR0FBRyxDQUFDcFEsTUFBTTtZQUN4RCxJQUFJaWUsaUJBQWlCd0MsaUJBQWlCdEMsY0FBY3NDLGVBQWU7Z0JBQ2pFTCxtQkFBbUJwZ0IsS0FBSzBnQixlQUFleGY7Z0JBQ3ZDO1lBQ0Y7UUFDQSxvREFBb0Q7UUFDdEQsT0FBTztZQUNMLElBQUkrYyxpQkFBaUJ3QyxlQUFlO2dCQUNsQy9ILGlCQUFpQi9HLE1BQU0sQ0FBQzNSO2dCQUN4QixJQUFJNFksMEJBQTBCNEgsbUJBQW1CO29CQUMvQyxvRUFBb0U7b0JBQ3BFLG9FQUFvRTtvQkFDcEUscUVBQXFFO29CQUNyRSw2Q0FBNkM7b0JBQzdDSixtQkFBbUJwZ0IsS0FBSzBnQixlQUFleGY7b0JBQ3ZDO2dCQUNGLE9BQU87b0JBQ0w0WCxpQkFBaUJqSSxHQUFHLENBQUM3UTtvQkFDckJvZ0IsbUJBQW1CcGdCLEtBQUsrZSxrQkFBa0JqRDtvQkFDMUMsT0FBT29DLHdCQUF3QmpkLE9BQU93ZixjQUFjO3dCQUNsRGhELG1CQUFtQjNCO29CQUNyQjtnQkFDRjtZQUNGO1lBQ0EseUNBQXlDO1lBQ3pDLElBQUlxQyxjQUFjc0MsZUFBZTtnQkFDL0JWLGdCQUFnQi9mLEtBQUsrZCxTQUFTMEMsYUFBYWphLEtBQUs7Z0JBQ2hEO1lBQ0Y7UUFDRjtRQUNBLElBQUk2WCxpQkFBaUJvQyxlQUFlO1lBQ2xDLE1BQU03Six1QkFBdUIsS0FBSztnQkFDaENpSCxNQUFNO1lBQ1I7UUFDRjtRQUNBLHlFQUF5RTtRQUN6RSxnQ0FBZ0M7UUFDaEMsSUFBSTdhLGVBQWUvQixNQUFNdVcsVUFBVSxDQUFDM1YsUUFBUSxJQUFJWixNQUFNWSxRQUFRO1FBQzlELElBQUk4ZSxzQkFBc0I1RCx3QkFBd0JoTixLQUFLek4sT0FBTyxFQUFFVSxjQUFjc2QsZ0JBQWdCL08sTUFBTTtRQUNwRyxJQUFJa0wsY0FBYzNHLHNCQUFzQkQ7UUFDeEMsSUFBSXhOLFVBQVVwSCxNQUFNdVcsVUFBVSxDQUFDdlcsS0FBSyxLQUFLLFNBQVM2RyxZQUFZMlUsYUFBYXhiLE1BQU11VyxVQUFVLENBQUMzVixRQUFRLEVBQUVtRyxZQUFZL0csTUFBTW9ILE9BQU87UUFDL0h0RCxVQUFVc0QsU0FBUztRQUNuQixJQUFJdVksU0FBUyxFQUFFakk7UUFDZkUsZUFBZXhJLEdBQUcsQ0FBQ3JRLEtBQUs0Z0I7UUFDeEIsSUFBSUMsY0FBYzlCLGtCQUFrQmpELFlBQVkyRSxhQUFhN1gsSUFBSTtRQUNqRTNILE1BQU00VyxRQUFRLENBQUN4SCxHQUFHLENBQUNyUSxLQUFLNmdCO1FBQ3hCLElBQUksQ0FBQ3JDLGVBQWVDLHFCQUFxQixHQUFHQyxpQkFBaUIzTyxLQUFLek4sT0FBTyxFQUFFckIsT0FBT29ILFNBQVN5VCxZQUFZOVksY0FBYyxPQUFPdVYsd0JBQXdCQyx5QkFBeUJDLHVCQUF1QlEsaUJBQWlCRixrQkFBa0JELGtCQUFrQjJELGFBQWF6VSxVQUFVO1lBQzlRLENBQUNTLE1BQU12QixLQUFLLENBQUNPLEVBQUUsQ0FBQyxFQUFFZ1osYUFBYTdYLElBQUk7UUFDckMsR0FBRzFILFVBQVUsOERBQThEOztRQUUzRSx1RUFBdUU7UUFDdkUsNEVBQTRFO1FBQzVFLHFEQUFxRDtRQUNyRHVkLHFCQUFxQm5ULE1BQU0sQ0FBQ3VULENBQUFBLEtBQU1BLEdBQUc3ZSxHQUFHLEtBQUtBLEtBQUt5SixPQUFPLENBQUNvVixDQUFBQTtZQUN4RCxJQUFJaUMsV0FBV2pDLEdBQUc3ZSxHQUFHO1lBQ3JCLElBQUltZ0Isa0JBQWtCbGYsTUFBTTRXLFFBQVEsQ0FBQ3hHLEdBQUcsQ0FBQ3lQO1lBQ3pDLElBQUloQyxzQkFBc0JDLGtCQUFrQjdkLFdBQVdpZixrQkFBa0JBLGdCQUFnQnZYLElBQUksR0FBRzFIO1lBQ2hHRCxNQUFNNFcsUUFBUSxDQUFDeEgsR0FBRyxDQUFDeVEsVUFBVWhDO1lBQzdCLElBQUlwRyxpQkFBaUJ0SSxHQUFHLENBQUMwUSxXQUFXO2dCQUNsQzlCLGFBQWE4QjtZQUNmO1lBQ0EsSUFBSWpDLEdBQUd2TixVQUFVLEVBQUU7Z0JBQ2pCb0gsaUJBQWlCckksR0FBRyxDQUFDeVEsVUFBVWpDLEdBQUd2TixVQUFVO1lBQzlDO1FBQ0Y7UUFDQW9JLFlBQVk7WUFDVjdCLFVBQVUsSUFBSUMsSUFBSTdXLE1BQU00VyxRQUFRO1FBQ2xDO1FBQ0EsSUFBSW9ILGlDQUFpQyxJQUFNUixxQkFBcUJoVixPQUFPLENBQUNvVixDQUFBQSxLQUFNRyxhQUFhSCxHQUFHN2UsR0FBRztRQUNqR3NnQixnQkFBZ0IvTyxNQUFNLENBQUMzSyxnQkFBZ0IsQ0FBQyxTQUFTcVk7UUFDakQsSUFBSSxFQUNGRSxPQUFPLEVBQ1BDLGFBQWEsRUFDYkMsY0FBYyxFQUNmLEdBQUcsTUFBTUMsK0JBQStCcmUsTUFBTW9ILE9BQU8sRUFBRUEsU0FBU21XLGVBQWVDLHNCQUFzQmtDO1FBQ3RHLElBQUlMLGdCQUFnQi9PLE1BQU0sQ0FBQ0MsT0FBTyxFQUFFO1lBQ2xDO1FBQ0Y7UUFDQThPLGdCQUFnQi9PLE1BQU0sQ0FBQzFLLG1CQUFtQixDQUFDLFNBQVNvWTtRQUNwRHBHLGVBQWVsSCxNQUFNLENBQUMzUjtRQUN0QjBZLGlCQUFpQi9HLE1BQU0sQ0FBQzNSO1FBQ3hCeWUscUJBQXFCaFYsT0FBTyxDQUFDMEosQ0FBQUEsSUFBS3VGLGlCQUFpQi9HLE1BQU0sQ0FBQ3dCLEVBQUVuVCxHQUFHO1FBQy9ELElBQUkyVCxXQUFXNEwsYUFBYUo7UUFDNUIsSUFBSXhMLFVBQVU7WUFDWixJQUFJQSxTQUFTaE8sR0FBRyxJQUFJNlksY0FBYzFlLE1BQU0sRUFBRTtnQkFDeEMsK0RBQStEO2dCQUMvRCxvRUFBb0U7Z0JBQ3BFLG9CQUFvQjtnQkFDcEIsSUFBSTBmLGFBQWFmLG9CQUFvQixDQUFDOUssU0FBU2hPLEdBQUcsR0FBRzZZLGNBQWMxZSxNQUFNLENBQUMsQ0FBQ0UsR0FBRztnQkFDOUU4WSxpQkFBaUJqSSxHQUFHLENBQUMyTztZQUN2QjtZQUNBLE9BQU90Qix3QkFBd0JqZCxPQUFPMFMsU0FBU3JKLE1BQU07UUFDdkQ7UUFDQSx5Q0FBeUM7UUFDekMsSUFBSSxFQUNGNUIsVUFBVSxFQUNWME8sTUFBTSxFQUNQLEdBQUdxSSxrQkFBa0J4ZSxPQUFPQSxNQUFNb0gsT0FBTyxFQUFFbVcsZUFBZVksZUFBZWxlLFdBQVd1ZCxzQkFBc0JZLGdCQUFnQm5HO1FBQzNILHlFQUF5RTtRQUN6RSw4REFBOEQ7UUFDOUQsSUFBSWpZLE1BQU00VyxRQUFRLENBQUN6SCxHQUFHLENBQUNwUSxNQUFNO1lBQzNCLElBQUkrZ0IsY0FBY0wsZUFBZUQsYUFBYTdYLElBQUk7WUFDbEQzSCxNQUFNNFcsUUFBUSxDQUFDeEgsR0FBRyxDQUFDclEsS0FBSytnQjtRQUMxQjtRQUNBbkIscUJBQXFCZ0I7UUFDckIsd0VBQXdFO1FBQ3hFLHVFQUF1RTtRQUN2RSxtREFBbUQ7UUFDbkQsSUFBSTNmLE1BQU11VyxVQUFVLENBQUN2VyxLQUFLLEtBQUssYUFBYTJmLFNBQVNoSSx5QkFBeUI7WUFDNUU3VCxVQUFVaVQsZUFBZTtZQUN6QkUsK0JBQStCQSw0QkFBNEI5RixLQUFLO1lBQ2hFeUksbUJBQW1CNVosTUFBTXVXLFVBQVUsQ0FBQzNWLFFBQVEsRUFBRTtnQkFDNUN3RztnQkFDQUs7Z0JBQ0EwTztnQkFDQVMsVUFBVSxJQUFJQyxJQUFJN1csTUFBTTRXLFFBQVE7WUFDbEM7UUFDRixPQUFPO1lBQ0wsdUVBQXVFO1lBQ3ZFLGtFQUFrRTtZQUNsRSx1RUFBdUU7WUFDdkU2QixZQUFZO2dCQUNWdEM7Z0JBQ0ExTyxZQUFZMlMsZ0JBQWdCcGEsTUFBTXlILFVBQVUsRUFBRUEsWUFBWUwsU0FBUytPO2dCQUNuRVMsVUFBVSxJQUFJQyxJQUFJN1csTUFBTTRXLFFBQVE7WUFDbEM7WUFDQVUseUJBQXlCO1FBQzNCO0lBQ0Y7SUFDQSwrRUFBK0U7SUFDL0UsZUFBZTBILG9CQUFvQmpnQixHQUFHLEVBQUUrZCxPQUFPLEVBQUVyYixJQUFJLEVBQUUrRixLQUFLLEVBQUVKLE9BQU8sRUFBRXVTLFNBQVMsRUFBRWtCLFVBQVU7UUFDMUYsSUFBSXFFLGtCQUFrQmxmLE1BQU00VyxRQUFRLENBQUN4RyxHQUFHLENBQUNyUjtRQUN6Q29nQixtQkFBbUJwZ0IsS0FBSytlLGtCQUFrQmpELFlBQVlxRSxrQkFBa0JBLGdCQUFnQnZYLElBQUksR0FBRzFILFlBQVk7WUFDekcwWjtRQUNGO1FBQ0EsK0NBQStDO1FBQy9DLElBQUkwRixrQkFBa0IsSUFBSWxOO1FBQzFCLElBQUltTixlQUFleEQsd0JBQXdCaE4sS0FBS3pOLE9BQU8sRUFBRUksTUFBTTRkLGdCQUFnQi9PLE1BQU07UUFDckZtSCxpQkFBaUJySSxHQUFHLENBQUNyUSxLQUFLc2dCO1FBQzFCLElBQUlFLG9CQUFvQjdIO1FBQ3hCLElBQUlyTyxTQUFTLE1BQU0wVCxtQkFBbUIsVUFBVXVDLGNBQWM5WCxPQUFPSixTQUFTZCxVQUFVRixvQkFBb0JXLFVBQVUrTixPQUFPakgsb0JBQW9CO1FBQ2pKLDRFQUE0RTtRQUM1RSx1RUFBdUU7UUFDdkUsNEVBQTRFO1FBQzVFLHdCQUF3QjtRQUN4QixJQUFJdVAsaUJBQWlCL1QsU0FBUztZQUM1QkEsU0FBUyxNQUFPMFcsb0JBQW9CMVcsUUFBUWlXLGFBQWFoUCxNQUFNLEVBQUUsU0FBVWpIO1FBQzdFO1FBQ0EsMEVBQTBFO1FBQzFFLHVFQUF1RTtRQUN2RSxJQUFJb08saUJBQWlCckgsR0FBRyxDQUFDclIsU0FBU3NnQixpQkFBaUI7WUFDakQ1SCxpQkFBaUIvRyxNQUFNLENBQUMzUjtRQUMxQjtRQUNBLElBQUl1Z0IsYUFBYWhQLE1BQU0sQ0FBQ0MsT0FBTyxFQUFFO1lBQy9CO1FBQ0Y7UUFDQSx1RUFBdUU7UUFDdkUsZ0VBQWdFO1FBQ2hFLElBQUl5SCxnQkFBZ0I3SSxHQUFHLENBQUNwUSxNQUFNO1lBQzVCb2dCLG1CQUFtQnBnQixLQUFLMGdCLGVBQWV4ZjtZQUN2QztRQUNGO1FBQ0EsMEVBQTBFO1FBQzFFLElBQUkrYyxpQkFBaUIzVCxTQUFTO1lBQzVCLElBQUlzTywwQkFBMEI0SCxtQkFBbUI7Z0JBQy9DLG9FQUFvRTtnQkFDcEUsdURBQXVEO2dCQUN2REosbUJBQW1CcGdCLEtBQUswZ0IsZUFBZXhmO2dCQUN2QztZQUNGLE9BQU87Z0JBQ0w0WCxpQkFBaUJqSSxHQUFHLENBQUM3UTtnQkFDckIsTUFBTWtlLHdCQUF3QmpkLE9BQU9xSjtnQkFDckM7WUFDRjtRQUNGO1FBQ0EseUNBQXlDO1FBQ3pDLElBQUk2VCxjQUFjN1QsU0FBUztZQUN6QnlWLGdCQUFnQi9mLEtBQUsrZCxTQUFTelQsT0FBTzlELEtBQUs7WUFDMUM7UUFDRjtRQUNBekIsVUFBVSxDQUFDc1osaUJBQWlCL1QsU0FBUztRQUNyQywwQ0FBMEM7UUFDMUM4VixtQkFBbUJwZ0IsS0FBSzBnQixlQUFlcFcsT0FBTzFCLElBQUk7SUFDcEQ7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JDLEdBQ0QsZUFBZXNWLHdCQUF3QmpkLEtBQUssRUFBRTBTLFFBQVEsRUFBRXNOLE1BQU07UUFDNUQsSUFBSSxFQUNGbkYsVUFBVSxFQUNWMkIsaUJBQWlCLEVBQ2pCdGEsT0FBTyxFQUNSLEdBQUc4ZCxXQUFXLEtBQUssSUFBSSxDQUFDLElBQUlBO1FBQzdCLElBQUl0TixTQUFTeUksVUFBVSxFQUFFO1lBQ3ZCN0QseUJBQXlCO1FBQzNCO1FBQ0EsSUFBSTJJLG1CQUFtQnBmLGVBQWViLE1BQU1ZLFFBQVEsRUFBRThSLFNBQVM5UixRQUFRLEVBQUU7WUFDdkVzWixhQUFhO1FBQ2Y7UUFDQXBXLFVBQVVtYyxrQkFBa0I7UUFDNUIsSUFBSXpMLFdBQVc7WUFDYixJQUFJMEwsbUJBQW1CO1lBQ3ZCLElBQUl4TixTQUFTeU4sY0FBYyxFQUFFO2dCQUMzQixnRUFBZ0U7Z0JBQ2hFRCxtQkFBbUI7WUFDckIsT0FBTyxJQUFJak0sbUJBQW1CekosSUFBSSxDQUFDa0ksU0FBUzlSLFFBQVEsR0FBRztnQkFDckQsTUFBTTZDLE1BQU1xTCxLQUFLek4sT0FBTyxDQUFDQyxTQUFTLENBQUNvUixTQUFTOVIsUUFBUTtnQkFDcERzZixtQkFDQSxzREFBc0Q7Z0JBQ3REemMsSUFBSWlDLE1BQU0sS0FBSzZPLGFBQWEzVCxRQUFRLENBQUM4RSxNQUFNLElBQzNDLHVFQUF1RTtnQkFDdkVzQixjQUFjdkQsSUFBSTNDLFFBQVEsRUFBRWlHLGFBQWE7WUFDM0M7WUFDQSxJQUFJbVosa0JBQWtCO2dCQUNwQixJQUFJaGUsU0FBUztvQkFDWHFTLGFBQWEzVCxRQUFRLENBQUNzQixPQUFPLENBQUN3USxTQUFTOVIsUUFBUTtnQkFDakQsT0FBTztvQkFDTDJULGFBQWEzVCxRQUFRLENBQUNwQyxNQUFNLENBQUNrVSxTQUFTOVIsUUFBUTtnQkFDaEQ7Z0JBQ0E7WUFDRjtRQUNGO1FBQ0EsbUVBQW1FO1FBQ25FLGlEQUFpRDtRQUNqRHFXLDhCQUE4QjtRQUM5QixJQUFJbUosd0JBQXdCbGUsWUFBWSxPQUFPOUMsT0FBTytDLE9BQU8sR0FBRy9DLE9BQU8wQyxJQUFJO1FBQzNFLHlFQUF5RTtRQUN6RSxtQkFBbUI7UUFDbkIsSUFBSSxFQUNGMFIsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWixHQUFHMVQsTUFBTXVXLFVBQVU7UUFDcEIsSUFBSSxDQUFDc0UsY0FBYyxDQUFDMkIscUJBQXFCaEosY0FBY0MsY0FBY0MsYUFBYTtZQUNoRm1ILGFBQWF5Qyw0QkFBNEJ0ZCxNQUFNdVcsVUFBVTtRQUMzRDtRQUNBLDJFQUEyRTtRQUMzRSw0RUFBNEU7UUFDNUUsc0JBQXNCO1FBQ3RCLElBQUk4RyxtQkFBbUJ4QyxjQUFjMkI7UUFDckMsSUFBSWxKLGtDQUFrQ25FLEdBQUcsQ0FBQ3VELFNBQVMxRCxNQUFNLEtBQUtxTyxvQkFBb0JwRCxpQkFBaUJvRCxpQkFBaUI3SixVQUFVLEdBQUc7WUFDL0gsTUFBTWtGLGdCQUFnQjBILHVCQUF1Qkgsa0JBQWtCO2dCQUM3RHBGLFlBQVl2YyxTQUFTLENBQUMsR0FBRytlLGtCQUFrQjtvQkFDekM1SixZQUFZZixTQUFTOVIsUUFBUTtnQkFDL0I7Z0JBQ0Esc0NBQXNDO2dCQUN0QzZWLG9CQUFvQk87WUFDdEI7UUFDRixPQUFPO1lBQ0wsc0VBQXNFO1lBQ3RFLHNCQUFzQjtZQUN0QixJQUFJc0UscUJBQXFCZSxxQkFBcUI0RCxrQkFBa0JwRjtZQUNoRSxNQUFNbkMsZ0JBQWdCMEgsdUJBQXVCSCxrQkFBa0I7Z0JBQzdEM0U7Z0JBQ0Esd0RBQXdEO2dCQUN4RGtCO2dCQUNBLHNDQUFzQztnQkFDdEMvRixvQkFBb0JPO1lBQ3RCO1FBQ0Y7SUFDRjtJQUNBLGVBQWVxSCwrQkFBK0JnQyxjQUFjLEVBQUVqWixPQUFPLEVBQUVtVyxhQUFhLEVBQUUrQyxjQUFjLEVBQUV6RSxPQUFPO1FBQzNHLDRFQUE0RTtRQUM1RSx3RUFBd0U7UUFDeEUsY0FBYztRQUNkLElBQUlxQyxVQUFVLE1BQU16TyxRQUFROFEsR0FBRyxDQUFDO2VBQUloRCxjQUFjM2QsR0FBRyxDQUFDNEgsQ0FBQUEsUUFBU3VWLG1CQUFtQixVQUFVbEIsU0FBU3JVLE9BQU9KLFNBQVNkLFVBQVVGLG9CQUFvQlcsVUFBVStOLE9BQU9qSCxvQkFBb0I7ZUFBT3lTLGVBQWUxZ0IsR0FBRyxDQUFDcWUsQ0FBQUE7Z0JBQ2hOLElBQUlBLEVBQUU3VyxPQUFPLElBQUk2VyxFQUFFelcsS0FBSyxJQUFJeVcsRUFBRTVOLFVBQVUsRUFBRTtvQkFDeEMsT0FBTzBNLG1CQUFtQixVQUFVakIsd0JBQXdCaE4sS0FBS3pOLE9BQU8sRUFBRTRjLEVBQUV4YyxJQUFJLEVBQUV3YyxFQUFFNU4sVUFBVSxDQUFDQyxNQUFNLEdBQUcyTixFQUFFelcsS0FBSyxFQUFFeVcsRUFBRTdXLE9BQU8sRUFBRWQsVUFBVUYsb0JBQW9CVyxVQUFVK04sT0FBT2pILG9CQUFvQjtnQkFDak0sT0FBTztvQkFDTCxJQUFJdEksUUFBUTt3QkFDVnFYLE1BQU0vVyxXQUFXTixLQUFLO3dCQUN0QkEsT0FBT29RLHVCQUF1QixLQUFLOzRCQUNqQzdVLFVBQVVtZCxFQUFFeGMsSUFBSTt3QkFDbEI7b0JBQ0Y7b0JBQ0EsT0FBTzhEO2dCQUNUO1lBQ0Y7U0FBRztRQUNILElBQUk0WSxnQkFBZ0JELFFBQVF0YSxLQUFLLENBQUMsR0FBRzJaLGNBQWMxZSxNQUFNO1FBQ3pELElBQUl1ZixpQkFBaUJGLFFBQVF0YSxLQUFLLENBQUMyWixjQUFjMWUsTUFBTTtRQUN2RCxNQUFNNFEsUUFBUThRLEdBQUcsQ0FBQztZQUFDQyx1QkFBdUJILGdCQUFnQjlDLGVBQWVZLGVBQWVBLGNBQWN2ZSxHQUFHLENBQUMsSUFBTWljLFFBQVF2TCxNQUFNLEdBQUcsT0FBT3RRLE1BQU15SCxVQUFVO1lBQUcrWSx1QkFBdUJILGdCQUFnQkMsZUFBZTFnQixHQUFHLENBQUNxZSxDQUFBQSxJQUFLQSxFQUFFelcsS0FBSyxHQUFHNFcsZ0JBQWdCa0MsZUFBZTFnQixHQUFHLENBQUNxZSxDQUFBQSxJQUFLQSxFQUFFNU4sVUFBVSxHQUFHNE4sRUFBRTVOLFVBQVUsQ0FBQ0MsTUFBTSxHQUFHLE9BQU87U0FBTTtRQUM5VCxPQUFPO1lBQ0w0TjtZQUNBQztZQUNBQztRQUNGO0lBQ0Y7SUFDQSxTQUFTaEQ7UUFDUCw2Q0FBNkM7UUFDN0M5RCx5QkFBeUI7UUFDekIscUVBQXFFO1FBQ3JFLGVBQWU7UUFDZkMsd0JBQXdCMVYsSUFBSSxJQUFJOFo7UUFDaEMsZ0NBQWdDO1FBQ2hDN0QsaUJBQWlCdFAsT0FBTyxDQUFDLENBQUNnRSxHQUFHek47WUFDM0IsSUFBSTBZLGlCQUFpQnRJLEdBQUcsQ0FBQ3BRLE1BQU07Z0JBQzdCeVksc0JBQXNCM1YsSUFBSSxDQUFDOUM7Z0JBQzNCZ2YsYUFBYWhmO1lBQ2Y7UUFDRjtJQUNGO0lBQ0EsU0FBU29nQixtQkFBbUJwZ0IsR0FBRyxFQUFFd2EsT0FBTyxFQUFFSCxJQUFJO1FBQzVDLElBQUlBLFNBQVMsS0FBSyxHQUFHO1lBQ25CQSxPQUFPLENBQUM7UUFDVjtRQUNBcFosTUFBTTRXLFFBQVEsQ0FBQ3hILEdBQUcsQ0FBQ3JRLEtBQUt3YTtRQUN4QmQsWUFBWTtZQUNWN0IsVUFBVSxJQUFJQyxJQUFJN1csTUFBTTRXLFFBQVE7UUFDbEMsR0FBRztZQUNEK0MsV0FBVyxDQUFDUCxRQUFRQSxLQUFLTyxTQUFTLE1BQU07UUFDMUM7SUFDRjtJQUNBLFNBQVNtRixnQkFBZ0IvZixHQUFHLEVBQUUrZCxPQUFPLEVBQUV2WCxLQUFLLEVBQUU2VCxJQUFJO1FBQ2hELElBQUlBLFNBQVMsS0FBSyxHQUFHO1lBQ25CQSxPQUFPLENBQUM7UUFDVjtRQUNBLElBQUkrRCxnQkFBZ0JuQixvQkFBb0JoYyxNQUFNb0gsT0FBTyxFQUFFMFY7UUFDdkQ3RCxjQUFjbGE7UUFDZDBaLFlBQVk7WUFDVnRDLFFBQVE7Z0JBQ04sQ0FBQ2dILGNBQWNsWCxLQUFLLENBQUNPLEVBQUUsQ0FBQyxFQUFFakI7WUFDNUI7WUFDQXFSLFVBQVUsSUFBSUMsSUFBSTdXLE1BQU00VyxRQUFRO1FBQ2xDLEdBQUc7WUFDRCtDLFdBQVcsQ0FBQ1AsUUFBUUEsS0FBS08sU0FBUyxNQUFNO1FBQzFDO0lBQ0Y7SUFDQSxTQUFTOEcsV0FBVzFoQixHQUFHO1FBQ3JCLElBQUkrVixPQUFPQyxpQkFBaUIsRUFBRTtZQUM1QmdELGVBQWUzSSxHQUFHLENBQUNyUSxLQUFLLENBQUNnWixlQUFlM0gsR0FBRyxDQUFDclIsUUFBUSxLQUFLO1lBQ3pELHlFQUF5RTtZQUN6RSxzQkFBc0I7WUFDdEIsSUFBSWlaLGdCQUFnQjdJLEdBQUcsQ0FBQ3BRLE1BQU07Z0JBQzVCaVosZ0JBQWdCdEgsTUFBTSxDQUFDM1I7WUFDekI7UUFDRjtRQUNBLE9BQU9pQixNQUFNNFcsUUFBUSxDQUFDeEcsR0FBRyxDQUFDclIsUUFBUThVO0lBQ3BDO0lBQ0EsU0FBU29GLGNBQWNsYSxHQUFHO1FBQ3hCLElBQUl3YSxVQUFVdlosTUFBTTRXLFFBQVEsQ0FBQ3hHLEdBQUcsQ0FBQ3JSO1FBQ2pDLHlFQUF5RTtRQUN6RSx5RUFBeUU7UUFDekUsa0RBQWtEO1FBQ2xELElBQUkwWSxpQkFBaUJ0SSxHQUFHLENBQUNwUSxRQUFRLENBQUV3YSxDQUFBQSxXQUFXQSxRQUFRdlosS0FBSyxLQUFLLGFBQWE0WCxlQUFlekksR0FBRyxDQUFDcFEsSUFBRyxHQUFJO1lBQ3JHZ2YsYUFBYWhmO1FBQ2Y7UUFDQStZLGlCQUFpQnBILE1BQU0sQ0FBQzNSO1FBQ3hCNlksZUFBZWxILE1BQU0sQ0FBQzNSO1FBQ3RCOFksaUJBQWlCbkgsTUFBTSxDQUFDM1I7UUFDeEJpWixnQkFBZ0J0SCxNQUFNLENBQUMzUjtRQUN2QmlCLE1BQU00VyxRQUFRLENBQUNsRyxNQUFNLENBQUMzUjtJQUN4QjtJQUNBLFNBQVMyaEIsNEJBQTRCM2hCLEdBQUc7UUFDdEMsSUFBSStWLE9BQU9DLGlCQUFpQixFQUFFO1lBQzVCLElBQUk0TCxRQUFRLENBQUM1SSxlQUFlM0gsR0FBRyxDQUFDclIsUUFBUSxLQUFLO1lBQzdDLElBQUk0aEIsU0FBUyxHQUFHO2dCQUNkNUksZUFBZXJILE1BQU0sQ0FBQzNSO2dCQUN0QmlaLGdCQUFnQnBJLEdBQUcsQ0FBQzdRO1lBQ3RCLE9BQU87Z0JBQ0xnWixlQUFlM0ksR0FBRyxDQUFDclEsS0FBSzRoQjtZQUMxQjtRQUNGLE9BQU87WUFDTDFILGNBQWNsYTtRQUNoQjtRQUNBMFosWUFBWTtZQUNWN0IsVUFBVSxJQUFJQyxJQUFJN1csTUFBTTRXLFFBQVE7UUFDbEM7SUFDRjtJQUNBLFNBQVNtSCxhQUFhaGYsR0FBRztRQUN2QixJQUFJc1IsYUFBYW9ILGlCQUFpQnJILEdBQUcsQ0FBQ3JSO1FBQ3RDK0UsVUFBVXVNLFlBQVksZ0NBQWdDdFI7UUFDdERzUixXQUFXYyxLQUFLO1FBQ2hCc0csaUJBQWlCL0csTUFBTSxDQUFDM1I7SUFDMUI7SUFDQSxTQUFTNmhCLGlCQUFpQnpHLElBQUk7UUFDNUIsS0FBSyxJQUFJcGIsT0FBT29iLEtBQU07WUFDcEIsSUFBSVosVUFBVWtILFdBQVcxaEI7WUFDekIsSUFBSStnQixjQUFjTCxlQUFlbEcsUUFBUTVSLElBQUk7WUFDN0MzSCxNQUFNNFcsUUFBUSxDQUFDeEgsR0FBRyxDQUFDclEsS0FBSytnQjtRQUMxQjtJQUNGO0lBQ0EsU0FBU25DO1FBQ1AsSUFBSWtELFdBQVcsRUFBRTtRQUNqQixJQUFJbkQsa0JBQWtCO1FBQ3RCLEtBQUssSUFBSTNlLE9BQU84WSxpQkFBa0I7WUFDaEMsSUFBSTBCLFVBQVV2WixNQUFNNFcsUUFBUSxDQUFDeEcsR0FBRyxDQUFDclI7WUFDakMrRSxVQUFVeVYsU0FBUyx1QkFBdUJ4YTtZQUMxQyxJQUFJd2EsUUFBUXZaLEtBQUssS0FBSyxXQUFXO2dCQUMvQjZYLGlCQUFpQm5ILE1BQU0sQ0FBQzNSO2dCQUN4QjhoQixTQUFTaGYsSUFBSSxDQUFDOUM7Z0JBQ2QyZSxrQkFBa0I7WUFDcEI7UUFDRjtRQUNBa0QsaUJBQWlCQztRQUNqQixPQUFPbkQ7SUFDVDtJQUNBLFNBQVNpQixxQkFBcUJtQyxRQUFRO1FBQ3BDLElBQUlDLGFBQWEsRUFBRTtRQUNuQixLQUFLLElBQUksQ0FBQ2hpQixLQUFLeUgsR0FBRyxJQUFJb1IsZUFBZ0I7WUFDcEMsSUFBSXBSLEtBQUtzYSxVQUFVO2dCQUNqQixJQUFJdkgsVUFBVXZaLE1BQU00VyxRQUFRLENBQUN4RyxHQUFHLENBQUNyUjtnQkFDakMrRSxVQUFVeVYsU0FBUyx1QkFBdUJ4YTtnQkFDMUMsSUFBSXdhLFFBQVF2WixLQUFLLEtBQUssV0FBVztvQkFDL0IrZCxhQUFhaGY7b0JBQ2I2WSxlQUFlbEgsTUFBTSxDQUFDM1I7b0JBQ3RCZ2lCLFdBQVdsZixJQUFJLENBQUM5QztnQkFDbEI7WUFDRjtRQUNGO1FBQ0E2aEIsaUJBQWlCRztRQUNqQixPQUFPQSxXQUFXbGlCLE1BQU0sR0FBRztJQUM3QjtJQUNBLFNBQVNtaUIsV0FBV2ppQixHQUFHLEVBQUV3RCxFQUFFO1FBQ3pCLElBQUkwZSxVQUFVamhCLE1BQU04VyxRQUFRLENBQUMxRyxHQUFHLENBQUNyUixRQUFRK1U7UUFDekMsSUFBSW9FLGlCQUFpQjlILEdBQUcsQ0FBQ3JSLFNBQVN3RCxJQUFJO1lBQ3BDMlYsaUJBQWlCOUksR0FBRyxDQUFDclEsS0FBS3dEO1FBQzVCO1FBQ0EsT0FBTzBlO0lBQ1Q7SUFDQSxTQUFTL0gsY0FBY25hLEdBQUc7UUFDeEJpQixNQUFNOFcsUUFBUSxDQUFDcEcsTUFBTSxDQUFDM1I7UUFDdEJtWixpQkFBaUJ4SCxNQUFNLENBQUMzUjtJQUMxQjtJQUNBLHdFQUF3RTtJQUN4RSxTQUFTeVosY0FBY3paLEdBQUcsRUFBRW1pQixVQUFVO1FBQ3BDLElBQUlELFVBQVVqaEIsTUFBTThXLFFBQVEsQ0FBQzFHLEdBQUcsQ0FBQ3JSLFFBQVErVTtRQUN6Qyw2QkFBNkI7UUFDN0IseVdBQXlXO1FBQ3pXaFEsVUFBVW1kLFFBQVFqaEIsS0FBSyxLQUFLLGVBQWVraEIsV0FBV2xoQixLQUFLLEtBQUssYUFBYWloQixRQUFRamhCLEtBQUssS0FBSyxhQUFha2hCLFdBQVdsaEIsS0FBSyxLQUFLLGFBQWFpaEIsUUFBUWpoQixLQUFLLEtBQUssYUFBYWtoQixXQUFXbGhCLEtBQUssS0FBSyxnQkFBZ0JpaEIsUUFBUWpoQixLQUFLLEtBQUssYUFBYWtoQixXQUFXbGhCLEtBQUssS0FBSyxlQUFlaWhCLFFBQVFqaEIsS0FBSyxLQUFLLGdCQUFnQmtoQixXQUFXbGhCLEtBQUssS0FBSyxhQUFhLHVDQUF1Q2loQixRQUFRamhCLEtBQUssR0FBRyxTQUFTa2hCLFdBQVdsaEIsS0FBSztRQUN6YSxJQUFJOFcsV0FBVyxJQUFJRCxJQUFJN1csTUFBTThXLFFBQVE7UUFDckNBLFNBQVMxSCxHQUFHLENBQUNyUSxLQUFLbWlCO1FBQ2xCekksWUFBWTtZQUNWM0I7UUFDRjtJQUNGO0lBQ0EsU0FBU3dCLHNCQUFzQmxHLEtBQUs7UUFDbEMsSUFBSSxFQUNGbUcsZUFBZSxFQUNmeFcsWUFBWSxFQUNadVUsYUFBYSxFQUNkLEdBQUdsRTtRQUNKLElBQUk4RixpQkFBaUJ6RyxJQUFJLEtBQUssR0FBRztZQUMvQjtRQUNGO1FBQ0EsMkVBQTJFO1FBQzNFLGlEQUFpRDtRQUNqRCxJQUFJeUcsaUJBQWlCekcsSUFBSSxHQUFHLEdBQUc7WUFDN0IxUSxRQUFRLE9BQU87UUFDakI7UUFDQSxJQUFJcEIsVUFBVW9TLE1BQU0xRCxJQUFJLENBQUM2SixpQkFBaUJ2WSxPQUFPO1FBQ2pELElBQUksQ0FBQzBZLFlBQVk4SSxnQkFBZ0IsR0FBR3hoQixPQUFPLENBQUNBLFFBQVFkLE1BQU0sR0FBRyxFQUFFO1FBQy9ELElBQUlvaUIsVUFBVWpoQixNQUFNOFcsUUFBUSxDQUFDMUcsR0FBRyxDQUFDaUk7UUFDakMsSUFBSTRJLFdBQVdBLFFBQVFqaEIsS0FBSyxLQUFLLGNBQWM7WUFDN0Msb0VBQW9FO1lBQ3BFLDBDQUEwQztZQUMxQztRQUNGO1FBQ0EseUVBQXlFO1FBQ3pFLGlDQUFpQztRQUNqQyxJQUFJbWhCLGdCQUFnQjtZQUNsQjVJO1lBQ0F4VztZQUNBdVU7UUFDRixJQUFJO1lBQ0YsT0FBTytCO1FBQ1Q7SUFDRjtJQUNBLFNBQVNzRCxzQkFBc0J5RixTQUFTO1FBQ3RDLElBQUlDLG9CQUFvQixFQUFFO1FBQzFCcEosZ0JBQWdCelAsT0FBTyxDQUFDLENBQUM4WSxLQUFLeEU7WUFDNUIsSUFBSSxDQUFDc0UsYUFBYUEsVUFBVXRFLFVBQVU7Z0JBQ3BDLHNFQUFzRTtnQkFDdEUsdUVBQXVFO2dCQUN2RSx1Q0FBdUM7Z0JBQ3ZDd0UsSUFBSXBRLE1BQU07Z0JBQ1ZtUSxrQkFBa0J4ZixJQUFJLENBQUNpYjtnQkFDdkI3RSxnQkFBZ0J2SCxNQUFNLENBQUNvTTtZQUN6QjtRQUNGO1FBQ0EsT0FBT3VFO0lBQ1Q7SUFDQSx5RUFBeUU7SUFDekUsNENBQTRDO0lBQzVDLFNBQVNFLHdCQUF3QkMsU0FBUyxFQUFFQyxXQUFXLEVBQUVDLE1BQU07UUFDN0R0TSx1QkFBdUJvTTtRQUN2QmxNLG9CQUFvQm1NO1FBQ3BCcE0sMEJBQTBCcU0sVUFBVTtRQUNwQywwRUFBMEU7UUFDMUUsZ0ZBQWdGO1FBQ2hGLHVEQUF1RDtRQUN2RCxJQUFJLENBQUNuTSx5QkFBeUJ2VixNQUFNdVcsVUFBVSxLQUFLaEQsaUJBQWlCO1lBQ2xFZ0Msd0JBQXdCO1lBQ3hCLElBQUlvTSxJQUFJcEgsdUJBQXVCdmEsTUFBTVksUUFBUSxFQUFFWixNQUFNb0gsT0FBTztZQUM1RCxJQUFJdWEsS0FBSyxNQUFNO2dCQUNibEosWUFBWTtvQkFDVmpDLHVCQUF1Qm1MO2dCQUN6QjtZQUNGO1FBQ0Y7UUFDQSxPQUFPO1lBQ0x2TSx1QkFBdUI7WUFDdkJFLG9CQUFvQjtZQUNwQkQsMEJBQTBCO1FBQzVCO0lBQ0Y7SUFDQSxTQUFTdU0sYUFBYWhoQixRQUFRLEVBQUV3RyxPQUFPO1FBQ3JDLElBQUlpTyx5QkFBeUI7WUFDM0IsSUFBSXRXLE1BQU1zVyx3QkFBd0J6VSxVQUFVd0csUUFBUXhILEdBQUcsQ0FBQ21XLENBQUFBLElBQUt4TywyQkFBMkJ3TyxHQUFHL1YsTUFBTXlILFVBQVU7WUFDM0csT0FBTzFJLE9BQU82QixTQUFTN0IsR0FBRztRQUM1QjtRQUNBLE9BQU82QixTQUFTN0IsR0FBRztJQUNyQjtJQUNBLFNBQVN3YyxtQkFBbUIzYSxRQUFRLEVBQUV3RyxPQUFPO1FBQzNDLElBQUlnTyx3QkFBd0JFLG1CQUFtQjtZQUM3QyxJQUFJdlcsTUFBTTZpQixhQUFhaGhCLFVBQVV3RztZQUNqQ2dPLG9CQUFvQixDQUFDclcsSUFBSSxHQUFHdVc7UUFDOUI7SUFDRjtJQUNBLFNBQVNpRix1QkFBdUIzWixRQUFRLEVBQUV3RyxPQUFPO1FBQy9DLElBQUlnTyxzQkFBc0I7WUFDeEIsSUFBSXJXLE1BQU02aUIsYUFBYWhoQixVQUFVd0c7WUFDakMsSUFBSXVhLElBQUl2TSxvQkFBb0IsQ0FBQ3JXLElBQUk7WUFDakMsSUFBSSxPQUFPNGlCLE1BQU0sVUFBVTtnQkFDekIsT0FBT0E7WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBU0UsbUJBQW1CQyxTQUFTO1FBQ25DeGIsV0FBVyxDQUFDO1FBQ1p1TyxxQkFBcUIzTywwQkFBMEI0YixXQUFXMWIsb0JBQW9CbkcsV0FBV3FHO0lBQzNGO0lBQ0ErUCxTQUFTO1FBQ1AsSUFBSXRQLFlBQVc7WUFDYixPQUFPQTtRQUNUO1FBQ0EsSUFBSStOLFVBQVM7WUFDWCxPQUFPQTtRQUNUO1FBQ0EsSUFBSTlVLFNBQVE7WUFDVixPQUFPQTtRQUNUO1FBQ0EsSUFBSW1HLFVBQVM7WUFDWCxPQUFPeU87UUFDVDtRQUNBLElBQUlsUyxVQUFTO1lBQ1gsT0FBTzZSO1FBQ1Q7UUFDQTZEO1FBQ0FuSDtRQUNBc1E7UUFDQS9HO1FBQ0FxRTtRQUNBMUQ7UUFDQSwyRUFBMkU7UUFDM0UsK0JBQStCO1FBQy9CaGEsWUFBWVIsQ0FBQUEsS0FBTW1PLEtBQUt6TixPQUFPLENBQUNGLFVBQVUsQ0FBQ1I7UUFDMUNhLGdCQUFnQmIsQ0FBQUEsS0FBTW1PLEtBQUt6TixPQUFPLENBQUNHLGNBQWMsQ0FBQ2I7UUFDbEQ4ZjtRQUNBeEgsZUFBZXlIO1FBQ2YzSDtRQUNBaUk7UUFDQTlIO1FBQ0E2SSwyQkFBMkJ0SztRQUMzQnVLLDBCQUEwQi9KO1FBQzFCLCtEQUErRDtRQUMvRCwyREFBMkQ7UUFDM0Q0SjtJQUNGO0lBQ0EsT0FBT3hMO0FBQ1Q7QUFDQSxZQUFZO0FBQ1osZ0ZBQWdGO0FBQ2hGLDZCQUE2QjtBQUM3QixnRkFBZ0Y7QUFDaEYsTUFBTTRMLHlCQUF5QkMsT0FBTztBQUN0QyxTQUFTQyxvQkFBb0JoYyxNQUFNLEVBQUVpVCxJQUFJO0lBQ3ZDdFYsVUFBVXFDLE9BQU90SCxNQUFNLEdBQUcsR0FBRztJQUM3QixJQUFJeUgsV0FBVyxDQUFDO0lBQ2hCLElBQUlTLFdBQVcsQ0FBQ3FTLE9BQU9BLEtBQUtyUyxRQUFRLEdBQUcsSUFBRyxLQUFNO0lBQ2hELElBQUlYO0lBQ0osSUFBSWdULFFBQVEsUUFBUUEsS0FBS2hULGtCQUFrQixFQUFFO1FBQzNDQSxxQkFBcUJnVCxLQUFLaFQsa0JBQWtCO0lBQzlDLE9BQU8sSUFBSWdULFFBQVEsUUFBUUEsS0FBS3pFLG1CQUFtQixFQUFFO1FBQ25ELDJFQUEyRTtRQUMzRSxJQUFJQSxzQkFBc0J5RSxLQUFLekUsbUJBQW1CO1FBQ2xEdk8scUJBQXFCSCxDQUFBQSxRQUFVO2dCQUM3QmtPLGtCQUFrQlEsb0JBQW9CMU87WUFDeEM7SUFDRixPQUFPO1FBQ0xHLHFCQUFxQjhOO0lBQ3ZCO0lBQ0EsK0JBQStCO0lBQy9CLElBQUlZLFNBQVN4VyxTQUFTO1FBQ3BCdVAsc0JBQXNCO0lBQ3hCLEdBQUd1TCxPQUFPQSxLQUFLdEUsTUFBTSxHQUFHO0lBQ3hCLElBQUlGLGFBQWExTywwQkFBMEJDLFFBQVFDLG9CQUFvQm5HLFdBQVdxRztJQUNsRjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JDLEdBQ0QsZUFBZThiLE1BQU12RyxPQUFPLEVBQUV3RyxNQUFNO1FBQ2xDLElBQUksRUFDRkMsY0FBYyxFQUNmLEdBQUdELFdBQVcsS0FBSyxJQUFJLENBQUMsSUFBSUE7UUFDN0IsSUFBSTVlLE1BQU0sSUFBSWxDLElBQUlzYSxRQUFRcFksR0FBRztRQUM3QixJQUFJb1osU0FBU2hCLFFBQVFnQixNQUFNO1FBQzNCLElBQUlqYyxXQUFXQyxlQUFlLElBQUlPLFdBQVdxQyxNQUFNLE1BQU07UUFDekQsSUFBSTJELFVBQVVQLFlBQVkrTixZQUFZaFUsVUFBVW1HO1FBQ2hELCtDQUErQztRQUMvQyxJQUFJLENBQUN3YixjQUFjMUYsV0FBV0EsV0FBVyxRQUFRO1lBQy9DLElBQUl0WCxRQUFRb1EsdUJBQXVCLEtBQUs7Z0JBQ3RDa0g7WUFDRjtZQUNBLElBQUksRUFDRnpWLFNBQVNvYix1QkFBdUIsRUFDaEN2YyxLQUFLLEVBQ04sR0FBRzJQLHVCQUF1QmhCO1lBQzNCLE9BQU87Z0JBQ0w3TjtnQkFDQW5HO2dCQUNBd0csU0FBU29iO2dCQUNUL2EsWUFBWSxDQUFDO2dCQUNia1AsWUFBWTtnQkFDWlIsUUFBUTtvQkFDTixDQUFDbFEsTUFBTU8sRUFBRSxDQUFDLEVBQUVqQjtnQkFDZDtnQkFDQWtkLFlBQVlsZCxNQUFNeUosTUFBTTtnQkFDeEIwVCxlQUFlLENBQUM7Z0JBQ2hCQyxlQUFlLENBQUM7Z0JBQ2hCMUssaUJBQWlCO1lBQ25CO1FBQ0YsT0FBTyxJQUFJLENBQUM3USxTQUFTO1lBQ25CLElBQUk3QixRQUFRb1EsdUJBQXVCLEtBQUs7Z0JBQ3RDN1UsVUFBVUYsU0FBU0UsUUFBUTtZQUM3QjtZQUNBLElBQUksRUFDRnNHLFNBQVNzVSxlQUFlLEVBQ3hCelYsS0FBSyxFQUNOLEdBQUcyUCx1QkFBdUJoQjtZQUMzQixPQUFPO2dCQUNMN047Z0JBQ0FuRztnQkFDQXdHLFNBQVNzVTtnQkFDVGpVLFlBQVksQ0FBQztnQkFDYmtQLFlBQVk7Z0JBQ1pSLFFBQVE7b0JBQ04sQ0FBQ2xRLE1BQU1PLEVBQUUsQ0FBQyxFQUFFakI7Z0JBQ2Q7Z0JBQ0FrZCxZQUFZbGQsTUFBTXlKLE1BQU07Z0JBQ3hCMFQsZUFBZSxDQUFDO2dCQUNoQkMsZUFBZSxDQUFDO2dCQUNoQjFLLGlCQUFpQjtZQUNuQjtRQUNGO1FBQ0EsSUFBSTVPLFNBQVMsTUFBTXVaLFVBQVUvRyxTQUFTamIsVUFBVXdHLFNBQVNrYjtRQUN6RCxJQUFJTyxXQUFXeFosU0FBUztZQUN0QixPQUFPQTtRQUNUO1FBQ0EsMEVBQTBFO1FBQzFFLDBFQUEwRTtRQUMxRSw2REFBNkQ7UUFDN0QsT0FBTy9LLFNBQVM7WUFDZHNDO1lBQ0FtRztRQUNGLEdBQUdzQztJQUNMO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkMsR0FDRCxlQUFleVosV0FBV2pILE9BQU8sRUFBRWtILE1BQU07UUFDdkMsSUFBSSxFQUNGakcsT0FBTyxFQUNQd0YsY0FBYyxFQUNmLEdBQUdTLFdBQVcsS0FBSyxJQUFJLENBQUMsSUFBSUE7UUFDN0IsSUFBSXRmLE1BQU0sSUFBSWxDLElBQUlzYSxRQUFRcFksR0FBRztRQUM3QixJQUFJb1osU0FBU2hCLFFBQVFnQixNQUFNO1FBQzNCLElBQUlqYyxXQUFXQyxlQUFlLElBQUlPLFdBQVdxQyxNQUFNLE1BQU07UUFDekQsSUFBSTJELFVBQVVQLFlBQVkrTixZQUFZaFUsVUFBVW1HO1FBQ2hELCtDQUErQztRQUMvQyxJQUFJLENBQUN3YixjQUFjMUYsV0FBV0EsV0FBVyxVQUFVQSxXQUFXLFdBQVc7WUFDdkUsTUFBTWxILHVCQUF1QixLQUFLO2dCQUNoQ2tIO1lBQ0Y7UUFDRixPQUFPLElBQUksQ0FBQ3pWLFNBQVM7WUFDbkIsTUFBTXVPLHVCQUF1QixLQUFLO2dCQUNoQzdVLFVBQVVGLFNBQVNFLFFBQVE7WUFDN0I7UUFDRjtRQUNBLElBQUkwRyxRQUFRc1YsVUFBVTFWLFFBQVE0YixJQUFJLENBQUNqTixDQUFBQSxJQUFLQSxFQUFFOVAsS0FBSyxDQUFDTyxFQUFFLEtBQUtzVyxXQUFXSCxlQUFldlYsU0FBU3hHO1FBQzFGLElBQUlrYyxXQUFXLENBQUN0VixPQUFPO1lBQ3JCLE1BQU1tTyx1QkFBdUIsS0FBSztnQkFDaEM3VSxVQUFVRixTQUFTRSxRQUFRO2dCQUMzQmdjO1lBQ0Y7UUFDRixPQUFPLElBQUksQ0FBQ3RWLE9BQU87WUFDakIsdUNBQXVDO1lBQ3ZDLE1BQU1tTyx1QkFBdUIsS0FBSztnQkFDaEM3VSxVQUFVRixTQUFTRSxRQUFRO1lBQzdCO1FBQ0Y7UUFDQSxJQUFJdUksU0FBUyxNQUFNdVosVUFBVS9HLFNBQVNqYixVQUFVd0csU0FBU2tiLGdCQUFnQjlhO1FBQ3pFLElBQUlxYixXQUFXeFosU0FBUztZQUN0QixPQUFPQTtRQUNUO1FBQ0EsSUFBSTlELFFBQVE4RCxPQUFPOE0sTUFBTSxHQUFHNVgsT0FBTzBrQixNQUFNLENBQUM1WixPQUFPOE0sTUFBTSxDQUFDLENBQUMsRUFBRSxHQUFHbFc7UUFDOUQsSUFBSXNGLFVBQVV0RixXQUFXO1lBQ3ZCLG1FQUFtRTtZQUNuRSx1RUFBdUU7WUFDdkUsc0VBQXNFO1lBQ3RFLG1EQUFtRDtZQUNuRCxNQUFNc0Y7UUFDUjtRQUNBLDJDQUEyQztRQUMzQyxJQUFJOEQsT0FBT3NOLFVBQVUsRUFBRTtZQUNyQixPQUFPcFksT0FBTzBrQixNQUFNLENBQUM1WixPQUFPc04sVUFBVSxDQUFDLENBQUMsRUFBRTtRQUM1QztRQUNBLElBQUl0TixPQUFPNUIsVUFBVSxFQUFFO1lBQ3JCLElBQUl5YjtZQUNKLElBQUl2YixPQUFPcEosT0FBTzBrQixNQUFNLENBQUM1WixPQUFPNUIsVUFBVSxDQUFDLENBQUMsRUFBRTtZQUM5QyxJQUFJLENBQUN5Yix3QkFBd0I3WixPQUFPNE8sZUFBZSxLQUFLLFFBQVFpTCxxQkFBcUIsQ0FBQzFiLE1BQU12QixLQUFLLENBQUNPLEVBQUUsQ0FBQyxFQUFFO2dCQUNyR21CLElBQUksQ0FBQ3NhLHVCQUF1QixHQUFHNVksT0FBTzRPLGVBQWUsQ0FBQ3pRLE1BQU12QixLQUFLLENBQUNPLEVBQUUsQ0FBQztZQUN2RTtZQUNBLE9BQU9tQjtRQUNUO1FBQ0EsT0FBTzFIO0lBQ1Q7SUFDQSxlQUFlMmlCLFVBQVUvRyxPQUFPLEVBQUVqYixRQUFRLEVBQUV3RyxPQUFPLEVBQUVrYixjQUFjLEVBQUVhLFVBQVU7UUFDN0VyZixVQUFVK1gsUUFBUXZMLE1BQU0sRUFBRTtRQUMxQixJQUFJO1lBQ0YsSUFBSTJKLGlCQUFpQjRCLFFBQVFnQixNQUFNLENBQUNqUSxXQUFXLEtBQUs7Z0JBQ2xELElBQUl2RCxTQUFTLE1BQU0rWixPQUFPdkgsU0FBU3pVLFNBQVMrYixjQUFjeEcsZUFBZXZWLFNBQVN4RyxXQUFXMGhCLGdCQUFnQmEsY0FBYztnQkFDM0gsT0FBTzlaO1lBQ1Q7WUFDQSxJQUFJQSxTQUFTLE1BQU1nYSxjQUFjeEgsU0FBU3pVLFNBQVNrYixnQkFBZ0JhO1lBQ25FLE9BQU9OLFdBQVd4WixVQUFVQSxTQUFTL0ssU0FBUyxDQUFDLEdBQUcrSyxRQUFRO2dCQUN4RHNOLFlBQVk7Z0JBQ1pnTSxlQUFlLENBQUM7WUFDbEI7UUFDRixFQUFFLE9BQU90ZSxHQUFHO1lBQ1Ysd0VBQXdFO1lBQ3hFLHlFQUF5RTtZQUN6RSxvQkFBb0I7WUFDcEIsSUFBSWlmLHFCQUFxQmpmLElBQUk7Z0JBQzNCLElBQUlBLEVBQUV1WSxJQUFJLEtBQUsvVyxXQUFXTixLQUFLLEVBQUU7b0JBQy9CLE1BQU1sQixFQUFFdU8sUUFBUTtnQkFDbEI7Z0JBQ0EsT0FBT3ZPLEVBQUV1TyxRQUFRO1lBQ25CO1lBQ0Esb0VBQW9FO1lBQ3BFLGFBQWE7WUFDYixJQUFJMlEsbUJBQW1CbGYsSUFBSTtnQkFDekIsT0FBT0E7WUFDVDtZQUNBLE1BQU1BO1FBQ1I7SUFDRjtJQUNBLGVBQWUrZSxPQUFPdkgsT0FBTyxFQUFFelUsT0FBTyxFQUFFc1YsV0FBVyxFQUFFNEYsY0FBYyxFQUFFa0IsY0FBYztRQUNqRixJQUFJbmE7UUFDSixJQUFJLENBQUNxVCxZQUFZelcsS0FBSyxDQUFDOUYsTUFBTSxJQUFJLENBQUN1YyxZQUFZelcsS0FBSyxDQUFDK1AsSUFBSSxFQUFFO1lBQ3hELElBQUl6USxRQUFRb1EsdUJBQXVCLEtBQUs7Z0JBQ3RDa0gsUUFBUWhCLFFBQVFnQixNQUFNO2dCQUN0Qi9iLFVBQVUsSUFBSVMsSUFBSXNhLFFBQVFwWSxHQUFHLEVBQUUzQyxRQUFRO2dCQUN2Q2djLFNBQVNKLFlBQVl6VyxLQUFLLENBQUNPLEVBQUU7WUFDL0I7WUFDQSxJQUFJZ2QsZ0JBQWdCO2dCQUNsQixNQUFNamU7WUFDUjtZQUNBOEQsU0FBUztnQkFDUHVULE1BQU0vVyxXQUFXTixLQUFLO2dCQUN0QkE7WUFDRjtRQUNGLE9BQU87WUFDTDhELFNBQVMsTUFBTTBULG1CQUFtQixVQUFVbEIsU0FBU2EsYUFBYXRWLFNBQVNkLFVBQVVGLG9CQUFvQlcsVUFBVStOLE9BQU9qSCxvQkFBb0IsRUFBRTtnQkFDOUk0VixpQkFBaUI7Z0JBQ2pCRDtnQkFDQWxCO1lBQ0Y7WUFDQSxJQUFJekcsUUFBUXZMLE1BQU0sQ0FBQ0MsT0FBTyxFQUFFO2dCQUMxQixJQUFJc00sU0FBUzJHLGlCQUFpQixlQUFlO2dCQUM3QyxNQUFNLElBQUl2ZixNQUFNNFksU0FBUyxzQkFBc0JoQixRQUFRZ0IsTUFBTSxHQUFHLE1BQU1oQixRQUFRcFksR0FBRztZQUNuRjtRQUNGO1FBQ0EsSUFBSXVaLGlCQUFpQjNULFNBQVM7WUFDNUIsc0VBQXNFO1lBQ3RFLHdFQUF3RTtZQUN4RSx1RUFBdUU7WUFDdkUsc0JBQXNCO1lBQ3RCLE1BQU0sSUFBSWdHLFNBQVMsTUFBTTtnQkFDdkJMLFFBQVEzRixPQUFPMkYsTUFBTTtnQkFDckJDLFNBQVM7b0JBQ1B5VSxVQUFVcmEsT0FBT3pJLFFBQVE7Z0JBQzNCO1lBQ0Y7UUFDRjtRQUNBLElBQUl3YyxpQkFBaUIvVCxTQUFTO1lBQzVCLElBQUk5RCxRQUFRb1EsdUJBQXVCLEtBQUs7Z0JBQ3RDaUgsTUFBTTtZQUNSO1lBQ0EsSUFBSTRHLGdCQUFnQjtnQkFDbEIsTUFBTWplO1lBQ1I7WUFDQThELFNBQVM7Z0JBQ1B1VCxNQUFNL1csV0FBV04sS0FBSztnQkFDdEJBO1lBQ0Y7UUFDRjtRQUNBLElBQUlpZSxnQkFBZ0I7WUFDbEIsc0VBQXNFO1lBQ3RFLDBFQUEwRTtZQUMxRSxJQUFJdEcsY0FBYzdULFNBQVM7Z0JBQ3pCLE1BQU1BLE9BQU85RCxLQUFLO1lBQ3BCO1lBQ0EsT0FBTztnQkFDTDZCLFNBQVM7b0JBQUNzVjtpQkFBWTtnQkFDdEJqVixZQUFZLENBQUM7Z0JBQ2JrUCxZQUFZO29CQUNWLENBQUMrRixZQUFZelcsS0FBSyxDQUFDTyxFQUFFLENBQUMsRUFBRTZDLE9BQU8xQixJQUFJO2dCQUNyQztnQkFDQXdPLFFBQVE7Z0JBQ1IsbUVBQW1FO2dCQUNuRSxtQ0FBbUM7Z0JBQ25Dc00sWUFBWTtnQkFDWkMsZUFBZSxDQUFDO2dCQUNoQkMsZUFBZSxDQUFDO2dCQUNoQjFLLGlCQUFpQjtZQUNuQjtRQUNGO1FBQ0EsSUFBSWlGLGNBQWM3VCxTQUFTO1lBQ3pCLHFFQUFxRTtZQUNyRSw2REFBNkQ7WUFDN0QsSUFBSThULGdCQUFnQm5CLG9CQUFvQjVVLFNBQVNzVixZQUFZelcsS0FBSyxDQUFDTyxFQUFFO1lBQ3JFLElBQUltZCxVQUFVLE1BQU1OLGNBQWN4SCxTQUFTelUsU0FBU2tiLGdCQUFnQnJpQixXQUFXO2dCQUM3RSxDQUFDa2QsY0FBY2xYLEtBQUssQ0FBQ08sRUFBRSxDQUFDLEVBQUU2QyxPQUFPOUQsS0FBSztZQUN4QztZQUNBLCtEQUErRDtZQUMvRCxPQUFPakgsU0FBUyxDQUFDLEdBQUdxbEIsU0FBUztnQkFDM0JsQixZQUFZelAscUJBQXFCM0osT0FBTzlELEtBQUssSUFBSThELE9BQU85RCxLQUFLLENBQUN5SixNQUFNLEdBQUc7Z0JBQ3ZFMkgsWUFBWTtnQkFDWmdNLGVBQWVya0IsU0FBUyxDQUFDLEdBQUcrSyxPQUFPNEYsT0FBTyxHQUFHO29CQUMzQyxDQUFDeU4sWUFBWXpXLEtBQUssQ0FBQ08sRUFBRSxDQUFDLEVBQUU2QyxPQUFPNEYsT0FBTztnQkFDeEMsSUFBSSxDQUFDO1lBQ1A7UUFDRjtRQUNBLHVDQUF1QztRQUN2QyxJQUFJMlUsZ0JBQWdCLElBQUl0SCxRQUFRVCxRQUFRcFksR0FBRyxFQUFFO1lBQzNDd0wsU0FBUzRNLFFBQVE1TSxPQUFPO1lBQ3hCeUQsVUFBVW1KLFFBQVFuSixRQUFRO1lBQzFCcEMsUUFBUXVMLFFBQVF2TCxNQUFNO1FBQ3hCO1FBQ0EsSUFBSXFULFVBQVUsTUFBTU4sY0FBY08sZUFBZXhjLFNBQVNrYjtRQUMxRCxPQUFPaGtCLFNBQVMsQ0FBQyxHQUFHcWxCLFNBQVN0YSxPQUFPb1osVUFBVSxHQUFHO1lBQy9DQSxZQUFZcFosT0FBT29aLFVBQVU7UUFDL0IsSUFBSSxDQUFDLEdBQUc7WUFDTjlMLFlBQVk7Z0JBQ1YsQ0FBQytGLFlBQVl6VyxLQUFLLENBQUNPLEVBQUUsQ0FBQyxFQUFFNkMsT0FBTzFCLElBQUk7WUFDckM7WUFDQWdiLGVBQWVya0IsU0FBUyxDQUFDLEdBQUcrSyxPQUFPNEYsT0FBTyxHQUFHO2dCQUMzQyxDQUFDeU4sWUFBWXpXLEtBQUssQ0FBQ08sRUFBRSxDQUFDLEVBQUU2QyxPQUFPNEYsT0FBTztZQUN4QyxJQUFJLENBQUM7UUFDUDtJQUNGO0lBQ0EsZUFBZW9VLGNBQWN4SCxPQUFPLEVBQUV6VSxPQUFPLEVBQUVrYixjQUFjLEVBQUVhLFVBQVUsRUFBRS9HLGtCQUFrQjtRQUMzRixJQUFJb0gsaUJBQWlCTCxjQUFjO1FBQ25DLDREQUE0RDtRQUM1RCxJQUFJSyxrQkFBa0IsQ0FBRUwsQ0FBQUEsY0FBYyxRQUFRQSxXQUFXbGQsS0FBSyxDQUFDaVEsTUFBTSxLQUFLLENBQUVpTixDQUFBQSxjQUFjLFFBQVFBLFdBQVdsZCxLQUFLLENBQUMrUCxJQUFJLEdBQUc7WUFDeEgsTUFBTUwsdUJBQXVCLEtBQUs7Z0JBQ2hDa0gsUUFBUWhCLFFBQVFnQixNQUFNO2dCQUN0Qi9iLFVBQVUsSUFBSVMsSUFBSXNhLFFBQVFwWSxHQUFHLEVBQUUzQyxRQUFRO2dCQUN2Q2djLFNBQVNxRyxjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXbGQsS0FBSyxDQUFDTyxFQUFFO1lBQzVEO1FBQ0Y7UUFDQSxJQUFJeVksaUJBQWlCa0UsYUFBYTtZQUFDQTtTQUFXLEdBQUdVLDhCQUE4QnpjLFNBQVM3SSxPQUFPNGIsSUFBSSxDQUFDaUMsc0JBQXNCLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDaEksSUFBSW1CLGdCQUFnQjBCLGVBQWU1VSxNQUFNLENBQUMwTCxDQUFBQSxJQUFLQSxFQUFFOVAsS0FBSyxDQUFDaVEsTUFBTSxJQUFJSCxFQUFFOVAsS0FBSyxDQUFDK1AsSUFBSTtRQUM3RSx1REFBdUQ7UUFDdkQsSUFBSXVILGNBQWMxZSxNQUFNLEtBQUssR0FBRztZQUM5QixPQUFPO2dCQUNMdUk7Z0JBQ0EsMEVBQTBFO2dCQUMxRUssWUFBWUwsUUFBUWtELE1BQU0sQ0FBQyxDQUFDcUgsS0FBS29FLElBQU14WCxPQUFPQyxNQUFNLENBQUNtVCxLQUFLO3dCQUN4RCxDQUFDb0UsRUFBRTlQLEtBQUssQ0FBQ08sRUFBRSxDQUFDLEVBQUU7b0JBQ2hCLElBQUksQ0FBQztnQkFDTDJQLFFBQVFpRyxzQkFBc0I7Z0JBQzlCcUcsWUFBWTtnQkFDWkMsZUFBZSxDQUFDO2dCQUNoQnpLLGlCQUFpQjtZQUNuQjtRQUNGO1FBQ0EsSUFBSWlHLFVBQVUsTUFBTXpPLFFBQVE4USxHQUFHLENBQUM7ZUFBSWhELGNBQWMzZCxHQUFHLENBQUM0SCxDQUFBQSxRQUFTdVYsbUJBQW1CLFVBQVVsQixTQUFTclUsT0FBT0osU0FBU2QsVUFBVUYsb0JBQW9CVyxVQUFVK04sT0FBT2pILG9CQUFvQixFQUFFO29CQUN4TDRWLGlCQUFpQjtvQkFDakJEO29CQUNBbEI7Z0JBQ0Y7U0FBSTtRQUNKLElBQUl6RyxRQUFRdkwsTUFBTSxDQUFDQyxPQUFPLEVBQUU7WUFDMUIsSUFBSXNNLFNBQVMyRyxpQkFBaUIsZUFBZTtZQUM3QyxNQUFNLElBQUl2ZixNQUFNNFksU0FBUyxzQkFBc0JoQixRQUFRZ0IsTUFBTSxHQUFHLE1BQU1oQixRQUFRcFksR0FBRztRQUNuRjtRQUNBLHlDQUF5QztRQUN6QyxJQUFJd1Usa0JBQWtCLElBQUlwQjtRQUMxQixJQUFJOE0sVUFBVUcsdUJBQXVCMWMsU0FBU21XLGVBQWVXLFNBQVM5QixvQkFBb0JuRTtRQUMxRiw4RUFBOEU7UUFDOUUsSUFBSThMLGtCQUFrQixJQUFJaGUsSUFBSXdYLGNBQWMzZCxHQUFHLENBQUM0SCxDQUFBQSxRQUFTQSxNQUFNdkIsS0FBSyxDQUFDTyxFQUFFO1FBQ3ZFWSxRQUFRb0IsT0FBTyxDQUFDaEIsQ0FBQUE7WUFDZCxJQUFJLENBQUN1YyxnQkFBZ0I1VSxHQUFHLENBQUMzSCxNQUFNdkIsS0FBSyxDQUFDTyxFQUFFLEdBQUc7Z0JBQ3hDbWQsUUFBUWxjLFVBQVUsQ0FBQ0QsTUFBTXZCLEtBQUssQ0FBQ08sRUFBRSxDQUFDLEdBQUc7WUFDdkM7UUFDRjtRQUNBLE9BQU9sSSxTQUFTLENBQUMsR0FBR3FsQixTQUFTO1lBQzNCdmM7WUFDQTZRLGlCQUFpQkEsZ0JBQWdCeEcsSUFBSSxHQUFHLElBQUlsVCxPQUFPeWxCLFdBQVcsQ0FBQy9MLGdCQUFnQnRZLE9BQU8sTUFBTTtRQUM5RjtJQUNGO0lBQ0EsT0FBTztRQUNMaVY7UUFDQXdOO1FBQ0FVO0lBQ0Y7QUFDRjtBQUNBLFlBQVk7QUFDWixnRkFBZ0Y7QUFDaEYsaUJBQWlCO0FBQ2pCLGdGQUFnRjtBQUNoRjs7O0NBR0MsR0FDRCxTQUFTbUIsMEJBQTBCOWQsTUFBTSxFQUFFd2QsT0FBTyxFQUFFcGUsS0FBSztJQUN2RCxJQUFJMmUsYUFBYTVsQixTQUFTLENBQUMsR0FBR3FsQixTQUFTO1FBQ3JDbEIsWUFBWTtRQUNadE0sUUFBUTtZQUNOLENBQUN3TixRQUFRUSwwQkFBMEIsSUFBSWhlLE1BQU0sQ0FBQyxFQUFFLENBQUNLLEVBQUUsQ0FBQyxFQUFFakI7UUFDeEQ7SUFDRjtJQUNBLE9BQU8yZTtBQUNUO0FBQ0EsU0FBU0UsdUJBQXVCaEwsSUFBSTtJQUNsQyxPQUFPQSxRQUFRLFFBQVMsZUFBY0EsUUFBUUEsS0FBS3pGLFFBQVEsSUFBSSxRQUFRLFVBQVV5RixRQUFRQSxLQUFLaUwsSUFBSSxLQUFLcGtCLFNBQVE7QUFDakg7QUFDQSxTQUFTeWEsWUFBWTlaLFFBQVEsRUFBRXdHLE9BQU8sRUFBRUwsUUFBUSxFQUFFdWQsZUFBZSxFQUFFM2pCLEVBQUUsRUFBRWtOLG9CQUFvQixFQUFFOE0sV0FBVyxFQUFFQyxRQUFRO0lBQ2hILElBQUkySjtJQUNKLElBQUlDO0lBQ0osSUFBSTdKLGFBQWE7UUFDZixzRUFBc0U7UUFDdEUsdUNBQXVDO1FBQ3ZDNEosb0JBQW9CLEVBQUU7UUFDdEIsS0FBSyxJQUFJL2MsU0FBU0osUUFBUztZQUN6Qm1kLGtCQUFrQjFpQixJQUFJLENBQUMyRjtZQUN2QixJQUFJQSxNQUFNdkIsS0FBSyxDQUFDTyxFQUFFLEtBQUttVSxhQUFhO2dCQUNsQzZKLG1CQUFtQmhkO2dCQUNuQjtZQUNGO1FBQ0Y7SUFDRixPQUFPO1FBQ0wrYyxvQkFBb0JuZDtRQUNwQm9kLG1CQUFtQnBkLE9BQU8sQ0FBQ0EsUUFBUXZJLE1BQU0sR0FBRyxFQUFFO0lBQ2hEO0lBQ0EsNEJBQTRCO0lBQzVCLElBQUk0QyxPQUFPc00sVUFBVXBOLEtBQUtBLEtBQUssS0FBS2lOLG9CQUFvQjJXLG1CQUFtQjFXLHVCQUF1QjdHLGNBQWNwRyxTQUFTRSxRQUFRLEVBQUVpRyxhQUFhbkcsU0FBU0UsUUFBUSxFQUFFOFosYUFBYTtJQUNoTCxxRUFBcUU7SUFDckUsNkRBQTZEO0lBQzdELG9EQUFvRDtJQUNwRCxJQUFJamEsTUFBTSxNQUFNO1FBQ2RjLEtBQUtFLE1BQU0sR0FBR2YsU0FBU2UsTUFBTTtRQUM3QkYsS0FBS0csSUFBSSxHQUFHaEIsU0FBU2dCLElBQUk7SUFDM0I7SUFDQSw0RUFBNEU7SUFDNUUsSUFBSSxDQUFDakIsTUFBTSxRQUFRQSxPQUFPLE1BQU1BLE9BQU8sR0FBRSxLQUFNNmpCLG9CQUFvQkEsaUJBQWlCdmUsS0FBSyxDQUFDbkcsS0FBSyxJQUFJLENBQUMya0IsbUJBQW1CaGpCLEtBQUtFLE1BQU0sR0FBRztRQUNuSUYsS0FBS0UsTUFBTSxHQUFHRixLQUFLRSxNQUFNLEdBQUdGLEtBQUtFLE1BQU0sQ0FBQ08sT0FBTyxDQUFDLE9BQU8sYUFBYTtJQUN0RTtJQUNBLHdFQUF3RTtJQUN4RSx5RUFBeUU7SUFDekUsMEVBQTBFO0lBQzFFLGtCQUFrQjtJQUNsQixJQUFJb2lCLG1CQUFtQnZkLGFBQWEsS0FBSztRQUN2Q3RGLEtBQUtYLFFBQVEsR0FBR1csS0FBS1gsUUFBUSxLQUFLLE1BQU1pRyxXQUFXb0IsVUFBVTtZQUFDcEI7WUFBVXRGLEtBQUtYLFFBQVE7U0FBQztJQUN4RjtJQUNBLE9BQU9NLFdBQVdLO0FBQ3BCO0FBQ0EsZ0ZBQWdGO0FBQ2hGLHdFQUF3RTtBQUN4RSxTQUFTcVoseUJBQXlCNEosbUJBQW1CLEVBQUVDLFNBQVMsRUFBRWxqQixJQUFJLEVBQUUyWCxJQUFJO0lBQzFFLHlEQUF5RDtJQUN6RCxJQUFJLENBQUNBLFFBQVEsQ0FBQ2dMLHVCQUF1QmhMLE9BQU87UUFDMUMsT0FBTztZQUNMM1g7UUFDRjtJQUNGO0lBQ0EsSUFBSTJYLEtBQUs1RixVQUFVLElBQUksQ0FBQytPLGNBQWNuSixLQUFLNUYsVUFBVSxHQUFHO1FBQ3RELE9BQU87WUFDTC9SO1lBQ0E4RCxPQUFPb1EsdUJBQXVCLEtBQUs7Z0JBQ2pDa0gsUUFBUXpELEtBQUs1RixVQUFVO1lBQ3pCO1FBQ0Y7SUFDRjtJQUNBLElBQUlvUixzQkFBc0IsSUFBTztZQUMvQm5qQjtZQUNBOEQsT0FBT29RLHVCQUF1QixLQUFLO2dCQUNqQ2lILE1BQU07WUFDUjtRQUNGO0lBQ0EsNkNBQTZDO0lBQzdDLElBQUlpSSxnQkFBZ0J6TCxLQUFLNUYsVUFBVSxJQUFJO0lBQ3ZDLElBQUlBLGFBQWFrUixzQkFBc0JHLGNBQWNDLFdBQVcsS0FBS0QsY0FBY2pZLFdBQVc7SUFDOUYsSUFBSTZHLGFBQWFzUixrQkFBa0J0akI7SUFDbkMsSUFBSTJYLEtBQUtpTCxJQUFJLEtBQUtwa0IsV0FBVztRQUMzQixJQUFJbVosS0FBSzFGLFdBQVcsS0FBSyxjQUFjO1lBQ3JDLHNEQUFzRDtZQUN0RCxJQUFJLENBQUN1RyxpQkFBaUJ6RyxhQUFhO2dCQUNqQyxPQUFPb1I7WUFDVDtZQUNBLElBQUloUixPQUFPLE9BQU93RixLQUFLaUwsSUFBSSxLQUFLLFdBQVdqTCxLQUFLaUwsSUFBSSxHQUFHakwsS0FBS2lMLElBQUksWUFBWVcsWUFBWTVMLEtBQUtpTCxJQUFJLFlBQVlZLGtCQUM3RywrRkFBK0Y7WUFDL0ZsVCxNQUFNMUQsSUFBSSxDQUFDK0ssS0FBS2lMLElBQUksQ0FBQzFrQixPQUFPLElBQUkySyxNQUFNLENBQUMsQ0FBQ3FILEtBQUtDO2dCQUMzQyxJQUFJLENBQUNuTSxNQUFNMUIsTUFBTSxHQUFHNk47Z0JBQ3BCLE9BQU8sS0FBS0QsTUFBTWxNLE9BQU8sTUFBTTFCLFFBQVE7WUFDekMsR0FBRyxNQUFNd0gsT0FBTzZOLEtBQUtpTCxJQUFJO1lBQ3pCLE9BQU87Z0JBQ0w1aUI7Z0JBQ0FvWixZQUFZO29CQUNWckg7b0JBQ0FDO29CQUNBQyxhQUFhMEYsS0FBSzFGLFdBQVc7b0JBQzdCQyxVQUFVMVQ7b0JBQ1Y0TyxNQUFNNU87b0JBQ04yVDtnQkFDRjtZQUNGO1FBQ0YsT0FBTyxJQUFJd0YsS0FBSzFGLFdBQVcsS0FBSyxvQkFBb0I7WUFDbEQsdURBQXVEO1lBQ3ZELElBQUksQ0FBQ3VHLGlCQUFpQnpHLGFBQWE7Z0JBQ2pDLE9BQU9vUjtZQUNUO1lBQ0EsSUFBSTtnQkFDRixJQUFJL1YsT0FBTyxPQUFPdUssS0FBS2lMLElBQUksS0FBSyxXQUFXcGpCLEtBQUtpa0IsS0FBSyxDQUFDOUwsS0FBS2lMLElBQUksSUFBSWpMLEtBQUtpTCxJQUFJO2dCQUM1RSxPQUFPO29CQUNMNWlCO29CQUNBb1osWUFBWTt3QkFDVnJIO3dCQUNBQzt3QkFDQUMsYUFBYTBGLEtBQUsxRixXQUFXO3dCQUM3QkMsVUFBVTFUO3dCQUNWNE87d0JBQ0ErRSxNQUFNM1Q7b0JBQ1I7Z0JBQ0Y7WUFDRixFQUFFLE9BQU9vRSxHQUFHO2dCQUNWLE9BQU91Z0I7WUFDVDtRQUNGO0lBQ0Y7SUFDQTlnQixVQUFVLE9BQU9raEIsYUFBYSxZQUFZO0lBQzFDLElBQUlHO0lBQ0osSUFBSXhSO0lBQ0osSUFBSXlGLEtBQUt6RixRQUFRLEVBQUU7UUFDakJ3UixlQUFlQyw4QkFBOEJoTSxLQUFLekYsUUFBUTtRQUMxREEsV0FBV3lGLEtBQUt6RixRQUFRO0lBQzFCLE9BQU8sSUFBSXlGLEtBQUtpTCxJQUFJLFlBQVlXLFVBQVU7UUFDeENHLGVBQWVDLDhCQUE4QmhNLEtBQUtpTCxJQUFJO1FBQ3REMVEsV0FBV3lGLEtBQUtpTCxJQUFJO0lBQ3RCLE9BQU8sSUFBSWpMLEtBQUtpTCxJQUFJLFlBQVlZLGlCQUFpQjtRQUMvQ0UsZUFBZS9MLEtBQUtpTCxJQUFJO1FBQ3hCMVEsV0FBVzBSLDhCQUE4QkY7SUFDM0MsT0FBTyxJQUFJL0wsS0FBS2lMLElBQUksSUFBSSxNQUFNO1FBQzVCYyxlQUFlLElBQUlGO1FBQ25CdFIsV0FBVyxJQUFJcVI7SUFDakIsT0FBTztRQUNMLElBQUk7WUFDRkcsZUFBZSxJQUFJRixnQkFBZ0I3TCxLQUFLaUwsSUFBSTtZQUM1QzFRLFdBQVcwUiw4QkFBOEJGO1FBQzNDLEVBQUUsT0FBTzlnQixHQUFHO1lBQ1YsT0FBT3VnQjtRQUNUO0lBQ0Y7SUFDQSxJQUFJL0osYUFBYTtRQUNmckg7UUFDQUM7UUFDQUMsYUFBYTBGLFFBQVFBLEtBQUsxRixXQUFXLElBQUk7UUFDekNDO1FBQ0E5RSxNQUFNNU87UUFDTjJULE1BQU0zVDtJQUNSO0lBQ0EsSUFBSWdhLGlCQUFpQlksV0FBV3JILFVBQVUsR0FBRztRQUMzQyxPQUFPO1lBQ0wvUjtZQUNBb1o7UUFDRjtJQUNGO0lBQ0EsOERBQThEO0lBQzlELElBQUloVyxhQUFhbkQsVUFBVUQ7SUFDM0Isc0VBQXNFO0lBQ3RFLDhFQUE4RTtJQUM5RSw2RUFBNkU7SUFDN0UsSUFBSWtqQixhQUFhOWYsV0FBV2xELE1BQU0sSUFBSThpQixtQkFBbUI1ZixXQUFXbEQsTUFBTSxHQUFHO1FBQzNFd2pCLGFBQWFHLE1BQU0sQ0FBQyxTQUFTO0lBQy9CO0lBQ0F6Z0IsV0FBV2xELE1BQU0sR0FBRyxNQUFNd2pCO0lBQzFCLE9BQU87UUFDTDFqQixNQUFNTCxXQUFXeUQ7UUFDakJnVztJQUNGO0FBQ0Y7QUFDQSx1RUFBdUU7QUFDdkUsdUNBQXVDO0FBQ3ZDLFNBQVNnSiw4QkFBOEJ6YyxPQUFPLEVBQUVtZSxVQUFVO0lBQ3hELElBQUlDLGtCQUFrQnBlO0lBQ3RCLElBQUltZSxZQUFZO1FBQ2QsSUFBSXpsQixRQUFRc0gsUUFBUXFlLFNBQVMsQ0FBQzFQLENBQUFBLElBQUtBLEVBQUU5UCxLQUFLLENBQUNPLEVBQUUsS0FBSytlO1FBQ2xELElBQUl6bEIsU0FBUyxHQUFHO1lBQ2QwbEIsa0JBQWtCcGUsUUFBUXhELEtBQUssQ0FBQyxHQUFHOUQ7UUFDckM7SUFDRjtJQUNBLE9BQU8wbEI7QUFDVDtBQUNBLFNBQVMvSCxpQkFBaUJwYyxPQUFPLEVBQUVyQixLQUFLLEVBQUVvSCxPQUFPLEVBQUV5VCxVQUFVLEVBQUVqYSxRQUFRLEVBQUU4a0IsYUFBYSxFQUFFcE8sc0JBQXNCLEVBQUVDLHVCQUF1QixFQUFFQyxxQkFBcUIsRUFBRVEsZUFBZSxFQUFFRixnQkFBZ0IsRUFBRUQsZ0JBQWdCLEVBQUUyRCxXQUFXLEVBQUV6VSxRQUFRLEVBQUVnVixpQkFBaUIsRUFBRWYsWUFBWTtJQUN6USxJQUFJd0UsZUFBZXhFLGVBQWV6YyxPQUFPMGtCLE1BQU0sQ0FBQ2pJLGFBQWEsQ0FBQyxFQUFFLEdBQUdlLG9CQUFvQnhkLE9BQU8wa0IsTUFBTSxDQUFDbEgsa0JBQWtCLENBQUMsRUFBRSxHQUFHOWI7SUFDN0gsSUFBSTBsQixhQUFhdGtCLFFBQVFDLFNBQVMsQ0FBQ3RCLE1BQU1ZLFFBQVE7SUFDakQsSUFBSWdsQixVQUFVdmtCLFFBQVFDLFNBQVMsQ0FBQ1Y7SUFDaEMsdUVBQXVFO0lBQ3ZFLElBQUkya0IsYUFBYXZLLGVBQWV6YyxPQUFPNGIsSUFBSSxDQUFDYSxhQUFhLENBQUMsRUFBRSxHQUFHL2E7SUFDL0QsSUFBSXVsQixrQkFBa0IzQiw4QkFBOEJ6YyxTQUFTbWU7SUFDN0QsSUFBSU0sb0JBQW9CTCxnQkFBZ0JuYixNQUFNLENBQUMsQ0FBQzdDLE9BQU8xSDtRQUNyRCxJQUFJLEVBQ0ZtRyxLQUFLLEVBQ04sR0FBR3VCO1FBQ0osSUFBSXZCLE1BQU0rUCxJQUFJLEVBQUU7WUFDZCwwRUFBMEU7WUFDMUUsT0FBTztRQUNUO1FBQ0EsSUFBSS9QLE1BQU1pUSxNQUFNLElBQUksTUFBTTtZQUN4QixPQUFPO1FBQ1Q7UUFDQSxJQUFJd1AsZUFBZTtZQUNqQixJQUFJemYsTUFBTWlRLE1BQU0sQ0FBQ0UsT0FBTyxFQUFFO2dCQUN4QixPQUFPO1lBQ1Q7WUFDQSxPQUFPcFcsTUFBTXlILFVBQVUsQ0FBQ3hCLE1BQU1PLEVBQUUsQ0FBQyxLQUFLdkcsYUFDdEMsb0RBQW9EO1lBQ3BELEVBQUNELE1BQU1tVyxNQUFNLElBQUluVyxNQUFNbVcsTUFBTSxDQUFDbFEsTUFBTU8sRUFBRSxDQUFDLEtBQUt2RyxTQUFRO1FBQ3REO1FBQ0EsZ0ZBQWdGO1FBQ2hGLElBQUk2bEIsWUFBWTlsQixNQUFNeUgsVUFBVSxFQUFFekgsTUFBTW9ILE9BQU8sQ0FBQ3RILE1BQU0sRUFBRTBILFVBQVUrUCx3QkFBd0JuTixJQUFJLENBQUM1RCxDQUFBQSxLQUFNQSxPQUFPZ0IsTUFBTXZCLEtBQUssQ0FBQ08sRUFBRSxHQUFHO1lBQzNILE9BQU87UUFDVDtRQUNBLDJFQUEyRTtRQUMzRSx1RUFBdUU7UUFDdkUsd0VBQXdFO1FBQ3hFLCtCQUErQjtRQUMvQixJQUFJdWYsb0JBQW9CL2xCLE1BQU1vSCxPQUFPLENBQUN0SCxNQUFNO1FBQzVDLElBQUlrbUIsaUJBQWlCeGU7UUFDckIsT0FBT3llLHVCQUF1QnplLE9BQU9sSixTQUFTO1lBQzVDcW5CO1lBQ0FPLGVBQWVILGtCQUFrQnJlLE1BQU07WUFDdkNrZTtZQUNBTyxZQUFZSCxlQUFldGUsTUFBTTtRQUNuQyxHQUFHbVQsWUFBWTtZQUNiMkU7WUFDQTRHLHlCQUNBLCtFQUErRTtZQUMvRTlPLDBCQUNBLGdEQUFnRDtZQUNoRHFPLFdBQVc3a0IsUUFBUSxHQUFHNmtCLFdBQVdoa0IsTUFBTSxLQUFLaWtCLFFBQVE5a0IsUUFBUSxHQUFHOGtCLFFBQVFqa0IsTUFBTSxJQUM3RSxtQ0FBbUM7WUFDbkNna0IsV0FBV2hrQixNQUFNLEtBQUtpa0IsUUFBUWprQixNQUFNLElBQUkwa0IsbUJBQW1CTixtQkFBbUJDO1FBQ2hGO0lBQ0Y7SUFDQSxpREFBaUQ7SUFDakQsSUFBSXhJLHVCQUF1QixFQUFFO0lBQzdCMUYsaUJBQWlCdFAsT0FBTyxDQUFDLENBQUN5VixHQUFHbGY7UUFDM0Isb0JBQW9CO1FBQ3BCLDZEQUE2RDtRQUM3RCwwREFBMEQ7UUFDMUQsMkRBQTJEO1FBQzNELGlFQUFpRTtRQUNqRSxJQUFJMm1CLGlCQUFpQixDQUFDdGUsUUFBUWdELElBQUksQ0FBQzJMLENBQUFBLElBQUtBLEVBQUU5UCxLQUFLLENBQUNPLEVBQUUsS0FBS3lYLEVBQUVuQixPQUFPLEtBQUs5RSxnQkFBZ0I3SSxHQUFHLENBQUNwUSxNQUFNO1lBQzdGO1FBQ0Y7UUFDQSxJQUFJdW5CLGlCQUFpQnpmLFlBQVkyVSxhQUFheUMsRUFBRXhjLElBQUksRUFBRXNGO1FBQ3RELHlFQUF5RTtRQUN6RSx3RUFBd0U7UUFDeEUsMEVBQTBFO1FBQzFFLGdFQUFnRTtRQUNoRSxJQUFJLENBQUN1ZixnQkFBZ0I7WUFDbkI5SSxxQkFBcUIzYixJQUFJLENBQUM7Z0JBQ3hCOUM7Z0JBQ0ErZCxTQUFTbUIsRUFBRW5CLE9BQU87Z0JBQ2xCcmIsTUFBTXdjLEVBQUV4YyxJQUFJO2dCQUNaMkYsU0FBUztnQkFDVEksT0FBTztnQkFDUDZJLFlBQVk7WUFDZDtZQUNBO1FBQ0Y7UUFDQSx3RUFBd0U7UUFDeEUsMkVBQTJFO1FBQzNFLHNEQUFzRDtRQUN0RCxJQUFJa0osVUFBVXZaLE1BQU00VyxRQUFRLENBQUN4RyxHQUFHLENBQUNyUjtRQUNqQyxJQUFJd25CLGVBQWU1SixlQUFlMkosZ0JBQWdCckksRUFBRXhjLElBQUk7UUFDeEQsSUFBSStrQixtQkFBbUI7UUFDdkIsSUFBSTNPLGlCQUFpQjFJLEdBQUcsQ0FBQ3BRLE1BQU07WUFDN0Isa0VBQWtFO1lBQ2xFeW5CLG1CQUFtQjtRQUNyQixPQUFPLElBQUloUCxzQkFBc0I5TyxRQUFRLENBQUMzSixNQUFNO1lBQzlDLGlEQUFpRDtZQUNqRHluQixtQkFBbUI7UUFDckIsT0FBTyxJQUFJak4sV0FBV0EsUUFBUXZaLEtBQUssS0FBSyxVQUFVdVosUUFBUTVSLElBQUksS0FBSzFILFdBQVc7WUFDNUUsc0VBQXNFO1lBQ3RFLGlFQUFpRTtZQUNqRSwyQkFBMkI7WUFDM0J1bUIsbUJBQW1CbFA7UUFDckIsT0FBTztZQUNMLHVFQUF1RTtZQUN2RSxpQ0FBaUM7WUFDakNrUCxtQkFBbUJQLHVCQUF1Qk0sY0FBY2pvQixTQUFTO2dCQUMvRHFuQjtnQkFDQU8sZUFBZWxtQixNQUFNb0gsT0FBTyxDQUFDcEgsTUFBTW9ILE9BQU8sQ0FBQ3ZJLE1BQU0sR0FBRyxFQUFFLENBQUM2SSxNQUFNO2dCQUM3RGtlO2dCQUNBTyxZQUFZL2UsT0FBTyxDQUFDQSxRQUFRdkksTUFBTSxHQUFHLEVBQUUsQ0FBQzZJLE1BQU07WUFDaEQsR0FBR21ULFlBQVk7Z0JBQ2IyRTtnQkFDQTRHLHlCQUF5QjlPO1lBQzNCO1FBQ0Y7UUFDQSxJQUFJa1Asa0JBQWtCO1lBQ3BCaEoscUJBQXFCM2IsSUFBSSxDQUFDO2dCQUN4QjlDO2dCQUNBK2QsU0FBU21CLEVBQUVuQixPQUFPO2dCQUNsQnJiLE1BQU13YyxFQUFFeGMsSUFBSTtnQkFDWjJGLFNBQVNrZjtnQkFDVDllLE9BQU8rZTtnQkFDUGxXLFlBQVksSUFBSThCO1lBQ2xCO1FBQ0Y7SUFDRjtJQUNBLE9BQU87UUFBQzBUO1FBQW1Cckk7S0FBcUI7QUFDbEQ7QUFDQSxTQUFTc0ksWUFBWVcsaUJBQWlCLEVBQUVDLFlBQVksRUFBRWxmLEtBQUs7SUFDekQsSUFBSW1mLFFBQ0osZ0JBQWdCO0lBQ2hCLENBQUNELGdCQUNELG1CQUFtQjtJQUNuQmxmLE1BQU12QixLQUFLLENBQUNPLEVBQUUsS0FBS2tnQixhQUFhemdCLEtBQUssQ0FBQ08sRUFBRTtJQUN4QywyRUFBMkU7SUFDM0UsMERBQTBEO0lBQzFELElBQUlvZ0IsZ0JBQWdCSCxpQkFBaUIsQ0FBQ2pmLE1BQU12QixLQUFLLENBQUNPLEVBQUUsQ0FBQyxLQUFLdkc7SUFDMUQsbUVBQW1FO0lBQ25FLE9BQU8wbUIsU0FBU0M7QUFDbEI7QUFDQSxTQUFTUCxtQkFBbUJLLFlBQVksRUFBRWxmLEtBQUs7SUFDN0MsSUFBSXFmLGNBQWNILGFBQWF6Z0IsS0FBSyxDQUFDeEUsSUFBSTtJQUN6QyxPQUNFLHdEQUF3RDtJQUN4RGlsQixhQUFhNWxCLFFBQVEsS0FBSzBHLE1BQU0xRyxRQUFRLElBQ3hDLDBEQUEwRDtJQUMxRCxzREFBc0Q7SUFDdEQrbEIsZUFBZSxRQUFRQSxZQUFZM2QsUUFBUSxDQUFDLFFBQVF3ZCxhQUFhaGYsTUFBTSxDQUFDLElBQUksS0FBS0YsTUFBTUUsTUFBTSxDQUFDLElBQUk7QUFFdEc7QUFDQSxTQUFTdWUsdUJBQXVCYSxXQUFXLEVBQUVDLEdBQUc7SUFDOUMsSUFBSUQsWUFBWTdnQixLQUFLLENBQUN1Z0IsZ0JBQWdCLEVBQUU7UUFDdEMsSUFBSVEsY0FBY0YsWUFBWTdnQixLQUFLLENBQUN1Z0IsZ0JBQWdCLENBQUNPO1FBQ3JELElBQUksT0FBT0MsZ0JBQWdCLFdBQVc7WUFDcEMsT0FBT0E7UUFDVDtJQUNGO0lBQ0EsT0FBT0QsSUFBSVgsdUJBQXVCO0FBQ3BDO0FBQ0E7Ozs7Q0FJQyxHQUNELGVBQWVhLG9CQUFvQmhoQixLQUFLLEVBQUVHLGtCQUFrQixFQUFFRSxRQUFRO0lBQ3BFLElBQUksQ0FBQ0wsTUFBTStQLElBQUksRUFBRTtRQUNmO0lBQ0Y7SUFDQSxJQUFJa1IsWUFBWSxNQUFNamhCLE1BQU0rUCxJQUFJO0lBQ2hDLDBFQUEwRTtJQUMxRSwyRUFBMkU7SUFDM0UseUNBQXlDO0lBQ3pDLElBQUksQ0FBQy9QLE1BQU0rUCxJQUFJLEVBQUU7UUFDZjtJQUNGO0lBQ0EsSUFBSW1SLGdCQUFnQjdnQixRQUFRLENBQUNMLE1BQU1PLEVBQUUsQ0FBQztJQUN0QzFDLFVBQVVxakIsZUFBZTtJQUN6Qix5RUFBeUU7SUFDekUsc0VBQXNFO0lBQ3RFLDBCQUEwQjtJQUMxQixFQUFFO0lBQ0YsNEVBQTRFO0lBQzVFLHlFQUF5RTtJQUN6RSx1RUFBdUU7SUFDdkUsMkRBQTJEO0lBQzNELElBQUlDLGVBQWUsQ0FBQztJQUNwQixJQUFLLElBQUlDLHFCQUFxQkgsVUFBVztRQUN2QyxJQUFJSSxtQkFBbUJILGFBQWEsQ0FBQ0Usa0JBQWtCO1FBQ3ZELElBQUlFLDhCQUE4QkQscUJBQXFCcm5CLGFBQ3ZELHFFQUFxRTtRQUNyRSx1QkFBdUI7UUFDdkJvbkIsc0JBQXNCO1FBQ3RCdG1CLFFBQVEsQ0FBQ3dtQiw2QkFBNkIsWUFBYUosY0FBYzNnQixFQUFFLEdBQUcsOEJBQWdDNmdCLG9CQUFvQixPQUFRLGdGQUFpRiwrQkFBK0JBLG9CQUFvQixvQkFBb0I7UUFDMVIsSUFBSSxDQUFDRSwrQkFBK0IsQ0FBQ3poQixtQkFBbUJxSixHQUFHLENBQUNrWSxvQkFBb0I7WUFDOUVELFlBQVksQ0FBQ0Msa0JBQWtCLEdBQUdILFNBQVMsQ0FBQ0csa0JBQWtCO1FBQ2hFO0lBQ0Y7SUFDQSx3RUFBd0U7SUFDeEUsNENBQTRDO0lBQzVDOW9CLE9BQU9DLE1BQU0sQ0FBQzJvQixlQUFlQztJQUM3Qix5RUFBeUU7SUFDekUsc0VBQXNFO0lBQ3RFLGVBQWU7SUFDZjdvQixPQUFPQyxNQUFNLENBQUMyb0IsZUFBZTdvQixTQUFTLENBQUMsR0FBRzhILG1CQUFtQitnQixnQkFBZ0I7UUFDM0VuUixNQUFNL1Y7SUFDUjtBQUNGO0FBQ0EsZUFBZThjLG1CQUFtQkgsSUFBSSxFQUFFZixPQUFPLEVBQUVyVSxLQUFLLEVBQUVKLE9BQU8sRUFBRWQsUUFBUSxFQUFFRixrQkFBa0IsRUFBRVcsUUFBUSxFQUFFOEcsb0JBQW9CLEVBQUV1TCxJQUFJO0lBQ2pJLElBQUlBLFNBQVMsS0FBSyxHQUFHO1FBQ25CQSxPQUFPLENBQUM7SUFDVjtJQUNBLElBQUlvTztJQUNKLElBQUluZTtJQUNKLElBQUlvZTtJQUNKLElBQUlDLGFBQWFDLENBQUFBO1FBQ2YsMEVBQTBFO1FBQzFFLElBQUlsWDtRQUNKLElBQUlWLGVBQWUsSUFBSU4sUUFBUSxDQUFDakQsR0FBRzBGLElBQU16QixTQUFTeUI7UUFDbER1VixXQUFXLElBQU1oWDtRQUNqQm9MLFFBQVF2TCxNQUFNLENBQUMzSyxnQkFBZ0IsQ0FBQyxTQUFTOGhCO1FBQ3pDLE9BQU9oWSxRQUFRSyxJQUFJLENBQUM7WUFBQzZYLFFBQVE7Z0JBQzNCOUw7Z0JBQ0FuVSxRQUFRRixNQUFNRSxNQUFNO2dCQUNwQmljLFNBQVN2SyxLQUFLa0osY0FBYztZQUM5QjtZQUFJdlM7U0FBYTtJQUNuQjtJQUNBLElBQUk7UUFDRixJQUFJNFgsVUFBVW5nQixNQUFNdkIsS0FBSyxDQUFDMlcsS0FBSztRQUMvQixJQUFJcFYsTUFBTXZCLEtBQUssQ0FBQytQLElBQUksRUFBRTtZQUNwQixJQUFJMlIsU0FBUztnQkFDWCx5REFBeUQ7Z0JBQ3pELElBQUlDO2dCQUNKLElBQUkzRSxTQUFTLE1BQU14VCxRQUFROFEsR0FBRyxDQUFDO29CQUMvQiw4REFBOEQ7b0JBQzlELHNFQUFzRTtvQkFDdEUsaURBQWlEO29CQUNqRG1ILFdBQVdDLFNBQVN6WCxLQUFLLENBQUM3TCxDQUFBQTt3QkFDeEJ1akIsZUFBZXZqQjtvQkFDakI7b0JBQUk0aUIsb0JBQW9CemYsTUFBTXZCLEtBQUssRUFBRUcsb0JBQW9CRTtpQkFBVTtnQkFDbkUsSUFBSXNoQixjQUFjO29CQUNoQixNQUFNQTtnQkFDUjtnQkFDQXZlLFNBQVM0WixNQUFNLENBQUMsRUFBRTtZQUNwQixPQUFPO2dCQUNMLHdEQUF3RDtnQkFDeEQsTUFBTWdFLG9CQUFvQnpmLE1BQU12QixLQUFLLEVBQUVHLG9CQUFvQkU7Z0JBQzNEcWhCLFVBQVVuZ0IsTUFBTXZCLEtBQUssQ0FBQzJXLEtBQUs7Z0JBQzNCLElBQUkrSyxTQUFTO29CQUNYLHVFQUF1RTtvQkFDdkUsaUVBQWlFO29CQUNqRSxnQ0FBZ0M7b0JBQ2hDdGUsU0FBUyxNQUFNcWUsV0FBV0M7Z0JBQzVCLE9BQU8sSUFBSS9LLFNBQVMsVUFBVTtvQkFDNUIsSUFBSW5aLE1BQU0sSUFBSWxDLElBQUlzYSxRQUFRcFksR0FBRztvQkFDN0IsSUFBSTNDLFdBQVcyQyxJQUFJM0MsUUFBUSxHQUFHMkMsSUFBSTlCLE1BQU07b0JBQ3hDLE1BQU1nVSx1QkFBdUIsS0FBSzt3QkFDaENrSCxRQUFRaEIsUUFBUWdCLE1BQU07d0JBQ3RCL2I7d0JBQ0FnYyxTQUFTdFYsTUFBTXZCLEtBQUssQ0FBQ08sRUFBRTtvQkFDekI7Z0JBQ0YsT0FBTztvQkFDTCxxRUFBcUU7b0JBQ3JFLDhEQUE4RDtvQkFDOUQsT0FBTzt3QkFDTG9XLE1BQU0vVyxXQUFXOEIsSUFBSTt3QkFDckJBLE1BQU0xSDtvQkFDUjtnQkFDRjtZQUNGO1FBQ0YsT0FBTyxJQUFJLENBQUMwbkIsU0FBUztZQUNuQixJQUFJbGtCLE1BQU0sSUFBSWxDLElBQUlzYSxRQUFRcFksR0FBRztZQUM3QixJQUFJM0MsV0FBVzJDLElBQUkzQyxRQUFRLEdBQUcyQyxJQUFJOUIsTUFBTTtZQUN4QyxNQUFNZ1UsdUJBQXVCLEtBQUs7Z0JBQ2hDN1U7WUFDRjtRQUNGLE9BQU87WUFDTHVJLFNBQVMsTUFBTXFlLFdBQVdDO1FBQzVCO1FBQ0E3akIsVUFBVXVGLFdBQVdwSixXQUFXLGlCQUFrQjJjLENBQUFBLFNBQVMsV0FBVyxjQUFjLFVBQVMsSUFBSyxnQkFBaUIsT0FBT3BWLE1BQU12QixLQUFLLENBQUNPLEVBQUUsR0FBRyw4Q0FBOENvVyxPQUFPLElBQUcsSUFBSztJQUMxTSxFQUFFLE9BQU92WSxHQUFHO1FBQ1ZtakIsYUFBYTNoQixXQUFXTixLQUFLO1FBQzdCOEQsU0FBU2hGO0lBQ1gsU0FBVTtRQUNSLElBQUlvakIsVUFBVTtZQUNaNUwsUUFBUXZMLE1BQU0sQ0FBQzFLLG1CQUFtQixDQUFDLFNBQVM2aEI7UUFDOUM7SUFDRjtJQUNBLElBQUk1RSxXQUFXeFosU0FBUztRQUN0QixJQUFJMkYsU0FBUzNGLE9BQU8yRixNQUFNO1FBQzFCLG9CQUFvQjtRQUNwQixJQUFJcUUsb0JBQW9CbEUsR0FBRyxDQUFDSCxTQUFTO1lBQ25DLElBQUlwTyxXQUFXeUksT0FBTzRGLE9BQU8sQ0FBQ21CLEdBQUcsQ0FBQztZQUNsQ3RNLFVBQVVsRCxVQUFVO1lBQ3BCLGlEQUFpRDtZQUNqRCxJQUFJLENBQUNxVCxtQkFBbUJ6SixJQUFJLENBQUM1SixXQUFXO2dCQUN0Q0EsV0FBVzhaLFlBQVksSUFBSW5aLElBQUlzYSxRQUFRcFksR0FBRyxHQUFHMkQsUUFBUXhELEtBQUssQ0FBQyxHQUFHd0QsUUFBUXpELE9BQU8sQ0FBQzZELFNBQVMsSUFBSVQsVUFBVSxNQUFNbkcsVUFBVWlOO1lBQ3ZILE9BQU8sSUFBSSxDQUFDdUwsS0FBS3FLLGVBQWUsRUFBRTtnQkFDaEMseUVBQXlFO2dCQUN6RSx1RUFBdUU7Z0JBQ3ZFLGdCQUFnQjtnQkFDaEIsSUFBSWtDLGFBQWEsSUFBSXBrQixJQUFJc2EsUUFBUXBZLEdBQUc7Z0JBQ3BDLElBQUlBLE1BQU03QyxTQUFTc0MsVUFBVSxDQUFDLFFBQVEsSUFBSTNCLElBQUlva0IsV0FBV2tDLFFBQVEsR0FBR2puQixZQUFZLElBQUlXLElBQUlYO2dCQUN4RixJQUFJa25CLGlCQUFpQjlnQixjQUFjdkQsSUFBSTNDLFFBQVEsRUFBRWlHLGFBQWE7Z0JBQzlELElBQUl0RCxJQUFJaUMsTUFBTSxLQUFLaWdCLFdBQVdqZ0IsTUFBTSxJQUFJb2lCLGdCQUFnQjtvQkFDdERsbkIsV0FBVzZDLElBQUkzQyxRQUFRLEdBQUcyQyxJQUFJOUIsTUFBTSxHQUFHOEIsSUFBSTdCLElBQUk7Z0JBQ2pEO1lBQ0Y7WUFDQSx5RUFBeUU7WUFDekUsd0VBQXdFO1lBQ3hFLHlFQUF5RTtZQUN6RSxzREFBc0Q7WUFDdEQsSUFBSXdYLEtBQUtxSyxlQUFlLEVBQUU7Z0JBQ3hCcGEsT0FBTzRGLE9BQU8sQ0FBQ0csR0FBRyxDQUFDLFlBQVl4TztnQkFDL0IsTUFBTXlJO1lBQ1I7WUFDQSxPQUFPO2dCQUNMdVQsTUFBTS9XLFdBQVc2TSxRQUFRO2dCQUN6QjFEO2dCQUNBcE87Z0JBQ0F1YSxZQUFZOVIsT0FBTzRGLE9BQU8sQ0FBQ21CLEdBQUcsQ0FBQywwQkFBMEI7Z0JBQ3pEK1AsZ0JBQWdCOVcsT0FBTzRGLE9BQU8sQ0FBQ21CLEdBQUcsQ0FBQywrQkFBK0I7WUFDcEU7UUFDRjtRQUNBLHlFQUF5RTtRQUN6RSxzRUFBc0U7UUFDdEUsNkRBQTZEO1FBQzdELElBQUlnSixLQUFLb0ssY0FBYyxFQUFFO1lBQ3ZCLElBQUl1RSxxQkFBcUI7Z0JBQ3ZCbkwsTUFBTTRLLGVBQWUzaEIsV0FBV04sS0FBSyxHQUFHTSxXQUFXTixLQUFLLEdBQUdNLFdBQVc4QixJQUFJO2dCQUMxRWlMLFVBQVV2SjtZQUNaO1lBQ0EsTUFBTTBlO1FBQ1I7UUFDQSxJQUFJcGdCO1FBQ0osSUFBSTtZQUNGLElBQUlxZ0IsY0FBYzNlLE9BQU80RixPQUFPLENBQUNtQixHQUFHLENBQUM7WUFDckMsd0VBQXdFO1lBQ3hFLHdFQUF3RTtZQUN4RSxJQUFJNFgsZUFBZSx3QkFBd0J4ZCxJQUFJLENBQUN3ZCxjQUFjO2dCQUM1RCxJQUFJM2UsT0FBT2diLElBQUksSUFBSSxNQUFNO29CQUN2QjFjLE9BQU87Z0JBQ1QsT0FBTztvQkFDTEEsT0FBTyxNQUFNMEIsT0FBT3dGLElBQUk7Z0JBQzFCO1lBQ0YsT0FBTztnQkFDTGxILE9BQU8sTUFBTTBCLE9BQU91SyxJQUFJO1lBQzFCO1FBQ0YsRUFBRSxPQUFPdlAsR0FBRztZQUNWLE9BQU87Z0JBQ0x1WSxNQUFNL1csV0FBV04sS0FBSztnQkFDdEJBLE9BQU9sQjtZQUNUO1FBQ0Y7UUFDQSxJQUFJbWpCLGVBQWUzaEIsV0FBV04sS0FBSyxFQUFFO1lBQ25DLE9BQU87Z0JBQ0xxWCxNQUFNNEs7Z0JBQ05qaUIsT0FBTyxJQUFJc04sa0JBQWtCN0QsUUFBUTNGLE9BQU95SixVQUFVLEVBQUVuTDtnQkFDeERzSCxTQUFTNUYsT0FBTzRGLE9BQU87WUFDekI7UUFDRjtRQUNBLE9BQU87WUFDTDJOLE1BQU0vVyxXQUFXOEIsSUFBSTtZQUNyQkE7WUFDQThhLFlBQVlwWixPQUFPMkYsTUFBTTtZQUN6QkMsU0FBUzVGLE9BQU80RixPQUFPO1FBQ3pCO0lBQ0Y7SUFDQSxJQUFJdVksZUFBZTNoQixXQUFXTixLQUFLLEVBQUU7UUFDbkMsT0FBTztZQUNMcVgsTUFBTTRLO1lBQ05qaUIsT0FBTzhEO1FBQ1Q7SUFDRjtJQUNBLElBQUk0ZSxlQUFlNWUsU0FBUztRQUMxQixJQUFJNmUsY0FBY0M7UUFDbEIsT0FBTztZQUNMdkwsTUFBTS9XLFdBQVd1aUIsUUFBUTtZQUN6QjNKLGNBQWNwVjtZQUNkb1osWUFBWSxDQUFDeUYsZUFBZTdlLE9BQU95RixJQUFJLEtBQUssT0FBTyxLQUFLLElBQUlvWixhQUFhbFosTUFBTTtZQUMvRUMsU0FBUyxDQUFDLENBQUNrWixnQkFBZ0I5ZSxPQUFPeUYsSUFBSSxLQUFLLE9BQU8sS0FBSyxJQUFJcVosY0FBY2xaLE9BQU8sS0FBSyxJQUFJQyxRQUFRN0YsT0FBT3lGLElBQUksQ0FBQ0csT0FBTztRQUN0SDtJQUNGO0lBQ0EsT0FBTztRQUNMMk4sTUFBTS9XLFdBQVc4QixJQUFJO1FBQ3JCQSxNQUFNMEI7SUFDUjtBQUNGO0FBQ0EsK0VBQStFO0FBQy9FLHlFQUF5RTtBQUN6RSw4REFBOEQ7QUFDOUQsU0FBU3lTLHdCQUF3QnphLE9BQU8sRUFBRVQsUUFBUSxFQUFFMFAsTUFBTSxFQUFFdUssVUFBVTtJQUNwRSxJQUFJcFgsTUFBTXBDLFFBQVFDLFNBQVMsQ0FBQ3lqQixrQkFBa0Jua0IsV0FBVzRELFFBQVE7SUFDakUsSUFBSXNLLE9BQU87UUFDVHdCO0lBQ0Y7SUFDQSxJQUFJdUssY0FBY1osaUJBQWlCWSxXQUFXckgsVUFBVSxHQUFHO1FBQ3pELElBQUksRUFDRkEsVUFBVSxFQUNWRSxXQUFXLEVBQ1osR0FBR21IO1FBQ0osMkVBQTJFO1FBQzNFLHdFQUF3RTtRQUN4RSxxREFBcUQ7UUFDckQvTCxLQUFLK04sTUFBTSxHQUFHckosV0FBV3NSLFdBQVc7UUFDcEMsSUFBSXBSLGdCQUFnQixvQkFBb0I7WUFDdEM1RSxLQUFLRyxPQUFPLEdBQUcsSUFBSUMsUUFBUTtnQkFDekIsZ0JBQWdCd0U7WUFDbEI7WUFDQTVFLEtBQUt1VixJQUFJLEdBQUdwakIsS0FBS0MsU0FBUyxDQUFDMlosV0FBV2hNLElBQUk7UUFDNUMsT0FBTyxJQUFJNkUsZ0JBQWdCLGNBQWM7WUFDdkMsd0VBQXdFO1lBQ3hFNUUsS0FBS3VWLElBQUksR0FBR3hKLFdBQVdqSCxJQUFJO1FBQzdCLE9BQU8sSUFBSUYsZ0JBQWdCLHVDQUF1Q21ILFdBQVdsSCxRQUFRLEVBQUU7WUFDckYsd0VBQXdFO1lBQ3hFN0UsS0FBS3VWLElBQUksR0FBR2UsOEJBQThCdkssV0FBV2xILFFBQVE7UUFDL0QsT0FBTztZQUNMLHdFQUF3RTtZQUN4RTdFLEtBQUt1VixJQUFJLEdBQUd4SixXQUFXbEgsUUFBUTtRQUNqQztJQUNGO0lBQ0EsT0FBTyxJQUFJMkksUUFBUTdZLEtBQUtxTDtBQUMxQjtBQUNBLFNBQVNzVyw4QkFBOEJ6UixRQUFRO0lBQzdDLElBQUl3UixlQUFlLElBQUlGO0lBQ3ZCLEtBQUssSUFBSSxDQUFDbG1CLEtBQUtnRixNQUFNLElBQUk0UCxTQUFTaFUsT0FBTyxHQUFJO1FBQzNDLGlJQUFpSTtRQUNqSXdsQixhQUFhRyxNQUFNLENBQUN2bUIsS0FBSyxPQUFPZ0YsVUFBVSxXQUFXQSxRQUFRQSxNQUFNMEIsSUFBSTtJQUN6RTtJQUNBLE9BQU8wZjtBQUNUO0FBQ0EsU0FBU0UsOEJBQThCRixZQUFZO0lBQ2pELElBQUl4UixXQUFXLElBQUlxUjtJQUNuQixLQUFLLElBQUksQ0FBQ2ptQixLQUFLZ0YsTUFBTSxJQUFJb2hCLGFBQWF4bEIsT0FBTyxHQUFJO1FBQy9DZ1UsU0FBUzJSLE1BQU0sQ0FBQ3ZtQixLQUFLZ0Y7SUFDdkI7SUFDQSxPQUFPNFA7QUFDVDtBQUNBLFNBQVNtUSx1QkFBdUIxYyxPQUFPLEVBQUVtVyxhQUFhLEVBQUVXLE9BQU8sRUFBRWxELFlBQVksRUFBRS9DLGVBQWU7SUFDNUYsNkNBQTZDO0lBQzdDLElBQUl4USxhQUFhLENBQUM7SUFDbEIsSUFBSTBPLFNBQVM7SUFDYixJQUFJc007SUFDSixJQUFJNEYsYUFBYTtJQUNqQixJQUFJM0YsZ0JBQWdCLENBQUM7SUFDckIsNERBQTREO0lBQzVEeEUsUUFBUTFWLE9BQU8sQ0FBQyxDQUFDYSxRQUFRdko7UUFDdkIsSUFBSTBHLEtBQUsrVyxhQUFhLENBQUN6ZCxNQUFNLENBQUNtRyxLQUFLLENBQUNPLEVBQUU7UUFDdEMxQyxVQUFVLENBQUNrWixpQkFBaUIzVCxTQUFTO1FBQ3JDLElBQUk2VCxjQUFjN1QsU0FBUztZQUN6QiwrREFBK0Q7WUFDL0QsK0NBQStDO1lBQy9DLElBQUk4VCxnQkFBZ0JuQixvQkFBb0I1VSxTQUFTWjtZQUNqRCxJQUFJakIsUUFBUThELE9BQU85RCxLQUFLO1lBQ3hCLHVFQUF1RTtZQUN2RSxxRUFBcUU7WUFDckUsa0JBQWtCO1lBQ2xCLElBQUl5VixjQUFjO2dCQUNoQnpWLFFBQVFoSCxPQUFPMGtCLE1BQU0sQ0FBQ2pJLGFBQWEsQ0FBQyxFQUFFO2dCQUN0Q0EsZUFBZS9hO1lBQ2pCO1lBQ0FrVyxTQUFTQSxVQUFVLENBQUM7WUFDcEIseUVBQXlFO1lBQ3pFLElBQUlBLE1BQU0sQ0FBQ2dILGNBQWNsWCxLQUFLLENBQUNPLEVBQUUsQ0FBQyxJQUFJLE1BQU07Z0JBQzFDMlAsTUFBTSxDQUFDZ0gsY0FBY2xYLEtBQUssQ0FBQ08sRUFBRSxDQUFDLEdBQUdqQjtZQUNuQztZQUNBLHdEQUF3RDtZQUN4RGtDLFVBQVUsQ0FBQ2pCLEdBQUcsR0FBR3ZHO1lBQ2pCLHFFQUFxRTtZQUNyRSw4Q0FBOEM7WUFDOUMsSUFBSSxDQUFDb29CLFlBQVk7Z0JBQ2ZBLGFBQWE7Z0JBQ2I1RixhQUFhelAscUJBQXFCM0osT0FBTzlELEtBQUssSUFBSThELE9BQU85RCxLQUFLLENBQUN5SixNQUFNLEdBQUc7WUFDMUU7WUFDQSxJQUFJM0YsT0FBTzRGLE9BQU8sRUFBRTtnQkFDbEJ5VCxhQUFhLENBQUNsYyxHQUFHLEdBQUc2QyxPQUFPNEYsT0FBTztZQUNwQztRQUNGLE9BQU87WUFDTCxJQUFJbU8saUJBQWlCL1QsU0FBUztnQkFDNUI0TyxnQkFBZ0I3SSxHQUFHLENBQUM1SSxJQUFJNkMsT0FBT29WLFlBQVk7Z0JBQzNDaFgsVUFBVSxDQUFDakIsR0FBRyxHQUFHNkMsT0FBT29WLFlBQVksQ0FBQzlXLElBQUk7WUFDM0MsT0FBTztnQkFDTEYsVUFBVSxDQUFDakIsR0FBRyxHQUFHNkMsT0FBTzFCLElBQUk7WUFDOUI7WUFDQSxzRUFBc0U7WUFDdEUsMERBQTBEO1lBQzFELElBQUkwQixPQUFPb1osVUFBVSxJQUFJLFFBQVFwWixPQUFPb1osVUFBVSxLQUFLLE9BQU8sQ0FBQzRGLFlBQVk7Z0JBQ3pFNUYsYUFBYXBaLE9BQU9vWixVQUFVO1lBQ2hDO1lBQ0EsSUFBSXBaLE9BQU80RixPQUFPLEVBQUU7Z0JBQ2xCeVQsYUFBYSxDQUFDbGMsR0FBRyxHQUFHNkMsT0FBTzRGLE9BQU87WUFDcEM7UUFDRjtJQUNGO0lBQ0EsbUVBQW1FO0lBQ25FLDBFQUEwRTtJQUMxRSxpQkFBaUI7SUFDakIsSUFBSStMLGNBQWM7UUFDaEI3RSxTQUFTNkU7UUFDVHZULFVBQVUsQ0FBQ2xKLE9BQU80YixJQUFJLENBQUNhLGFBQWEsQ0FBQyxFQUFFLENBQUMsR0FBRy9hO0lBQzdDO0lBQ0EsT0FBTztRQUNMd0g7UUFDQTBPO1FBQ0FzTSxZQUFZQSxjQUFjO1FBQzFCQztJQUNGO0FBQ0Y7QUFDQSxTQUFTbEUsa0JBQWtCeGUsS0FBSyxFQUFFb0gsT0FBTyxFQUFFbVcsYUFBYSxFQUFFVyxPQUFPLEVBQUVsRCxZQUFZLEVBQUV3QyxvQkFBb0IsRUFBRVksY0FBYyxFQUFFbkcsZUFBZTtJQUNwSSxJQUFJLEVBQ0Z4USxVQUFVLEVBQ1YwTyxNQUFNLEVBQ1AsR0FBRzJOLHVCQUF1QjFjLFNBQVNtVyxlQUFlVyxTQUFTbEQsY0FBYy9DO0lBQzFFLGlEQUFpRDtJQUNqRCxJQUFLLElBQUluWSxRQUFRLEdBQUdBLFFBQVEwZCxxQkFBcUIzZSxNQUFNLEVBQUVpQixRQUFTO1FBQ2hFLElBQUksRUFDRmYsR0FBRyxFQUNIeUksS0FBSyxFQUNMNkksVUFBVSxFQUNYLEdBQUdtTixvQkFBb0IsQ0FBQzFkLE1BQU07UUFDL0JnRSxVQUFVc2EsbUJBQW1CbmUsYUFBYW1lLGNBQWMsQ0FBQ3RlLE1BQU0sS0FBS0csV0FBVztRQUMvRSxJQUFJb0osU0FBUytVLGNBQWMsQ0FBQ3RlLE1BQU07UUFDbEMsc0NBQXNDO1FBQ3RDLElBQUl1USxjQUFjQSxXQUFXQyxNQUFNLENBQUNDLE9BQU8sRUFBRTtZQUUzQztRQUNGLE9BQU8sSUFBSTJNLGNBQWM3VCxTQUFTO1lBQ2hDLElBQUk4VCxnQkFBZ0JuQixvQkFBb0JoYyxNQUFNb0gsT0FBTyxFQUFFSSxTQUFTLE9BQU8sS0FBSyxJQUFJQSxNQUFNdkIsS0FBSyxDQUFDTyxFQUFFO1lBQzlGLElBQUksQ0FBRTJQLENBQUFBLFVBQVVBLE1BQU0sQ0FBQ2dILGNBQWNsWCxLQUFLLENBQUNPLEVBQUUsQ0FBQyxHQUFHO2dCQUMvQzJQLFNBQVM3WCxTQUFTLENBQUMsR0FBRzZYLFFBQVE7b0JBQzVCLENBQUNnSCxjQUFjbFgsS0FBSyxDQUFDTyxFQUFFLENBQUMsRUFBRTZDLE9BQU85RCxLQUFLO2dCQUN4QztZQUNGO1lBQ0F2RixNQUFNNFcsUUFBUSxDQUFDbEcsTUFBTSxDQUFDM1I7UUFDeEIsT0FBTyxJQUFJaWUsaUJBQWlCM1QsU0FBUztZQUNuQyxzRUFBc0U7WUFDdEUsMkRBQTJEO1lBQzNEdkYsVUFBVSxPQUFPO1FBQ25CLE9BQU8sSUFBSXNaLGlCQUFpQi9ULFNBQVM7WUFDbkMsc0VBQXNFO1lBQ3RFLDRCQUE0QjtZQUM1QnZGLFVBQVUsT0FBTztRQUNuQixPQUFPO1lBQ0wsSUFBSWdjLGNBQWNMLGVBQWVwVyxPQUFPMUIsSUFBSTtZQUM1QzNILE1BQU00VyxRQUFRLENBQUN4SCxHQUFHLENBQUNyUSxLQUFLK2dCO1FBQzFCO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xyWTtRQUNBME87SUFDRjtBQUNGO0FBQ0EsU0FBU2lFLGdCQUFnQjNTLFVBQVUsRUFBRTZnQixhQUFhLEVBQUVsaEIsT0FBTyxFQUFFK08sTUFBTTtJQUNqRSxJQUFJb1MsbUJBQW1CanFCLFNBQVMsQ0FBQyxHQUFHZ3FCO0lBQ3BDLEtBQUssSUFBSTlnQixTQUFTSixRQUFTO1FBQ3pCLElBQUlaLEtBQUtnQixNQUFNdkIsS0FBSyxDQUFDTyxFQUFFO1FBQ3ZCLElBQUk4aEIsY0FBY3JwQixjQUFjLENBQUN1SCxLQUFLO1lBQ3BDLElBQUk4aEIsYUFBYSxDQUFDOWhCLEdBQUcsS0FBS3ZHLFdBQVc7Z0JBQ25Dc29CLGdCQUFnQixDQUFDL2hCLEdBQUcsR0FBRzhoQixhQUFhLENBQUM5aEIsR0FBRztZQUMxQztRQUNGLE9BQU8sSUFBSWlCLFVBQVUsQ0FBQ2pCLEdBQUcsS0FBS3ZHLGFBQWF1SCxNQUFNdkIsS0FBSyxDQUFDaVEsTUFBTSxFQUFFO1lBQzdELDBFQUEwRTtZQUMxRSx3QkFBd0I7WUFDeEJxUyxnQkFBZ0IsQ0FBQy9oQixHQUFHLEdBQUdpQixVQUFVLENBQUNqQixHQUFHO1FBQ3ZDO1FBQ0EsSUFBSTJQLFVBQVVBLE9BQU9sWCxjQUFjLENBQUN1SCxLQUFLO1lBRXZDO1FBQ0Y7SUFDRjtJQUNBLE9BQU8raEI7QUFDVDtBQUNBLCtFQUErRTtBQUMvRSx1RUFBdUU7QUFDdkUsK0JBQStCO0FBQy9CLFNBQVN2TSxvQkFBb0I1VSxPQUFPLEVBQUUwVixPQUFPO0lBQzNDLElBQUkwTCxrQkFBa0IxTCxVQUFVMVYsUUFBUXhELEtBQUssQ0FBQyxHQUFHd0QsUUFBUXFlLFNBQVMsQ0FBQzFQLENBQUFBLElBQUtBLEVBQUU5UCxLQUFLLENBQUNPLEVBQUUsS0FBS3NXLFdBQVcsS0FBSztXQUFJMVY7S0FBUTtJQUNuSCxPQUFPb2hCLGdCQUFnQkMsT0FBTyxHQUFHekYsSUFBSSxDQUFDak4sQ0FBQUEsSUFBS0EsRUFBRTlQLEtBQUssQ0FBQ2tPLGdCQUFnQixLQUFLLFNBQVMvTSxPQUFPLENBQUMsRUFBRTtBQUM3RjtBQUNBLFNBQVN3Tyx1QkFBdUJ6UCxNQUFNO0lBQ3BDLDBFQUEwRTtJQUMxRSxJQUFJRixRQUFRRSxPQUFPdEgsTUFBTSxLQUFLLElBQUlzSCxNQUFNLENBQUMsRUFBRSxHQUFHQSxPQUFPNmMsSUFBSSxDQUFDOVEsQ0FBQUEsSUFBS0EsRUFBRXBTLEtBQUssSUFBSSxDQUFDb1MsRUFBRXpRLElBQUksSUFBSXlRLEVBQUV6USxJQUFJLEtBQUssUUFBUTtRQUN0RytFLElBQUk7SUFDTjtJQUNBLE9BQU87UUFDTFksU0FBUztZQUFDO2dCQUNSTSxRQUFRLENBQUM7Z0JBQ1Q1RyxVQUFVO2dCQUNWbUssY0FBYztnQkFDZGhGO1lBQ0Y7U0FBRTtRQUNGQTtJQUNGO0FBQ0Y7QUFDQSxTQUFTMFAsdUJBQXVCM0csTUFBTSxFQUFFMFosTUFBTTtJQUM1QyxJQUFJLEVBQ0Y1bkIsUUFBUSxFQUNSZ2MsT0FBTyxFQUNQRCxNQUFNLEVBQ05ELElBQUksRUFDTCxHQUFHOEwsV0FBVyxLQUFLLElBQUksQ0FBQyxJQUFJQTtJQUM3QixJQUFJNVYsYUFBYTtJQUNqQixJQUFJNlYsZUFBZTtJQUNuQixJQUFJM1osV0FBVyxLQUFLO1FBQ2xCOEQsYUFBYTtRQUNiLElBQUkrSixVQUFVL2IsWUFBWWdjLFNBQVM7WUFDakM2TCxlQUFlLGdCQUFnQjlMLFNBQVMsa0JBQW1CL2IsV0FBVyxXQUFhLDRDQUE0Q2djLFVBQVUsS0FBSyxJQUFLO1FBQ3JKLE9BQU8sSUFBSUYsU0FBUyxnQkFBZ0I7WUFDbEMrTCxlQUFlO1FBQ2pCLE9BQU8sSUFBSS9MLFNBQVMsZ0JBQWdCO1lBQ2xDK0wsZUFBZTtRQUNqQjtJQUNGLE9BQU8sSUFBSTNaLFdBQVcsS0FBSztRQUN6QjhELGFBQWE7UUFDYjZWLGVBQWUsWUFBYTdMLFVBQVUsMkJBQTZCaGMsV0FBVztJQUNoRixPQUFPLElBQUlrTyxXQUFXLEtBQUs7UUFDekI4RCxhQUFhO1FBQ2I2VixlQUFlLDJCQUE0QjduQixXQUFXO0lBQ3hELE9BQU8sSUFBSWtPLFdBQVcsS0FBSztRQUN6QjhELGFBQWE7UUFDYixJQUFJK0osVUFBVS9iLFlBQVlnYyxTQUFTO1lBQ2pDNkwsZUFBZSxnQkFBZ0I5TCxPQUFPaUksV0FBVyxLQUFLLGtCQUFtQmhrQixXQUFXLFdBQWEsNkNBQTZDZ2MsVUFBVSxLQUFLLElBQUs7UUFDcEssT0FBTyxJQUFJRCxRQUFRO1lBQ2pCOEwsZUFBZSw2QkFBOEI5TCxPQUFPaUksV0FBVyxLQUFLO1FBQ3RFO0lBQ0Y7SUFDQSxPQUFPLElBQUlqUyxrQkFBa0I3RCxVQUFVLEtBQUs4RCxZQUFZLElBQUk3TyxNQUFNMGtCLGVBQWU7QUFDbkY7QUFDQSxvRUFBb0U7QUFDcEUsU0FBU3JLLGFBQWFKLE9BQU87SUFDM0IsSUFBSyxJQUFJdmYsSUFBSXVmLFFBQVFyZixNQUFNLEdBQUcsR0FBR0YsS0FBSyxHQUFHQSxJQUFLO1FBQzVDLElBQUkwSyxTQUFTNlUsT0FBTyxDQUFDdmYsRUFBRTtRQUN2QixJQUFJcWUsaUJBQWlCM1QsU0FBUztZQUM1QixPQUFPO2dCQUNMQTtnQkFDQTNFLEtBQUsvRjtZQUNQO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU29tQixrQkFBa0J0akIsSUFBSTtJQUM3QixJQUFJb0QsYUFBYSxPQUFPcEQsU0FBUyxXQUFXQyxVQUFVRCxRQUFRQTtJQUM5RCxPQUFPTCxXQUFXOUMsU0FBUyxDQUFDLEdBQUd1RyxZQUFZO1FBQ3pDakQsTUFBTTtJQUNSO0FBQ0Y7QUFDQSxTQUFTZ2EsaUJBQWlCcFMsQ0FBQyxFQUFFQyxDQUFDO0lBQzVCLElBQUlELEVBQUUxSSxRQUFRLEtBQUsySSxFQUFFM0ksUUFBUSxJQUFJMEksRUFBRTdILE1BQU0sS0FBSzhILEVBQUU5SCxNQUFNLEVBQUU7UUFDdEQsT0FBTztJQUNUO0lBQ0EsSUFBSTZILEVBQUU1SCxJQUFJLEtBQUssSUFBSTtRQUNqQixzQkFBc0I7UUFDdEIsT0FBTzZILEVBQUU3SCxJQUFJLEtBQUs7SUFDcEIsT0FBTyxJQUFJNEgsRUFBRTVILElBQUksS0FBSzZILEVBQUU3SCxJQUFJLEVBQUU7UUFDNUIsMkJBQTJCO1FBQzNCLE9BQU87SUFDVCxPQUFPLElBQUk2SCxFQUFFN0gsSUFBSSxLQUFLLElBQUk7UUFDeEIsNEJBQTRCO1FBQzVCLE9BQU87SUFDVDtJQUNBLDZFQUE2RTtJQUM3RSxzQkFBc0I7SUFDdEIsT0FBTztBQUNUO0FBQ0EsU0FBU3diLGlCQUFpQi9ULE1BQU07SUFDOUIsT0FBT0EsT0FBT3VULElBQUksS0FBSy9XLFdBQVd1aUIsUUFBUTtBQUM1QztBQUNBLFNBQVNsTCxjQUFjN1QsTUFBTTtJQUMzQixPQUFPQSxPQUFPdVQsSUFBSSxLQUFLL1csV0FBV04sS0FBSztBQUN6QztBQUNBLFNBQVN5WCxpQkFBaUIzVCxNQUFNO0lBQzlCLE9BQU8sQ0FBQ0EsVUFBVUEsT0FBT3VULElBQUksTUFBTS9XLFdBQVc2TSxRQUFRO0FBQ3hEO0FBQ0EsU0FBU3VWLGVBQWVsa0IsS0FBSztJQUMzQixJQUFJcWtCLFdBQVdya0I7SUFDZixPQUFPcWtCLFlBQVksT0FBT0EsYUFBYSxZQUFZLE9BQU9BLFNBQVN6Z0IsSUFBSSxLQUFLLFlBQVksT0FBT3lnQixTQUFTblgsU0FBUyxLQUFLLGNBQWMsT0FBT21YLFNBQVNsWCxNQUFNLEtBQUssY0FBYyxPQUFPa1gsU0FBUzlXLFdBQVcsS0FBSztBQUMvTTtBQUNBLFNBQVN1UixXQUFXOWUsS0FBSztJQUN2QixPQUFPQSxTQUFTLFFBQVEsT0FBT0EsTUFBTWlMLE1BQU0sS0FBSyxZQUFZLE9BQU9qTCxNQUFNK08sVUFBVSxLQUFLLFlBQVksT0FBTy9PLE1BQU1rTCxPQUFPLEtBQUssWUFBWSxPQUFPbEwsTUFBTXNnQixJQUFJLEtBQUs7QUFDaks7QUFDQSxTQUFTZCxtQkFBbUJsYSxNQUFNO0lBQ2hDLElBQUksQ0FBQ3daLFdBQVd4WixTQUFTO1FBQ3ZCLE9BQU87SUFDVDtJQUNBLElBQUkyRixTQUFTM0YsT0FBTzJGLE1BQU07SUFDMUIsSUFBSXBPLFdBQVd5SSxPQUFPNEYsT0FBTyxDQUFDbUIsR0FBRyxDQUFDO0lBQ2xDLE9BQU9wQixVQUFVLE9BQU9BLFVBQVUsT0FBT3BPLFlBQVk7QUFDdkQ7QUFDQSxTQUFTMGlCLHFCQUFxQnNGLEdBQUc7SUFDL0IsT0FBT0EsT0FBTy9GLFdBQVcrRixJQUFJaFcsUUFBUSxLQUFNZ1csQ0FBQUEsSUFBSWhNLElBQUksS0FBSy9XLFdBQVc4QixJQUFJLElBQUlpaEIsSUFBSWhNLElBQUksS0FBSy9XLFdBQVdOLEtBQUs7QUFDMUc7QUFDQSxTQUFTZ2QsY0FBYzFGLE1BQU07SUFDM0IsT0FBT3pKLG9CQUFvQmpFLEdBQUcsQ0FBQzBOLE9BQU9qUSxXQUFXO0FBQ25EO0FBQ0EsU0FBU3FOLGlCQUFpQjRDLE1BQU07SUFDOUIsT0FBTzNKLHFCQUFxQi9ELEdBQUcsQ0FBQzBOLE9BQU9qUSxXQUFXO0FBQ3BEO0FBQ0EsZUFBZTRULHVCQUF1QkgsY0FBYyxFQUFFOUMsYUFBYSxFQUFFVyxPQUFPLEVBQUUySyxPQUFPLEVBQUVsRSxTQUFTLEVBQUU4QixpQkFBaUI7SUFDakgsSUFBSyxJQUFJM21CLFFBQVEsR0FBR0EsUUFBUW9lLFFBQVFyZixNQUFNLEVBQUVpQixRQUFTO1FBQ25ELElBQUl1SixTQUFTNlUsT0FBTyxDQUFDcGUsTUFBTTtRQUMzQixJQUFJMEgsUUFBUStWLGFBQWEsQ0FBQ3pkLE1BQU07UUFDaEMscUVBQXFFO1FBQ3JFLHdFQUF3RTtRQUN4RSxxQkFBcUI7UUFDckIsSUFBSSxDQUFDMEgsT0FBTztZQUNWO1FBQ0Y7UUFDQSxJQUFJa2YsZUFBZXJHLGVBQWUyQyxJQUFJLENBQUNqTixDQUFBQSxJQUFLQSxFQUFFOVAsS0FBSyxDQUFDTyxFQUFFLEtBQUtnQixNQUFNdkIsS0FBSyxDQUFDTyxFQUFFO1FBQ3pFLElBQUlzaUIsdUJBQXVCcEMsZ0JBQWdCLFFBQVEsQ0FBQ0wsbUJBQW1CSyxjQUFjbGYsVUFBVSxDQUFDaWYscUJBQXFCQSxpQkFBaUIsQ0FBQ2pmLE1BQU12QixLQUFLLENBQUNPLEVBQUUsQ0FBQyxNQUFNdkc7UUFDNUosSUFBSW1kLGlCQUFpQi9ULFdBQVlzYixDQUFBQSxhQUFhbUUsb0JBQW1CLEdBQUk7WUFDbkUsd0VBQXdFO1lBQ3hFLG9FQUFvRTtZQUNwRSxrQkFBa0I7WUFDbEIsSUFBSXhZLFNBQVN1WSxPQUFPLENBQUMvb0IsTUFBTTtZQUMzQmdFLFVBQVV3TSxRQUFRO1lBQ2xCLE1BQU15UCxvQkFBb0IxVyxRQUFRaUgsUUFBUXFVLFdBQVczVSxJQUFJLENBQUMzRyxDQUFBQTtnQkFDeEQsSUFBSUEsUUFBUTtvQkFDVjZVLE9BQU8sQ0FBQ3BlLE1BQU0sR0FBR3VKLFVBQVU2VSxPQUFPLENBQUNwZSxNQUFNO2dCQUMzQztZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsZUFBZWlnQixvQkFBb0IxVyxNQUFNLEVBQUVpSCxNQUFNLEVBQUV5WSxNQUFNO0lBQ3ZELElBQUlBLFdBQVcsS0FBSyxHQUFHO1FBQ3JCQSxTQUFTO0lBQ1g7SUFDQSxJQUFJeFksVUFBVSxNQUFNbEgsT0FBT29WLFlBQVksQ0FBQ25OLFdBQVcsQ0FBQ2hCO0lBQ3BELElBQUlDLFNBQVM7UUFDWDtJQUNGO0lBQ0EsSUFBSXdZLFFBQVE7UUFDVixJQUFJO1lBQ0YsT0FBTztnQkFDTG5NLE1BQU0vVyxXQUFXOEIsSUFBSTtnQkFDckJBLE1BQU0wQixPQUFPb1YsWUFBWSxDQUFDL00sYUFBYTtZQUN6QztRQUNGLEVBQUUsT0FBT3JOLEdBQUc7WUFDVix1RUFBdUU7WUFDdkUsT0FBTztnQkFDTHVZLE1BQU0vVyxXQUFXTixLQUFLO2dCQUN0QkEsT0FBT2xCO1lBQ1Q7UUFDRjtJQUNGO0lBQ0EsT0FBTztRQUNMdVksTUFBTS9XLFdBQVc4QixJQUFJO1FBQ3JCQSxNQUFNMEIsT0FBT29WLFlBQVksQ0FBQzlXLElBQUk7SUFDaEM7QUFDRjtBQUNBLFNBQVM4YyxtQkFBbUI5aUIsTUFBTTtJQUNoQyxPQUFPLElBQUlzakIsZ0JBQWdCdGpCLFFBQVFxbkIsTUFBTSxDQUFDLFNBQVM1ZSxJQUFJLENBQUNnSCxDQUFBQSxJQUFLQSxNQUFNO0FBQ3JFO0FBQ0EsU0FBU3VMLGVBQWV2VixPQUFPLEVBQUV4RyxRQUFRO0lBQ3ZDLElBQUllLFNBQVMsT0FBT2YsYUFBYSxXQUFXYyxVQUFVZCxVQUFVZSxNQUFNLEdBQUdmLFNBQVNlLE1BQU07SUFDeEYsSUFBSXlGLE9BQU8sQ0FBQ0EsUUFBUXZJLE1BQU0sR0FBRyxFQUFFLENBQUNvSCxLQUFLLENBQUNuRyxLQUFLLElBQUkya0IsbUJBQW1COWlCLFVBQVUsS0FBSztRQUMvRSxvREFBb0Q7UUFDcEQsT0FBT3lGLE9BQU8sQ0FBQ0EsUUFBUXZJLE1BQU0sR0FBRyxFQUFFO0lBQ3BDO0lBQ0EsMkVBQTJFO0lBQzNFLDBCQUEwQjtJQUMxQixJQUFJaVAsY0FBY0gsMkJBQTJCdkc7SUFDN0MsT0FBTzBHLFdBQVcsQ0FBQ0EsWUFBWWpQLE1BQU0sR0FBRyxFQUFFO0FBQzVDO0FBQ0EsU0FBU3llLDRCQUE0Qi9HLFVBQVU7SUFDN0MsSUFBSSxFQUNGL0MsVUFBVSxFQUNWQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEUsSUFBSSxFQUNKRCxRQUFRLEVBQ1I5RSxJQUFJLEVBQ0wsR0FBRzBIO0lBQ0osSUFBSSxDQUFDL0MsY0FBYyxDQUFDQyxjQUFjLENBQUNDLGFBQWE7UUFDOUM7SUFDRjtJQUNBLElBQUlFLFFBQVEsTUFBTTtRQUNoQixPQUFPO1lBQ0xKO1lBQ0FDO1lBQ0FDO1lBQ0FDLFVBQVUxVDtZQUNWNE8sTUFBTTVPO1lBQ04yVDtRQUNGO0lBQ0YsT0FBTyxJQUFJRCxZQUFZLE1BQU07UUFDM0IsT0FBTztZQUNMSDtZQUNBQztZQUNBQztZQUNBQztZQUNBOUUsTUFBTTVPO1lBQ04yVCxNQUFNM1Q7UUFDUjtJQUNGLE9BQU8sSUFBSTRPLFNBQVM1TyxXQUFXO1FBQzdCLE9BQU87WUFDTHVUO1lBQ0FDO1lBQ0FDO1lBQ0FDLFVBQVUxVDtZQUNWNE87WUFDQStFLE1BQU0zVDtRQUNSO0lBQ0Y7QUFDRjtBQUNBLFNBQVNvYyxxQkFBcUJ6YixRQUFRLEVBQUVpYSxVQUFVO0lBQ2hELElBQUlBLFlBQVk7UUFDZCxJQUFJdEUsYUFBYTtZQUNmdlcsT0FBTztZQUNQWTtZQUNBNFMsWUFBWXFILFdBQVdySCxVQUFVO1lBQ2pDQyxZQUFZb0gsV0FBV3BILFVBQVU7WUFDakNDLGFBQWFtSCxXQUFXbkgsV0FBVztZQUNuQ0MsVUFBVWtILFdBQVdsSCxRQUFRO1lBQzdCOUUsTUFBTWdNLFdBQVdoTSxJQUFJO1lBQ3JCK0UsTUFBTWlILFdBQVdqSCxJQUFJO1FBQ3ZCO1FBQ0EsT0FBTzJDO0lBQ1QsT0FBTztRQUNMLElBQUlBLGFBQWE7WUFDZnZXLE9BQU87WUFDUFk7WUFDQTRTLFlBQVl2VDtZQUNad1QsWUFBWXhUO1lBQ1p5VCxhQUFhelQ7WUFDYjBULFVBQVUxVDtZQUNWNE8sTUFBTTVPO1lBQ04yVCxNQUFNM1Q7UUFDUjtRQUNBLE9BQU9zVztJQUNUO0FBQ0Y7QUFDQSxTQUFTa0csd0JBQXdCN2IsUUFBUSxFQUFFaWEsVUFBVTtJQUNuRCxJQUFJdEUsYUFBYTtRQUNmdlcsT0FBTztRQUNQWTtRQUNBNFMsWUFBWXFILFdBQVdySCxVQUFVO1FBQ2pDQyxZQUFZb0gsV0FBV3BILFVBQVU7UUFDakNDLGFBQWFtSCxXQUFXbkgsV0FBVztRQUNuQ0MsVUFBVWtILFdBQVdsSCxRQUFRO1FBQzdCOUUsTUFBTWdNLFdBQVdoTSxJQUFJO1FBQ3JCK0UsTUFBTWlILFdBQVdqSCxJQUFJO0lBQ3ZCO0lBQ0EsT0FBTzJDO0FBQ1Q7QUFDQSxTQUFTdUgsa0JBQWtCakQsVUFBVSxFQUFFbFQsSUFBSTtJQUN6QyxJQUFJa1QsWUFBWTtRQUNkLElBQUl0QixVQUFVO1lBQ1p2WixPQUFPO1lBQ1B3VCxZQUFZcUgsV0FBV3JILFVBQVU7WUFDakNDLFlBQVlvSCxXQUFXcEgsVUFBVTtZQUNqQ0MsYUFBYW1ILFdBQVduSCxXQUFXO1lBQ25DQyxVQUFVa0gsV0FBV2xILFFBQVE7WUFDN0I5RSxNQUFNZ00sV0FBV2hNLElBQUk7WUFDckIrRSxNQUFNaUgsV0FBV2pILElBQUk7WUFDckJqTTtRQUNGO1FBQ0EsT0FBTzRSO0lBQ1QsT0FBTztRQUNMLElBQUlBLFVBQVU7WUFDWnZaLE9BQU87WUFDUHdULFlBQVl2VDtZQUNad1QsWUFBWXhUO1lBQ1p5VCxhQUFhelQ7WUFDYjBULFVBQVUxVDtZQUNWNE8sTUFBTTVPO1lBQ04yVCxNQUFNM1Q7WUFDTjBIO1FBQ0Y7UUFDQSxPQUFPNFI7SUFDVDtBQUNGO0FBQ0EsU0FBUzZGLHFCQUFxQnZFLFVBQVUsRUFBRXFFLGVBQWU7SUFDdkQsSUFBSTNGLFVBQVU7UUFDWnZaLE9BQU87UUFDUHdULFlBQVlxSCxXQUFXckgsVUFBVTtRQUNqQ0MsWUFBWW9ILFdBQVdwSCxVQUFVO1FBQ2pDQyxhQUFhbUgsV0FBV25ILFdBQVc7UUFDbkNDLFVBQVVrSCxXQUFXbEgsUUFBUTtRQUM3QjlFLE1BQU1nTSxXQUFXaE0sSUFBSTtRQUNyQitFLE1BQU1pSCxXQUFXakgsSUFBSTtRQUNyQmpNLE1BQU11WCxrQkFBa0JBLGdCQUFnQnZYLElBQUksR0FBRzFIO0lBQ2pEO0lBQ0EsT0FBT3NaO0FBQ1Q7QUFDQSxTQUFTa0csZUFBZTlYLElBQUk7SUFDMUIsSUFBSTRSLFVBQVU7UUFDWnZaLE9BQU87UUFDUHdULFlBQVl2VDtRQUNad1QsWUFBWXhUO1FBQ1p5VCxhQUFhelQ7UUFDYjBULFVBQVUxVDtRQUNWNE8sTUFBTTVPO1FBQ04yVCxNQUFNM1Q7UUFDTjBIO0lBQ0Y7SUFDQSxPQUFPNFI7QUFDVDtBQUNBLFNBQVNaLDBCQUEwQnNRLE9BQU8sRUFBRUMsV0FBVztJQUNyRCxJQUFJO1FBQ0YsSUFBSUMsbUJBQW1CRixRQUFRRyxjQUFjLENBQUNDLE9BQU8sQ0FBQ2hWO1FBQ3RELElBQUk4VSxrQkFBa0I7WUFDcEIsSUFBSXRhLE9BQU81TixLQUFLaWtCLEtBQUssQ0FBQ2lFO1lBQ3RCLEtBQUssSUFBSSxDQUFDOVgsR0FBR0QsRUFBRSxJQUFJN1MsT0FBT29CLE9BQU8sQ0FBQ2tQLFFBQVEsQ0FBQyxHQUFJO2dCQUM3QyxJQUFJdUMsS0FBS1csTUFBTUUsT0FBTyxDQUFDYixJQUFJO29CQUN6QjhYLFlBQVk5WixHQUFHLENBQUNpQyxHQUFHLElBQUl0TCxJQUFJcUwsS0FBSyxFQUFFO2dCQUNwQztZQUNGO1FBQ0Y7SUFDRixFQUFFLE9BQU8vTSxHQUFHO0lBQ1Ysa0NBQWtDO0lBQ3BDO0FBQ0Y7QUFDQSxTQUFTd1UsMEJBQTBCb1EsT0FBTyxFQUFFQyxXQUFXO0lBQ3JELElBQUlBLFlBQVl6WCxJQUFJLEdBQUcsR0FBRztRQUN4QixJQUFJNUMsT0FBTyxDQUFDO1FBQ1osS0FBSyxJQUFJLENBQUN3QyxHQUFHRCxFQUFFLElBQUk4WCxZQUFhO1lBQzlCcmEsSUFBSSxDQUFDd0MsRUFBRSxHQUFHO21CQUFJRDthQUFFO1FBQ2xCO1FBQ0EsSUFBSTtZQUNGNlgsUUFBUUcsY0FBYyxDQUFDRSxPQUFPLENBQUNqVix5QkFBeUJwVCxLQUFLQyxTQUFTLENBQUMyTjtRQUN6RSxFQUFFLE9BQU90SixPQUFPO1lBQ2R4RSxRQUFRLE9BQU8sZ0VBQWdFd0UsUUFBUTtRQUN6RjtJQUNGO0FBQ0Y7QUFDQSxZQUFZO0FBRTh2QixDQUMxd0Isa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JvdXRlci9kaXN0L3JvdXRlci5qcz81MDM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHJlbWl4LXJ1bi9yb3V0ZXIgdjEuMTQuMlxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBUeXBlcyBhbmQgQ29uc3RhbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBBY3Rpb25zIHJlcHJlc2VudCB0aGUgdHlwZSBvZiBjaGFuZ2UgdG8gYSBsb2NhdGlvbiB2YWx1ZS5cbiAqL1xudmFyIEFjdGlvbjtcbihmdW5jdGlvbiAoQWN0aW9uKSB7XG4gIC8qKlxuICAgKiBBIFBPUCBpbmRpY2F0ZXMgYSBjaGFuZ2UgdG8gYW4gYXJiaXRyYXJ5IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoXG4gICAqIGFzIGEgYmFjayBvciBmb3J3YXJkIG5hdmlnYXRpb24uIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAqIG5hdmlnYXRpb24sIG9ubHkgdGhhdCB0aGUgY3VycmVudCBpbmRleCBjaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgbmV3bHkgY3JlYXRlZCBoaXN0b3J5IG9iamVjdHMuXG4gICAqL1xuICBBY3Rpb25bXCJQb3BcIl0gPSBcIlBPUFwiO1xuICAvKipcbiAgICogQSBQVVNIIGluZGljYXRlcyBhIG5ldyBlbnRyeSBiZWluZyBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaCBhcyB3aGVuXG4gICAqIGEgbGluayBpcyBjbGlja2VkIGFuZCBhIG5ldyBwYWdlIGxvYWRzLiBXaGVuIHRoaXMgaGFwcGVucywgYWxsIHN1YnNlcXVlbnRcbiAgICogZW50cmllcyBpbiB0aGUgc3RhY2sgYXJlIGxvc3QuXG4gICAqL1xuICBBY3Rpb25bXCJQdXNoXCJdID0gXCJQVVNIXCI7XG4gIC8qKlxuICAgKiBBIFJFUExBQ0UgaW5kaWNhdGVzIHRoZSBlbnRyeSBhdCB0aGUgY3VycmVudCBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKiBiZWluZyByZXBsYWNlZCBieSBhIG5ldyBvbmUuXG4gICAqL1xuICBBY3Rpb25bXCJSZXBsYWNlXCJdID0gXCJSRVBMQUNFXCI7XG59KShBY3Rpb24gfHwgKEFjdGlvbiA9IHt9KSk7XG5jb25zdCBQb3BTdGF0ZUV2ZW50VHlwZSA9IFwicG9wc3RhdGVcIjtcbi8qKlxuICogTWVtb3J5IGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIG1lbW9yeS4gSXQgaXMgZGVzaWduZWQgZm9yIHVzZVxuICogaW4gc3RhdGVmdWwgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIGxpa2UgdGVzdHMgYW5kIFJlYWN0IE5hdGl2ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgbGV0IHtcbiAgICBpbml0aWFsRW50cmllcyA9IFtcIi9cIl0sXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIHY1Q29tcGF0ID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCBlbnRyaWVzOyAvLyBEZWNsYXJlIHNvIHdlIGNhbiBhY2Nlc3MgZnJvbSBjcmVhdGVNZW1vcnlMb2NhdGlvblxuICBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKChlbnRyeSwgaW5kZXgpID0+IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKGVudHJ5LCB0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIgPyBudWxsIDogZW50cnkuc3RhdGUsIGluZGV4ID09PSAwID8gXCJkZWZhdWx0XCIgOiB1bmRlZmluZWQpKTtcbiAgbGV0IGluZGV4ID0gY2xhbXBJbmRleChpbml0aWFsSW5kZXggPT0gbnVsbCA/IGVudHJpZXMubGVuZ3RoIC0gMSA6IGluaXRpYWxJbmRleCk7XG4gIGxldCBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICBsZXQgbGlzdGVuZXIgPSBudWxsO1xuICBmdW5jdGlvbiBjbGFtcEluZGV4KG4pIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgMCksIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHJldHVybiBlbnRyaWVzW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUsIGtleSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGVudHJpZXMgPyBnZXRDdXJyZW50TG9jYXRpb24oKS5wYXRobmFtZSA6IFwiL1wiLCB0bywgc3RhdGUsIGtleSk7XG4gICAgd2FybmluZyhsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLCBcInJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeTogXCIgKyBKU09OLnN0cmluZ2lmeSh0bykpO1xuICAgIHJldHVybiBsb2NhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmLFxuICAgIGNyZWF0ZVVSTCh0bykge1xuICAgICAgcmV0dXJuIG5ldyBVUkwoY3JlYXRlSHJlZih0byksIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgICB9LFxuICAgIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gICAgICBsZXQgcGF0aCA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLnBhdGhuYW1lIHx8IFwiXCIsXG4gICAgICAgIHNlYXJjaDogcGF0aC5zZWFyY2ggfHwgXCJcIixcbiAgICAgICAgaGFzaDogcGF0aC5oYXNoIHx8IFwiXCJcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgZW50cmllcy5sZW5ndGgsIG5leHRMb2NhdGlvbik7XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoe1xuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgIGRlbHRhOiAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7XG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgICAgZGVsdGE6IDBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnbyhkZWx0YSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICAgIGxldCBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGluZGV4ICsgZGVsdGEpO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGVudHJpZXNbbmV4dEluZGV4XTtcbiAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICBkZWx0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbi8qKlxuICogQnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzLiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3JcbiAqIG1vc3Qgd2ViIGFwcHMsIGJ1dCBpdCByZXF1aXJlcyBzb21lIGNvbmZpZ3VyYXRpb24gb24gdGhlIHNlcnZlciB0byBlbnN1cmUgeW91XG4gKiBzZXJ2ZSB0aGUgc2FtZSBhcHAgYXQgbXVsdGlwbGUgVVJMcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWJyb3dzZXJoaXN0b3J5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VyTG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaFxuICAgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFwiXCIsIHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaFxuICAgIH0sXG4gICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzciB8fCBudWxsLCBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5IHx8IFwiZGVmYXVsdFwiKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VySHJlZih3aW5kb3csIHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShjcmVhdGVCcm93c2VyTG9jYXRpb24sIGNyZWF0ZUJyb3dzZXJIcmVmLCBudWxsLCBvcHRpb25zKTtcbn1cbi8qKlxuICogSGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gd2luZG93LmxvY2F0aW9uLmhhc2guIFRoaXMgbWFrZXMgaXQgaWRlYWxcbiAqIGZvciBzaXR1YXRpb25zIHdoZXJlIHlvdSBkb24ndCB3YW50IHRvIHNlbmQgdGhlIGxvY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgZm9yXG4gKiBzb21lIHJlYXNvbiwgZWl0aGVyIGJlY2F1c2UgeW91IGRvIGNhbm5vdCBjb25maWd1cmUgaXQgb3IgdGhlIFVSTCBzcGFjZSBpc1xuICogcmVzZXJ2ZWQgZm9yIHNvbWV0aGluZyBlbHNlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlaGFzaGhpc3RvcnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3Rvcnkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hMb2NhdGlvbih3aW5kb3csIGdsb2JhbEhpc3RvcnkpIHtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgICBoYXNoID0gXCJcIlxuICAgIH0gPSBwYXJzZVBhdGgod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKTtcbiAgICAvLyBIYXNoIFVSTCBzaG91bGQgYWx3YXlzIGhhdmUgYSBsZWFkaW5nIC8ganVzdCBsaWtlIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZVxuICAgIC8vIGRvZXMsIHNvIGlmIGFuIGFwcCBlbmRzIHVwIGF0IGEgcm91dGUgbGlrZSAvI3NvbWV0aGluZyB0aGVuIHdlIGFkZCBhXG4gICAgLy8gbGVhZGluZyBzbGFzaCBzbyBhbGwgb2Ygb3VyIHBhdGgtbWF0Y2hpbmcgYmVoYXZlcyB0aGUgc2FtZSBhcyBpZiBpdCB3b3VsZFxuICAgIC8vIGluIGEgYnJvd3NlciByb3V0ZXIuICBUaGlzIGlzIHBhcnRpY3VsYXJseSBpbXBvcnRhbnQgd2hlbiB0aGVyZSBleGlzdHMgYVxuICAgIC8vIHJvb3Qgc3BsYXQgcm91dGUgKDxSb3V0ZSBwYXRoPVwiKlwiPikgc2luY2UgdGhhdCBtYXRjaGVzIGludGVybmFsbHkgYWdhaW5zdFxuICAgIC8vIFwiLypcIiBhbmQgd2UnZCBleHBlY3QgLyNzb21ldGhpbmcgdG8gNDA0IGluIGEgaGFzaCByb3V0ZXIgYXBwLlxuICAgIGlmICghcGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgJiYgIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiICsgcGF0aG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcIlwiLCB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhhc2hcbiAgICB9LFxuICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IgfHwgbnVsbCwgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSB8fCBcImRlZmF1bHRcIik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaEhyZWYod2luZG93LCB0bykge1xuICAgIGxldCBiYXNlID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpO1xuICAgIGxldCBocmVmID0gXCJcIjtcbiAgICBpZiAoYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZShcImhyZWZcIikpIHtcbiAgICAgIGxldCB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgIGxldCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG4gICAgICBocmVmID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaHJlZiArIFwiI1wiICsgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0bykpO1xuICB9XG4gIGZ1bmN0aW9uIHZhbGlkYXRlSGFzaExvY2F0aW9uKGxvY2F0aW9uLCB0bykge1xuICAgIHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIiwgXCJyZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goXCIgKyBKU09OLnN0cmluZ2lmeSh0bykgKyBcIilcIik7XG4gIH1cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShjcmVhdGVIYXNoTG9jYXRpb24sIGNyZWF0ZUhhc2hIcmVmLCB2YWxpZGF0ZUhhc2hMb2NhdGlvbiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBoaXN0b3J5IVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2UsIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDgpO1xufVxuLyoqXG4gKiBGb3IgYnJvd3Nlci1iYXNlZCBoaXN0b3JpZXMsIHdlIGNvbWJpbmUgdGhlIHN0YXRlIGFuZCBrZXkgaW50byBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCkge1xuICByZXR1cm4ge1xuICAgIHVzcjogbG9jYXRpb24uc3RhdGUsXG4gICAga2V5OiBsb2NhdGlvbi5rZXksXG4gICAgaWR4OiBpbmRleFxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgTG9jYXRpb24gb2JqZWN0IHdpdGggYSB1bmlxdWUga2V5IGZyb20gdGhlIGdpdmVuIFBhdGhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oY3VycmVudCwgdG8sIHN0YXRlLCBrZXkpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICBzdGF0ZSA9IG51bGw7XG4gIH1cbiAgbGV0IGxvY2F0aW9uID0gX2V4dGVuZHMoe1xuICAgIHBhdGhuYW1lOiB0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIiA/IGN1cnJlbnQgOiBjdXJyZW50LnBhdGhuYW1lLFxuICAgIHNlYXJjaDogXCJcIixcbiAgICBoYXNoOiBcIlwiXG4gIH0sIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bywge1xuICAgIHN0YXRlLFxuICAgIC8vIFRPRE86IFRoaXMgY291bGQgYmUgY2xlYW5lZCB1cC4gIHB1c2gvcmVwbGFjZSBzaG91bGQgcHJvYmFibHkganVzdCB0YWtlXG4gICAgLy8gZnVsbCBMb2NhdGlvbnMgbm93IGFuZCBhdm9pZCB0aGUgbmVlZCB0byBydW4gdGhyb3VnaCB0aGlzIGZsb3cgYXQgYWxsXG4gICAgLy8gQnV0IHRoYXQncyBhIHByZXR0eSBiaWcgcmVmYWN0b3IgdG8gdGhlIGN1cnJlbnQgdGVzdCBzdWl0ZSBzbyBnb2luZyB0b1xuICAgIC8vIGtlZXAgYXMgaXMgZm9yIHRoZSB0aW1lIGJlaW5nIGFuZCBqdXN0IGxldCBhbnkgaW5jb21pbmcga2V5cyB0YWtlIHByZWNlZGVuY2VcbiAgICBrZXk6IHRvICYmIHRvLmtleSB8fCBrZXkgfHwgY3JlYXRlS2V5KClcbiAgfSk7XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBVUkwgcGF0aCBmcm9tIHRoZSBnaXZlbiBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXRoKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCJcbiAgfSA9IF9yZWY7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSBcIj9cIikgcGF0aG5hbWUgKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gXCI/XCIgPyBzZWFyY2ggOiBcIj9cIiArIHNlYXJjaDtcbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gXCIjXCIpIHBhdGhuYW1lICs9IGhhc2guY2hhckF0KDApID09PSBcIiNcIiA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4gIHJldHVybiBwYXRobmFtZTtcbn1cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIFVSTCBwYXRoIGludG8gaXRzIHNlcGFyYXRlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0ge307XG4gIGlmIChwYXRoKSB7XG4gICAgbGV0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLmhhc2ggPSBwYXRoLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuICAgIGxldCBzZWFyY2hJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgICB9XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkUGF0aDtcbn1cbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShnZXRMb2NhdGlvbiwgY3JlYXRlSHJlZiwgdmFsaWRhdGVMb2NhdGlvbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGxldCB7XG4gICAgd2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcsXG4gICAgdjVDb21wYXQgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgbGV0IGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gIGxldCBpbmRleCA9IGdldEluZGV4KCk7XG4gIC8vIEluZGV4IHNob3VsZCBvbmx5IGJlIG51bGwgd2hlbiB3ZSBpbml0aWFsaXplLiBJZiBub3QsIGl0J3MgYmVjYXVzZSB0aGVcbiAgLy8gdXNlciBjYWxsZWQgaGlzdG9yeS5wdXNoU3RhdGUgb3IgaGlzdG9yeS5yZXBsYWNlU3RhdGUgZGlyZWN0bHksIGluIHdoaWNoXG4gIC8vIGNhc2Ugd2Ugc2hvdWxkIGxvZyBhIHdhcm5pbmcgYXMgaXQgd2lsbCByZXN1bHQgaW4gYnVncy5cbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sIGdsb2JhbEhpc3Rvcnkuc3RhdGUsIHtcbiAgICAgIGlkeDogaW5kZXhcbiAgICB9KSwgXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SW5kZXgoKSB7XG4gICAgbGV0IHN0YXRlID0gZ2xvYmFsSGlzdG9yeS5zdGF0ZSB8fCB7XG4gICAgICBpZHg6IG51bGxcbiAgICB9O1xuICAgIHJldHVybiBzdGF0ZS5pZHg7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKCkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgbGV0IG5leHRJbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGRlbHRhID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4IC0gaW5kZXg7XG4gICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7XG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gICAgICAgIGRlbHRhXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHVzaCh0bywgc3RhdGUpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG4gICAgaW5kZXggPSBnZXRJbmRleCgpICsgMTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgLy8gdHJ5Li4uY2F0Y2ggYmVjYXVzZSBpT1MgbGltaXRzIHVzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHMgOi9cbiAgICB0cnkge1xuICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB0aGUgZXhjZXB0aW9uIGlzIGJlY2F1c2UgYHN0YXRlYCBjYW4ndCBiZSBzZXJpYWxpemVkLCBsZXQgdGhhdCB0aHJvd1xuICAgICAgLy8gb3V0d2FyZHMganVzdCBsaWtlIGEgcmVwbGFjZSBjYWxsIHdvdWxkIHNvIHRoZSBkZXYga25vd3MgdGhlIGNhdXNlXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9uYXYtaGlzdG9yeS1hcGlzLmh0bWwjc2hhcmVkLWhpc3RvcnktcHVzaC9yZXBsYWNlLXN0YXRlLXN0ZXBzXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zdHJ1Y3R1cmVkLWRhdGEuaHRtbCNzdHJ1Y3R1cmVkc2VyaWFsaXplaW50ZXJuYWxcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSBcIkRhdGFDbG9uZUVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICAvLyBUaGV5IGFyZSBnb2luZyB0byBsb3NlIHN0YXRlIGhlcmUsIGJ1dCB0aGVyZSBpcyBubyByZWFsXG4gICAgICAvLyB3YXkgdG8gd2FybiB0aGVtIGFib3V0IGl0IHNpbmNlIHRoZSBwYWdlIHdpbGwgcmVmcmVzaC4uLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgZGVsdGE6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcbiAgICBpbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgZGVsdGE6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVVUkwodG8pIHtcbiAgICAvLyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIGlzIFwibnVsbFwiICh0aGUgbGl0ZXJhbCBzdHJpbmcgdmFsdWUpIGluIEZpcmVmb3hcbiAgICAvLyB1bmRlciBjZXJ0YWluIGNvbmRpdGlvbnMsIG5vdGFibHkgd2hlbiBzZXJ2aW5nIGZyb20gYSBsb2NhbCBIVE1MIGZpbGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODc4Mjk3XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICE9PSBcIm51bGxcIiA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gOiB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICBsZXQgaHJlZiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gICAgaW52YXJpYW50KGJhc2UsIFwiTm8gd2luZG93LmxvY2F0aW9uLihvcmlnaW58aHJlZikgYXZhaWxhYmxlIHRvIGNyZWF0ZSBVUkwgZm9yIGhyZWY6IFwiICsgaHJlZik7XG4gICAgcmV0dXJuIG5ldyBVUkwoaHJlZiwgYmFzZSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0TG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KTtcbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgaGlzdG9yeSBvbmx5IGFjY2VwdHMgb25lIGFjdGl2ZSBsaXN0ZW5lclwiKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUhyZWYod2luZG93LCB0byk7XG4gICAgfSxcbiAgICBjcmVhdGVVUkwsXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIC8vIEVuY29kZSBhIExvY2F0aW9uIHRoZSBzYW1lIHdheSB3aW5kb3cubG9jYXRpb24gd291bGRcbiAgICAgIGxldCB1cmwgPSBjcmVhdGVVUkwodG8pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxuICAgICAgICBoYXNoOiB1cmwuaGFzaFxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2gsXG4gICAgcmVwbGFjZSxcbiAgICBnbyhuKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuLy8jZW5kcmVnaW9uXG5cbnZhciBSZXN1bHRUeXBlO1xuKGZ1bmN0aW9uIChSZXN1bHRUeXBlKSB7XG4gIFJlc3VsdFR5cGVbXCJkYXRhXCJdID0gXCJkYXRhXCI7XG4gIFJlc3VsdFR5cGVbXCJkZWZlcnJlZFwiXSA9IFwiZGVmZXJyZWRcIjtcbiAgUmVzdWx0VHlwZVtcInJlZGlyZWN0XCJdID0gXCJyZWRpcmVjdFwiO1xuICBSZXN1bHRUeXBlW1wiZXJyb3JcIl0gPSBcImVycm9yXCI7XG59KShSZXN1bHRUeXBlIHx8IChSZXN1bHRUeXBlID0ge30pKTtcbmNvbnN0IGltbXV0YWJsZVJvdXRlS2V5cyA9IG5ldyBTZXQoW1wibGF6eVwiLCBcImNhc2VTZW5zaXRpdmVcIiwgXCJwYXRoXCIsIFwiaWRcIiwgXCJpbmRleFwiLCBcImNoaWxkcmVuXCJdKTtcbmZ1bmN0aW9uIGlzSW5kZXhSb3V0ZShyb3V0ZSkge1xuICByZXR1cm4gcm91dGUuaW5kZXggPT09IHRydWU7XG59XG4vLyBXYWxrIHRoZSByb3V0ZSB0cmVlIGdlbmVyYXRpbmcgdW5pcXVlIElEcyB3aGVyZSBuZWNlc3NhcnksIHNvIHdlIGFyZSB3b3JraW5nXG4vLyBzb2xlbHkgd2l0aCBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdCdzIHdpdGhpbiB0aGUgUm91dGVyXG5mdW5jdGlvbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCBwYXJlbnRQYXRoLCBtYW5pZmVzdCkge1xuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50UGF0aCA9IFtdO1xuICB9XG4gIGlmIChtYW5pZmVzdCA9PT0gdm9pZCAwKSB7XG4gICAgbWFuaWZlc3QgPSB7fTtcbiAgfVxuICByZXR1cm4gcm91dGVzLm1hcCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcbiAgICBsZXQgaWQgPSB0eXBlb2Ygcm91dGUuaWQgPT09IFwic3RyaW5nXCIgPyByb3V0ZS5pZCA6IHRyZWVQYXRoLmpvaW4oXCItXCIpO1xuICAgIGludmFyaWFudChyb3V0ZS5pbmRleCAhPT0gdHJ1ZSB8fCAhcm91dGUuY2hpbGRyZW4sIFwiQ2Fubm90IHNwZWNpZnkgY2hpbGRyZW4gb24gYW4gaW5kZXggcm91dGVcIik7XG4gICAgaW52YXJpYW50KCFtYW5pZmVzdFtpZF0sIFwiRm91bmQgYSByb3V0ZSBpZCBjb2xsaXNpb24gb24gaWQgXFxcIlwiICsgaWQgKyBcIlxcXCIuICBSb3V0ZSBcIiArIFwiaWQncyBtdXN0IGJlIGdsb2JhbGx5IHVuaXF1ZSB3aXRoaW4gRGF0YSBSb3V0ZXIgdXNhZ2VzXCIpO1xuICAgIGlmIChpc0luZGV4Um91dGUocm91dGUpKSB7XG4gICAgICBsZXQgaW5kZXhSb3V0ZSA9IF9leHRlbmRzKHt9LCByb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSwge1xuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgICBtYW5pZmVzdFtpZF0gPSBpbmRleFJvdXRlO1xuICAgICAgcmV0dXJuIGluZGV4Um91dGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXRoT3JMYXlvdXRSb3V0ZSA9IF9leHRlbmRzKHt9LCByb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSwge1xuICAgICAgICBpZCxcbiAgICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBtYW5pZmVzdFtpZF0gPSBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICBwYXRoT3JMYXlvdXRSb3V0ZS5jaGlsZHJlbiA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGUuY2hpbGRyZW4sIG1hcFJvdXRlUHJvcGVydGllcywgdHJlZVBhdGgsIG1hbmlmZXN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBNYXRjaGVzIHRoZSBnaXZlbiByb3V0ZXMgdG8gYSBsb2NhdGlvbiBhbmQgcmV0dXJucyB0aGUgbWF0Y2ggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL21hdGNoLXJvdXRlc1xuICovXG5mdW5jdGlvbiBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSkge1xuICBpZiAoYmFzZW5hbWUgPT09IHZvaWQgMCkge1xuICAgIGJhc2VuYW1lID0gXCIvXCI7XG4gIH1cbiAgbGV0IGxvY2F0aW9uID0gdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuICBsZXQgcGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiLCBiYXNlbmFtZSk7XG4gIGlmIChwYXRobmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG4gIGxldCBtYXRjaGVzID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IG1hdGNoZXMgPT0gbnVsbCAmJiBpIDwgYnJhbmNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICBtYXRjaGVzID0gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2hlc1tpXSxcbiAgICAvLyBJbmNvbWluZyBwYXRobmFtZXMgYXJlIGdlbmVyYWxseSBlbmNvZGVkIGZyb20gZWl0aGVyIHdpbmRvdy5sb2NhdGlvblxuICAgIC8vIG9yIGZyb20gcm91dGVyLm5hdmlnYXRlLCBidXQgd2Ugd2FudCB0byBtYXRjaCBhZ2FpbnN0IHRoZSB1bmVuY29kZWRcbiAgICAvLyBwYXRocyBpbiB0aGUgcm91dGUgZGVmaW5pdGlvbnMuICBNZW1vcnkgcm91dGVyIGxvY2F0aW9ucyB3b24ndCBiZVxuICAgIC8vIGVuY29kZWQgaGVyZSBidXQgdGhlcmUgYWxzbyBzaG91bGRuJ3QgYmUgYW55dGhpbmcgdG8gZGVjb2RlIHNvIHRoaXNcbiAgICAvLyBzaG91bGQgYmUgYSBzYWZlIG9wZXJhdGlvbi4gIFRoaXMgYXZvaWRzIG5lZWRpbmcgbWF0Y2hSb3V0ZXMgdG8gYmVcbiAgICAvLyBoaXN0b3J5LWF3YXJlLlxuICAgIHNhZmVseURlY29kZVVSSShwYXRobmFtZSkpO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobWF0Y2gsIGxvYWRlckRhdGEpIHtcbiAgbGV0IHtcbiAgICByb3V0ZSxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXNcbiAgfSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGlkOiByb3V0ZS5pZCxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXMsXG4gICAgZGF0YTogbG9hZGVyRGF0YVtyb3V0ZS5pZF0sXG4gICAgaGFuZGxlOiByb3V0ZS5oYW5kbGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5Sb3V0ZXMocm91dGVzLCBicmFuY2hlcywgcGFyZW50c01ldGEsIHBhcmVudFBhdGgpIHtcbiAgaWYgKGJyYW5jaGVzID09PSB2b2lkIDApIHtcbiAgICBicmFuY2hlcyA9IFtdO1xuICB9XG4gIGlmIChwYXJlbnRzTWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50c01ldGEgPSBbXTtcbiAgfVxuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50UGF0aCA9IFwiXCI7XG4gIH1cbiAgbGV0IGZsYXR0ZW5Sb3V0ZSA9IChyb3V0ZSwgaW5kZXgsIHJlbGF0aXZlUGF0aCkgPT4ge1xuICAgIGxldCBtZXRhID0ge1xuICAgICAgcmVsYXRpdmVQYXRoOiByZWxhdGl2ZVBhdGggPT09IHVuZGVmaW5lZCA/IHJvdXRlLnBhdGggfHwgXCJcIiA6IHJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcbiAgICAgIHJvdXRlXG4gICAgfTtcbiAgICBpZiAobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIGludmFyaWFudChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLCBcIkFic29sdXRlIHJvdXRlIHBhdGggXFxcIlwiICsgbWV0YS5yZWxhdGl2ZVBhdGggKyBcIlxcXCIgbmVzdGVkIHVuZGVyIHBhdGggXCIgKyAoXCJcXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBcIikgKyBcIm11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuXCIpO1xuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gam9pblBhdGhzKFtwYXJlbnRQYXRoLCBtZXRhLnJlbGF0aXZlUGF0aF0pO1xuICAgIGxldCByb3V0ZXNNZXRhID0gcGFyZW50c01ldGEuY29uY2F0KG1ldGEpO1xuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSwgc28gd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gcm91dGUgdHJlZSBkZXB0aC1maXJzdCBhbmQgY2hpbGQgcm91dGVzIGFwcGVhciBiZWZvcmUgdGhlaXIgcGFyZW50cyBpblxuICAgIC8vIHRoZSBcImZsYXR0ZW5lZFwiIHZlcnNpb24uXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgIC8vIE91ciB0eXBlcyBrbm93IGJldHRlciwgYnV0IHJ1bnRpbWUgSlMgbWF5IG5vdCFcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlLCBcIkluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkIHJvdXRlcy4gUGxlYXNlIHJlbW92ZSBcIiArIChcImFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFxcXCJcIiArIHBhdGggKyBcIlxcXCIuXCIpKTtcbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG4gICAgLy8gUm91dGVzIHdpdGhvdXQgYSBwYXRoIHNob3VsZG4ndCBldmVyIG1hdGNoIGJ5IHRoZW1zZWx2ZXMgdW5sZXNzIHRoZXkgYXJlXG4gICAgLy8gaW5kZXggcm91dGVzLCBzbyBkb24ndCBhZGQgdGhlbSB0byB0aGUgbGlzdCBvZiBwb3NzaWJsZSBicmFuY2hlcy5cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBicmFuY2hlcy5wdXNoKHtcbiAgICAgIHBhdGgsXG4gICAgICBzY29yZTogY29tcHV0ZVNjb3JlKHBhdGgsIHJvdXRlLmluZGV4KSxcbiAgICAgIHJvdXRlc01ldGFcbiAgICB9KTtcbiAgfTtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIHZhciBfcm91dGUkcGF0aDtcbiAgICAvLyBjb2Fyc2UtZ3JhaW4gY2hlY2sgZm9yIG9wdGlvbmFsIHBhcmFtc1xuICAgIGlmIChyb3V0ZS5wYXRoID09PSBcIlwiIHx8ICEoKF9yb3V0ZSRwYXRoID0gcm91dGUucGF0aCkgIT0gbnVsbCAmJiBfcm91dGUkcGF0aC5pbmNsdWRlcyhcIj9cIikpKSB7XG4gICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZXhwbG9kZWQgb2YgZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocm91dGUucGF0aCkpIHtcbiAgICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCwgZXhwbG9kZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBicmFuY2hlcztcbn1cbi8qKlxuICogQ29tcHV0ZXMgYWxsIGNvbWJpbmF0aW9ucyBvZiBvcHRpb25hbCBwYXRoIHNlZ21lbnRzIGZvciBhIGdpdmVuIHBhdGgsXG4gKiBleGNsdWRpbmcgY29tYmluYXRpb25zIHRoYXQgYXJlIGFtYmlndW91cyBhbmQgb2YgbG93ZXIgcHJpb3JpdHkuXG4gKlxuICogRm9yIGV4YW1wbGUsIGAvb25lLzp0d28/L3RocmVlLzpmb3VyPy86Zml2ZT9gIGV4cGxvZGVzIHRvOlxuICogLSBgL29uZS90aHJlZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZWBcbiAqIC0gYC9vbmUvdGhyZWUvOmZvdXJgXG4gKiAtIGAvb25lL3RocmVlLzpmaXZlYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmb3VyYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmaXZlYFxuICogLSBgL29uZS90aHJlZS86Zm91ci86Zml2ZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zm91ci86Zml2ZWBcbiAqL1xuZnVuY3Rpb24gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocGF0aCkge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IHNlZ21lbnRzO1xuICAvLyBPcHRpb25hbCBwYXRoIHNlZ21lbnRzIGFyZSBkZW5vdGVkIGJ5IGEgdHJhaWxpbmcgYD9gXG4gIGxldCBpc09wdGlvbmFsID0gZmlyc3QuZW5kc1dpdGgoXCI/XCIpO1xuICAvLyBDb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIHJlcXVpcmVkIHNlZ21lbnQ6IGBmb28/YCAtPiBgZm9vYFxuICBsZXQgcmVxdWlyZWQgPSBmaXJzdC5yZXBsYWNlKC9cXD8kLywgXCJcIik7XG4gIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIEludGVwcmV0IGVtcHR5IHN0cmluZyBhcyBvbWl0dGluZyBhbiBvcHRpb25hbCBzZWdtZW50XG4gICAgLy8gYFtcIm9uZVwiLCBcIlwiLCBcInRocmVlXCJdYCBjb3JyZXNwb25kcyB0byBvbWl0dGluZyBgOnR3b2AgZnJvbSBgL29uZS86dHdvPy90aHJlZWAgLT4gYC9vbmUvdGhyZWVgXG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgPyBbcmVxdWlyZWQsIFwiXCJdIDogW3JlcXVpcmVkXTtcbiAgfVxuICBsZXQgcmVzdEV4cGxvZGVkID0gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocmVzdC5qb2luKFwiL1wiKSk7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgLy8gQWxsIGNoaWxkIHBhdGhzIHdpdGggdGhlIHByZWZpeC4gIERvIHRoaXMgZm9yIGFsbCBjaGlsZHJlbiBiZWZvcmUgdGhlXG4gIC8vIG9wdGlvbmFsIHZlcnNpb24gZm9yIGFsbCBjaGlsZHJlbiwgc28gd2UgZ2V0IGNvbnNpc3RlbnQgb3JkZXJpbmcgd2hlcmUgdGhlXG4gIC8vIHBhcmVudCBvcHRpb25hbCBhc3BlY3QgaXMgcHJlZmVycmVkIGFzIHJlcXVpcmVkLiAgT3RoZXJ3aXNlLCB3ZSBjYW4gZ2V0XG4gIC8vIGNoaWxkIHNlY3Rpb25zIGludGVyc3BlcnNlZCB3aGVyZSBkZWVwZXIgb3B0aW9uYWwgc2VnbWVudHMgYXJlIGhpZ2hlciB0aGFuXG4gIC8vIHBhcmVudCBvcHRpb25hbCBzZWdtZW50cywgd2hlcmUgZm9yIGV4YW1wbGUsIC86dHdvIHdvdWxkIGV4cGxvZGUgX2VhcmxpZXJfXG4gIC8vIHRoZW4gLzpvbmUuICBCeSBhbHdheXMgaW5jbHVkaW5nIHRoZSBwYXJlbnQgYXMgcmVxdWlyZWQgX2ZvciBhbGwgY2hpbGRyZW5fXG4gIC8vIGZpcnN0LCB3ZSBhdm9pZCB0aGlzIGlzc3VlXG4gIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZC5tYXAoc3VicGF0aCA9PiBzdWJwYXRoID09PSBcIlwiID8gcmVxdWlyZWQgOiBbcmVxdWlyZWQsIHN1YnBhdGhdLmpvaW4oXCIvXCIpKSk7XG4gIC8vIFRoZW4sIGlmIHRoaXMgaXMgYW4gb3B0aW9uYWwgdmFsdWUsIGFkZCBhbGwgY2hpbGQgdmVyc2lvbnMgd2l0aG91dFxuICBpZiAoaXNPcHRpb25hbCkge1xuICAgIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZCk7XG4gIH1cbiAgLy8gZm9yIGFic29sdXRlIHBhdGhzLCBlbnN1cmUgYC9gIGluc3RlYWQgb2YgZW1wdHkgc2VnbWVudFxuICByZXR1cm4gcmVzdWx0Lm1hcChleHBsb2RlZCA9PiBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpICYmIGV4cGxvZGVkID09PSBcIlwiID8gXCIvXCIgOiBleHBsb2RlZCk7XG59XG5mdW5jdGlvbiByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcykge1xuICBicmFuY2hlcy5zb3J0KChhLCBiKSA9PiBhLnNjb3JlICE9PSBiLnNjb3JlID8gYi5zY29yZSAtIGEuc2NvcmUgLy8gSGlnaGVyIHNjb3JlIGZpcnN0XG4gIDogY29tcGFyZUluZGV4ZXMoYS5yb3V0ZXNNZXRhLm1hcChtZXRhID0+IG1ldGEuY2hpbGRyZW5JbmRleCksIGIucm91dGVzTWV0YS5tYXAobWV0YSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpKSk7XG59XG5jb25zdCBwYXJhbVJlID0gL146W1xcdy1dKyQvO1xuY29uc3QgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG5jb25zdCBpbmRleFJvdXRlVmFsdWUgPSAyO1xuY29uc3QgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xuY29uc3Qgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG5jb25zdCBzcGxhdFBlbmFsdHkgPSAtMjtcbmNvbnN0IGlzU3BsYXQgPSBzID0+IHMgPT09IFwiKlwiO1xuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKHBhdGgsIGluZGV4KSB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBsZXQgaW5pdGlhbFNjb3JlID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAoc2VnbWVudHMuc29tZShpc1NwbGF0KSkge1xuICAgIGluaXRpYWxTY29yZSArPSBzcGxhdFBlbmFsdHk7XG4gIH1cbiAgaWYgKGluZGV4KSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IGluZGV4Um91dGVWYWx1ZTtcbiAgfVxuICByZXR1cm4gc2VnbWVudHMuZmlsdGVyKHMgPT4gIWlzU3BsYXQocykpLnJlZHVjZSgoc2NvcmUsIHNlZ21lbnQpID0+IHNjb3JlICsgKHBhcmFtUmUudGVzdChzZWdtZW50KSA/IGR5bmFtaWNTZWdtZW50VmFsdWUgOiBzZWdtZW50ID09PSBcIlwiID8gZW1wdHlTZWdtZW50VmFsdWUgOiBzdGF0aWNTZWdtZW50VmFsdWUpLCBpbml0aWFsU2NvcmUpO1xufVxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYSwgYikge1xuICBsZXQgc2libGluZ3MgPSBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuICByZXR1cm4gc2libGluZ3MgP1xuICAvLyBJZiB0d28gcm91dGVzIGFyZSBzaWJsaW5ncywgd2Ugc2hvdWxkIHRyeSB0byBtYXRjaCB0aGUgZWFybGllciBzaWJsaW5nXG4gIC8vIGZpcnN0LiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gaGF2ZSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBtYXRjaGluZ1xuICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgLy8gd2FudCB0aGVtIHRyaWVkLlxuICBhW2EubGVuZ3RoIC0gMV0gLSBiW2IubGVuZ3RoIC0gMV0gOlxuICAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gIC8vIHNvIHRoZXkgc29ydCBlcXVhbGx5LlxuICAwO1xufVxuZnVuY3Rpb24gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2gsIHBhdGhuYW1lKSB7XG4gIGxldCB7XG4gICAgcm91dGVzTWV0YVxuICB9ID0gYnJhbmNoO1xuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCIgPyBwYXRobmFtZSA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aCh7XG4gICAgICBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVuZFxuICAgIH0sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG4gICAgbGV0IHJvdXRlID0gbWV0YS5yb3V0ZTtcbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgLy8gVE9ETzogQ2FuIHRoaXMgYXMgYmUgYXZvaWRlZD9cbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pKSxcbiAgICAgIHJvdXRlXG4gICAgfSk7XG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG4vKipcbiAqIFJldHVybnMgYSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL2dlbmVyYXRlLXBhdGhcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKG9yaWdpbmFsUGF0aCwgcGFyYW1zKSB7XG4gIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG4gIGxldCBwYXRoID0gb3JpZ2luYWxQYXRoO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikgJiYgcGF0aCAhPT0gXCIqXCIgJiYgIXBhdGguZW5kc1dpdGgoXCIvKlwiKSkge1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiUm91dGUgcGF0aCBcXFwiXCIgKyBwYXRoICsgXCJcXFwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIFwiICsgKFwiXFxcIlwiICsgcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKSArIFwiXFxcIiBiZWNhdXNlIHRoZSBgKmAgY2hhcmFjdGVyIG11c3QgXCIpICsgXCJhbHdheXMgZm9sbG93IGEgYC9gIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgXCIgKyAoXCJwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIuXCIpKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKTtcbiAgfVxuICAvLyBlbnN1cmUgYC9gIGlzIGFkZGVkIGF0IHRoZSBiZWdpbm5pbmcgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGVcbiAgY29uc3QgcHJlZml4ID0gcGF0aC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiL1wiIDogXCJcIjtcbiAgY29uc3Qgc3RyaW5naWZ5ID0gcCA9PiBwID09IG51bGwgPyBcIlwiIDogdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyBwIDogU3RyaW5nKHApO1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoL1xcLysvKS5tYXAoKHNlZ21lbnQsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBpbmRleCA9PT0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICAvLyBvbmx5IGFwcGx5IHRoZSBzcGxhdCBpZiBpdCdzIHRoZSBsYXN0IHNlZ21lbnRcbiAgICBpZiAoaXNMYXN0U2VnbWVudCAmJiBzZWdtZW50ID09PSBcIipcIikge1xuICAgICAgY29uc3Qgc3RhciA9IFwiKlwiO1xuICAgICAgLy8gQXBwbHkgdGhlIHNwbGF0XG4gICAgICByZXR1cm4gc3RyaW5naWZ5KHBhcmFtc1tzdGFyXSk7XG4gICAgfVxuICAgIGNvbnN0IGtleU1hdGNoID0gc2VnbWVudC5tYXRjaCgvXjooW1xcdy1dKykoXFw/PykkLyk7XG4gICAgaWYgKGtleU1hdGNoKSB7XG4gICAgICBjb25zdCBbLCBrZXksIG9wdGlvbmFsXSA9IGtleU1hdGNoO1xuICAgICAgbGV0IHBhcmFtID0gcGFyYW1zW2tleV07XG4gICAgICBpbnZhcmlhbnQob3B0aW9uYWwgPT09IFwiP1wiIHx8IHBhcmFtICE9IG51bGwsIFwiTWlzc2luZyBcXFwiOlwiICsga2V5ICsgXCJcXFwiIHBhcmFtXCIpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJhbSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhbnkgb3B0aW9uYWwgbWFya2VycyBmcm9tIG9wdGlvbmFsIHN0YXRpYyBzZWdtZW50c1xuICAgIHJldHVybiBzZWdtZW50LnJlcGxhY2UoL1xcPyQvZywgXCJcIik7XG4gIH0pXG4gIC8vIFJlbW92ZSBlbXB0eSBzZWdtZW50c1xuICAuZmlsdGVyKHNlZ21lbnQgPT4gISFzZWdtZW50KTtcbiAgcmV0dXJuIHByZWZpeCArIHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuLyoqXG4gKiBQZXJmb3JtcyBwYXR0ZXJuIG1hdGNoaW5nIG9uIGEgVVJMIHBhdGhuYW1lIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgbWF0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9tYXRjaC1wYXRoXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUGF0aChwYXR0ZXJuLCBwYXRobmFtZSkge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICBwYXR0ZXJuID0ge1xuICAgICAgcGF0aDogcGF0dGVybixcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgZW5kOiB0cnVlXG4gICAgfTtcbiAgfVxuICBsZXQgW21hdGNoZXIsIGNvbXBpbGVkUGFyYW1zXSA9IGNvbXBpbGVQYXRoKHBhdHRlcm4ucGF0aCwgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLCBwYXR0ZXJuLmVuZCk7XG4gIGxldCBtYXRjaCA9IHBhdGhuYW1lLm1hdGNoKG1hdGNoZXIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtcyA9IGNvbXBpbGVkUGFyYW1zLnJlZHVjZSgobWVtbywgX3JlZiwgaW5kZXgpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyYW1OYW1lLFxuICAgICAgaXNPcHRpb25hbFxuICAgIH0gPSBfcmVmO1xuICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgcGF0aG5hbWVCYXNlIGhlcmUgdXNpbmcgdGhlIHJhdyBzcGxhdCB2YWx1ZVxuICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgcGFyYW1zW1wiKlwiXSBsYXRlciBiZWNhdXNlIGl0IHdpbGwgYmUgZGVjb2RlZCB0aGVuXG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgIHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5zbGljZSgwLCBtYXRjaGVkUGF0aG5hbWUubGVuZ3RoIC0gc3BsYXRWYWx1ZS5sZW5ndGgpLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XTtcbiAgICBpZiAoaXNPcHRpb25hbCAmJiAhdmFsdWUpIHtcbiAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVtb1twYXJhbU5hbWVdID0gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlIHx8IFwiXCIsIHBhcmFtTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9LCB7fSk7XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm5cbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKHBhdGgsIGNhc2VTZW5zaXRpdmUsIGVuZCkge1xuICBpZiAoY2FzZVNlbnNpdGl2ZSA9PT0gdm9pZCAwKSB7XG4gICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGlmIChlbmQgPT09IHZvaWQgMCkge1xuICAgIGVuZCA9IHRydWU7XG4gIH1cbiAgd2FybmluZyhwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLCBcIlJvdXRlIHBhdGggXFxcIlwiICsgcGF0aCArIFwiXFxcIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiArIChcIlxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIgYmVjYXVzZSB0aGUgYCpgIGNoYXJhY3RlciBtdXN0IFwiKSArIFwiYWx3YXlzIGZvbGxvdyBhIGAvYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIFwiICsgKFwicGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcXFwiXCIgKyBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpICsgXCJcXFwiLlwiKSk7XG4gIGxldCBwYXJhbXMgPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9IFwiXlwiICsgcGF0aC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAucmVwbGFjZSgvXlxcLyovLCBcIi9cIikgLy8gTWFrZSBzdXJlIGl0IGhhcyBhIGxlYWRpbmcgL1xuICAucmVwbGFjZSgvW1xcXFwuKiteJHt9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcnNcbiAgLnJlcGxhY2UoL1xcLzooW1xcdy1dKykoXFw/KT8vZywgKF8sIHBhcmFtTmFtZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIHBhcmFtTmFtZSxcbiAgICAgIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwgIT0gbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiBpc09wdGlvbmFsID8gXCIvPyhbXlxcXFwvXSspP1wiIDogXCIvKFteXFxcXC9dKylcIjtcbiAgfSk7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIHBhcmFtTmFtZTogXCIqXCJcbiAgICB9KTtcbiAgICByZWdleHBTb3VyY2UgKz0gcGF0aCA9PT0gXCIqXCIgfHwgcGF0aCA9PT0gXCIvKlwiID8gXCIoLiopJFwiIC8vIEFscmVhZHkgbWF0Y2hlZCB0aGUgaW5pdGlhbCAvLCBqdXN0IG1hdGNoIHRoZSByZXN0XG4gICAgOiBcIig/OlxcXFwvKC4rKXxcXFxcLyopJFwiOyAvLyBEb24ndCBpbmNsdWRlIHRoZSAvIGluIHBhcmFtc1tcIipcIl1cbiAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICAvLyBXaGVuIG1hdGNoaW5nIHRvIHRoZSBlbmQsIGlnbm9yZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgcmVnZXhwU291cmNlICs9IFwiXFxcXC8qJFwiO1xuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcbiAgICAvLyBJZiBvdXIgcGF0aCBpcyBub24tZW1wdHkgYW5kIGNvbnRhaW5zIGFueXRoaW5nIGJleW9uZCBhbiBpbml0aWFsIHNsYXNoLFxuICAgIC8vIHRoZW4gd2UgaGF2ZSBfc29tZV8gZm9ybSBvZiBwYXRoIGluIG91ciByZWdleCwgc28gd2Ugc2hvdWxkIGV4cGVjdCB0b1xuICAgIC8vIG1hdGNoIG9ubHkgaWYgd2UgZmluZCB0aGUgZW5kIG9mIHRoaXMgcGF0aCBzZWdtZW50LiAgTG9vayBmb3IgYW4gb3B0aW9uYWxcbiAgICAvLyBub24tY2FwdHVyZWQgdHJhaWxpbmcgc2xhc2ggKHRvIG1hdGNoIGEgcG9ydGlvbiBvZiB0aGUgVVJMKSBvciB0aGUgZW5kXG4gICAgLy8gb2YgdGhlIHBhdGggKGlmIHdlJ3ZlIG1hdGNoZWQgdG8gdGhlIGVuZCkuICBXZSB1c2VkIHRvIGRvIHRoaXMgd2l0aCBhXG4gICAgLy8gd29yZCBib3VuZGFyeSBidXQgdGhhdCBnaXZlcyBmYWxzZSBwb3NpdGl2ZXMgb24gcm91dGVzIGxpa2VcbiAgICAvLyAvdXNlci1wcmVmZXJlbmNlcyBzaW5jZSBgLWAgY291bnRzIGFzIGEgd29yZCBib3VuZGFyeS5cbiAgICByZWdleHBTb3VyY2UgKz0gXCIoPzooPz1cXFxcL3wkKSlcIjtcbiAgfSBlbHNlIDtcbiAgbGV0IG1hdGNoZXIgPSBuZXcgUmVnRXhwKHJlZ2V4cFNvdXJjZSwgY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IFwiaVwiKTtcbiAgcmV0dXJuIFttYXRjaGVyLCBwYXJhbXNdO1xufVxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhmYWxzZSwgXCJUaGUgVVJMIHBhdGggXFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgY291bGQgbm90IGJlIGRlY29kZWQgYmVjYXVzZSBpdCBpcyBpcyBhIFwiICsgXCJtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHkgZHVlIHRvIGEgYmFkIHBlcmNlbnQgXCIgKyAoXCJlbmNvZGluZyAoXCIgKyBlcnJvciArIFwiKS5cIikpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlLCBwYXJhbU5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCBcIlRoZSB2YWx1ZSBmb3IgdGhlIFVSTCBwYXJhbSBcXFwiXCIgKyBwYXJhbU5hbWUgKyBcIlxcXCIgd2lsbCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlXCIgKyAoXCIgdGhlIHN0cmluZyBcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseVwiKSArIChcIiBkdWUgdG8gYSBiYWQgcGVyY2VudCBlbmNvZGluZyAoXCIgKyBlcnJvciArIFwiKS5cIikpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSkge1xuICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSByZXR1cm4gcGF0aG5hbWU7XG4gIGlmICghcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gV2Ugd2FudCB0byBsZWF2ZSB0cmFpbGluZyBzbGFzaCBiZWhhdmlvciBpbiB0aGUgdXNlcidzIGNvbnRyb2wsIHNvIGlmIHRoZXlcbiAgLy8gc3BlY2lmeSBhIGJhc2VuYW1lIHdpdGggYSB0cmFpbGluZyBzbGFzaCwgd2Ugc2hvdWxkIHN1cHBvcnQgaXRcbiAgbGV0IHN0YXJ0SW5kZXggPSBiYXNlbmFtZS5lbmRzV2l0aChcIi9cIikgPyBiYXNlbmFtZS5sZW5ndGggLSAxIDogYmFzZW5hbWUubGVuZ3RoO1xuICBsZXQgbmV4dENoYXIgPSBwYXRobmFtZS5jaGFyQXQoc3RhcnRJbmRleCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwYXRobmFtZS5zbGljZShzdGFydEluZGV4KSB8fCBcIi9cIjtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJlc29sdmVkIHBhdGggb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBwYXRobmFtZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL3Jlc29sdmUtcGF0aFxuICovXG5mdW5jdGlvbiByZXNvbHZlUGF0aCh0bywgZnJvbVBhdGhuYW1lKSB7XG4gIGlmIChmcm9tUGF0aG5hbWUgPT09IHZvaWQgMCkge1xuICAgIGZyb21QYXRobmFtZSA9IFwiL1wiO1xuICB9XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIlxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICBsZXQgcGF0aG5hbWUgPSB0b1BhdGhuYW1lID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSA/IHRvUGF0aG5hbWUgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKSA6IGZyb21QYXRobmFtZTtcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaClcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGgsIGZyb21QYXRobmFtZSkge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKHNlZ21lbnQgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIC8vIEtlZXAgdGhlIHJvb3QgXCJcIiBzZWdtZW50IHNvIHRoZSBwYXRobmFtZSBzdGFydHMgYXQgL1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFBhdGhFcnJvcihjaGFyLCBmaWVsZCwgZGVzdCwgcGF0aCkge1xuICByZXR1cm4gXCJDYW5ub3QgaW5jbHVkZSBhICdcIiArIGNoYXIgKyBcIicgY2hhcmFjdGVyIGluIGEgbWFudWFsbHkgc3BlY2lmaWVkIFwiICsgKFwiYHRvLlwiICsgZmllbGQgKyBcImAgZmllbGQgW1wiICsgSlNPTi5zdHJpbmdpZnkocGF0aCkgKyBcIl0uICBQbGVhc2Ugc2VwYXJhdGUgaXQgb3V0IHRvIHRoZSBcIikgKyAoXCJgdG8uXCIgKyBkZXN0ICsgXCJgIGZpZWxkLiBBbHRlcm5hdGl2ZWx5IHlvdSBtYXkgcHJvdmlkZSB0aGUgZnVsbCBwYXRoIGFzIFwiKSArIFwiYSBzdHJpbmcgaW4gPExpbmsgdG89XFxcIi4uLlxcXCI+IGFuZCB0aGUgcm91dGVyIHdpbGwgcGFyc2UgaXQgZm9yIHlvdS5cIjtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBXaGVuIHByb2Nlc3NpbmcgcmVsYXRpdmUgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIGlnbm9yZSBhbmNlc3RvciByb3V0ZXMgdGhhdFxuICogZG8gbm90IGNvbnRyaWJ1dGUgdG8gdGhlIHBhdGgsIHN1Y2ggdGhhdCBpbmRleC9wYXRobGVzcyBsYXlvdXQgcm91dGVzIGRvbid0XG4gKiBpbnRlcmZlcmUuXG4gKlxuICogRm9yIGV4YW1wbGUsIHdoZW4gbW92aW5nIGEgcm91dGUgZWxlbWVudCBpbnRvIGFuIGluZGV4IHJvdXRlIGFuZC9vciBhXG4gKiBwYXRobGVzcyBsYXlvdXQgcm91dGUsIHJlbGF0aXZlIGxpbmsgYmVoYXZpb3IgY29udGFpbmVkIHdpdGhpbiBzaG91bGQgc3RheVxuICogdGhlIHNhbWUuICBCb3RoIG9mIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgc2hvdWxkIGxpbmsgYmFjayB0byB0aGUgcm9vdDpcbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL1wiPlxuICogICAgIDxSb3V0ZSBwYXRoPVwiYWNjb3VudHNcIiBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9PlxuICogICA8L1JvdXRlPlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvXCI+XG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiPlxuICogICAgICAgPFJvdXRlIGVsZW1lbnQ9ezxBY2NvdW50c0xheW91dCAvPn0+ICAgICAgIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXG4gKiAgICAgICAgIDxSb3V0ZSBpbmRleCBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9IC8+ICAvLyA8LS0gRG9lcyBub3QgY29udHJpYnV0ZVxuICogICAgICAgPC9Sb3V0ZVxuICogICAgIDwvUm91dGU+XG4gKiAgIDwvUm91dGU+XG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpIHtcbiAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgpID0+IGluZGV4ID09PSAwIHx8IG1hdGNoLnJvdXRlLnBhdGggJiYgbWF0Y2gucm91dGUucGF0aC5sZW5ndGggPiAwKTtcbn1cbi8vIFJldHVybiB0aGUgYXJyYXkgb2YgcGF0aG5hbWVzIGZvciB0aGUgY3VycmVudCByb3V0ZSBtYXRjaGVzIC0gdXNlZCB0b1xuLy8gZ2VuZXJhdGUgdGhlIHJvdXRlUGF0aG5hbWVzIGlucHV0IGZvciByZXNvbHZlVG8oKVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzLCB2N19yZWxhdGl2ZVNwbGF0UGF0aCkge1xuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgLy8gV2hlbiB2N19yZWxhdGl2ZVNwbGF0UGF0aCBpcyBlbmFibGVkLCB1c2UgdGhlIGZ1bGwgcGF0aG5hbWUgZm9yIHRoZSBsZWFmXG4gIC8vIG1hdGNoIHNvIHdlIGluY2x1ZGUgc3BsYXQgdmFsdWVzIGZvciBcIi5cIiBsaW5rcy4gIFNlZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzLzExMDUyI2lzc3VlY29tbWVudC0xODM2NTg5MzI5XG4gIGlmICh2N19yZWxhdGl2ZVNwbGF0UGF0aCkge1xuICAgIHJldHVybiBwYXRoTWF0Y2hlcy5tYXAoKG1hdGNoLCBpZHgpID0+IGlkeCA9PT0gbWF0Y2hlcy5sZW5ndGggLSAxID8gbWF0Y2gucGF0aG5hbWUgOiBtYXRjaC5wYXRobmFtZUJhc2UpO1xuICB9XG4gIHJldHVybiBwYXRoTWF0Y2hlcy5tYXAobWF0Y2ggPT4gbWF0Y2gucGF0aG5hbWVCYXNlKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRvKHRvQXJnLCByb3V0ZVBhdGhuYW1lcywgbG9jYXRpb25QYXRobmFtZSwgaXNQYXRoUmVsYXRpdmUpIHtcbiAgaWYgKGlzUGF0aFJlbGF0aXZlID09PSB2b2lkIDApIHtcbiAgICBpc1BhdGhSZWxhdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGxldCB0bztcbiAgaWYgKHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRvID0gcGFyc2VQYXRoKHRvQXJnKTtcbiAgfSBlbHNlIHtcbiAgICB0byA9IF9leHRlbmRzKHt9LCB0b0FyZyk7XG4gICAgaW52YXJpYW50KCF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCI/XCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiP1wiLCBcInBhdGhuYW1lXCIsIFwic2VhcmNoXCIsIHRvKSk7XG4gICAgaW52YXJpYW50KCF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCIjXCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInBhdGhuYW1lXCIsIFwiaGFzaFwiLCB0bykpO1xuICAgIGludmFyaWFudCghdG8uc2VhcmNoIHx8ICF0by5zZWFyY2guaW5jbHVkZXMoXCIjXCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInNlYXJjaFwiLCBcImhhc2hcIiwgdG8pKTtcbiAgfVxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcbiAgbGV0IHRvUGF0aG5hbWUgPSBpc0VtcHR5UGF0aCA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG4gIGxldCBmcm9tO1xuICAvLyBSb3V0aW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBhdGhuYW1lIGlmIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAvL1xuICAvLyBJZiBhIHBhdGhuYW1lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gYHRvYCwgaXQgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAvLyByb3V0ZSBjb250ZXh0LiBUaGlzIGlzIGV4cGxhaW5lZCBpbiBgTm90ZSBvbiBgPExpbmsgdG8+YCB2YWx1ZXNgIGluIG91clxuICAvLyBtaWdyYXRpb24gZ3VpZGUgZnJvbSB2NSBhcyBhIG1lYW5zIG9mIGRpc2FtYmlndWF0aW9uIGJldHdlZW4gYHRvYCB2YWx1ZXNcbiAgLy8gdGhhdCBiZWdpbiB3aXRoIGAvYCBhbmQgdGhvc2UgdGhhdCBkbyBub3QuIEhvd2V2ZXIsIHRoaXMgaXMgcHJvYmxlbWF0aWMgZm9yXG4gIC8vIGB0b2AgdmFsdWVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBwYXRobmFtZS4gYHRvYCBjYW4gc2ltcGx5IGJlIGEgc2VhcmNoIG9yXG4gIC8vIGhhc2ggc3RyaW5nLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBhc3N1bWUgdGhhdCB0aGUgbmF2aWdhdGlvbiBpcyByZWxhdGl2ZVxuICAvLyB0byB0aGUgY3VycmVudCBsb2NhdGlvbidzIHBhdGhuYW1lIGFuZCAqbm90KiB0aGUgcm91dGUgcGF0aG5hbWUuXG4gIGlmICh0b1BhdGhuYW1lID09IG51bGwpIHtcbiAgICBmcm9tID0gbG9jYXRpb25QYXRobmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcbiAgICAvLyBXaXRoIHJlbGF0aXZlPVwicm91dGVcIiAodGhlIGRlZmF1bHQpLCBlYWNoIGxlYWRpbmcgLi4gc2VnbWVudCBtZWFuc1xuICAgIC8vIFwiZ28gdXAgb25lIHJvdXRlXCIgaW5zdGVhZCBvZiBcImdvIHVwIG9uZSBVUkwgc2VnbWVudFwiLiAgVGhpcyBpcyBhIGtleVxuICAgIC8vIGRpZmZlcmVuY2UgZnJvbSBob3cgPGEgaHJlZj4gd29ya3MgYW5kIGEgbWFqb3IgcmVhc29uIHdlIGNhbGwgdGhpcyBhXG4gICAgLy8gXCJ0b1wiIHZhbHVlIGluc3RlYWQgb2YgYSBcImhyZWZcIi5cbiAgICBpZiAoIWlzUGF0aFJlbGF0aXZlICYmIHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi4uXCIpKSB7XG4gICAgICBsZXQgdG9TZWdtZW50cyA9IHRvUGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgd2hpbGUgKHRvU2VnbWVudHNbMF0gPT09IFwiLi5cIikge1xuICAgICAgICB0b1NlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHJvdXRlUGF0aG5hbWVJbmRleCAtPSAxO1xuICAgICAgfVxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH1cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cbiAgbGV0IHBhdGggPSByZXNvbHZlUGF0aCh0bywgZnJvbSk7XG4gIC8vIEVuc3VyZSB0aGUgcGF0aG5hbWUgaGFzIGEgdHJhaWxpbmcgc2xhc2ggaWYgdGhlIG9yaWdpbmFsIFwidG9cIiBoYWQgb25lXG4gIGxldCBoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggPSB0b1BhdGhuYW1lICYmIHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICAvLyBPciBpZiB0aGlzIHdhcyBhIGxpbmsgdG8gdGhlIGN1cnJlbnQgcGF0aCB3aGljaCBoYXMgYSB0cmFpbGluZyBzbGFzaFxuICBsZXQgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2ggPSAoaXNFbXB0eVBhdGggfHwgdG9QYXRobmFtZSA9PT0gXCIuXCIpICYmIGxvY2F0aW9uUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICBpZiAoIXBhdGgucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpICYmIChoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2ggfHwgaGFzQ3VycmVudFRyYWlsaW5nU2xhc2gpKSB7XG4gICAgcGF0aC5wYXRobmFtZSArPSBcIi9cIjtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0VG9QYXRobmFtZSh0bykge1xuICAvLyBFbXB0eSBzdHJpbmdzIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lIGFzIC8gcGF0aHNcbiAgcmV0dXJuIHRvID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiID8gXCIvXCIgOiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pLnBhdGhuYW1lIDogdG8ucGF0aG5hbWU7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGpvaW5QYXRocyA9IHBhdGhzID0+IHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBub3JtYWxpemVQYXRobmFtZSA9IHBhdGhuYW1lID0+IHBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVNlYXJjaCA9IHNlYXJjaCA9PiAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCIgPyBcIlwiIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZUhhc2ggPSBoYXNoID0+ICFoYXNoIHx8IGhhc2ggPT09IFwiI1wiID8gXCJcIiA6IGhhc2guc3RhcnRzV2l0aChcIiNcIikgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuLyoqXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGBhcHBsaWNhdGlvbi9qc29uYCByZXNwb25zZXMuIENvbnZlcnRzIGBkYXRhYFxuICogdG8gSlNPTiBhbmQgc2V0cyB0aGUgYENvbnRlbnQtVHlwZWAgaGVhZGVyLlxuICovXG5jb25zdCBqc29uID0gZnVuY3Rpb24ganNvbihkYXRhLCBpbml0KSB7XG4gIGlmIChpbml0ID09PSB2b2lkIDApIHtcbiAgICBpbml0ID0ge307XG4gIH1cbiAgbGV0IHJlc3BvbnNlSW5pdCA9IHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8ge1xuICAgIHN0YXR1czogaW5pdFxuICB9IDogaW5pdDtcbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIik7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShkYXRhKSwgX2V4dGVuZHMoe30sIHJlc3BvbnNlSW5pdCwge1xuICAgIGhlYWRlcnNcbiAgfSkpO1xufTtcbmNsYXNzIEFib3J0ZWREZWZlcnJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmNsYXNzIERlZmVycmVkRGF0YSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHJlc3BvbnNlSW5pdCkge1xuICAgIHRoaXMucGVuZGluZ0tleXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmRlZmVycmVkS2V5cyA9IFtdO1xuICAgIGludmFyaWFudChkYXRhICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGRhdGEpLCBcImRlZmVyKCkgb25seSBhY2NlcHRzIHBsYWluIG9iamVjdHNcIik7XG4gICAgLy8gU2V0IHVwIGFuIEFib3J0Q29udHJvbGxlciArIFByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCB0byBleGl0IGVhcmx5XG4gICAgLy8gY2FuY2VsbGF0aW9uXG4gICAgbGV0IHJlamVjdDtcbiAgICB0aGlzLmFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiByZWplY3QgPSByKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IG9uQWJvcnQgPSAoKSA9PiByZWplY3QobmV3IEFib3J0ZWREZWZlcnJlZEVycm9yKFwiRGVmZXJyZWQgZGF0YSBhYm9ydGVkXCIpKTtcbiAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwgPSAoKSA9PiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB0aGlzLmRhdGEgPSBPYmplY3QuZW50cmllcyhkYXRhKS5yZWR1Y2UoKGFjYywgX3JlZjIpID0+IHtcbiAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmMjtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICBba2V5XTogdGhpcy50cmFja1Byb21pc2Uoa2V5LCB2YWx1ZSlcbiAgICAgIH0pO1xuICAgIH0sIHt9KTtcbiAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAvLyBBbGwgaW5jb21pbmcgdmFsdWVzIHdlcmUgcmVzb2x2ZWRcbiAgICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCgpO1xuICAgIH1cbiAgICB0aGlzLmluaXQgPSByZXNwb25zZUluaXQ7XG4gIH1cbiAgdHJhY2tQcm9taXNlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRoaXMuZGVmZXJyZWRLZXlzLnB1c2goa2V5KTtcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmFkZChrZXkpO1xuICAgIC8vIFdlIHN0b3JlIGEgbGl0dGxlIHdyYXBwZXIgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZXh0ZW5kZWQgd2l0aFxuICAgIC8vIF9kYXRhL19lcnJvciBwcm9wcyB1cG9uIHJlc29sdmUvcmVqZWN0XG4gICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJhY2UoW3ZhbHVlLCB0aGlzLmFib3J0UHJvbWlzZV0pLnRoZW4oZGF0YSA9PiB0aGlzLm9uU2V0dGxlKHByb21pc2UsIGtleSwgdW5kZWZpbmVkLCBkYXRhKSwgZXJyb3IgPT4gdGhpcy5vblNldHRsZShwcm9taXNlLCBrZXksIGVycm9yKSk7XG4gICAgLy8gUmVnaXN0ZXIgcmVqZWN0aW9uIGxpc3RlbmVycyB0byBhdm9pZCB1bmNhdWdodCBwcm9taXNlIHJlamVjdGlvbnMgb25cbiAgICAvLyBlcnJvcnMgb3IgYWJvcnRlZCBkZWZlcnJlZCB2YWx1ZXNcbiAgICBwcm9taXNlLmNhdGNoKCgpID0+IHt9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICBnZXQ6ICgpID0+IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBvblNldHRsZShwcm9taXNlLCBrZXksIGVycm9yLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJiBlcnJvciBpbnN0YW5jZW9mIEFib3J0ZWREZWZlcnJlZEVycm9yKSB7XG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gZXJyb3JcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5kZWxldGUoa2V5KTtcbiAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAvLyBOb3RoaW5nIGxlZnQgdG8gYWJvcnQhXG4gICAgICB0aGlzLnVubGlzdGVuQWJvcnRTaWduYWwoKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHByb21pc2Ugd2FzIHJlc29sdmVkL3JlamVjdGVkIHdpdGggdW5kZWZpbmVkLCB3ZSdsbCB0aHJvdyBhbiBlcnJvciBhcyB5b3VcbiAgICAvLyBzaG91bGQgYWx3YXlzIHJlc29sdmUgd2l0aCBhIHZhbHVlIG9yIG51bGxcbiAgICBpZiAoZXJyb3IgPT09IHVuZGVmaW5lZCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB1bmRlZmluZWRFcnJvciA9IG5ldyBFcnJvcihcIkRlZmVycmVkIGRhdGEgZm9yIGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgcmVzb2x2ZWQvcmVqZWN0ZWQgd2l0aCBgdW5kZWZpbmVkYCwgXCIgKyBcInlvdSBtdXN0IHJlc29sdmUvcmVqZWN0IHdpdGggYSB2YWx1ZSBvciBgbnVsbGAuXCIpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB1bmRlZmluZWRFcnJvclxuICAgICAgfSk7XG4gICAgICB0aGlzLmVtaXQoZmFsc2UsIGtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodW5kZWZpbmVkRXJyb3IpO1xuICAgIH1cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGVycm9yXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHtcbiAgICAgIGdldDogKCkgPT4gZGF0YVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBlbWl0KGFib3J0ZWQsIHNldHRsZWRLZXkpIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmZvckVhY2goc3Vic2NyaWJlciA9PiBzdWJzY3JpYmVyKGFib3J0ZWQsIHNldHRsZWRLZXkpKTtcbiAgfVxuICBzdWJzY3JpYmUoZm4pIHtcbiAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldC5mb3JFYWNoKCh2LCBrKSA9PiB0aGlzLnBlbmRpbmdLZXlzU2V0LmRlbGV0ZShrKSk7XG4gICAgdGhpcy5lbWl0KHRydWUpO1xuICB9XG4gIGFzeW5jIHJlc29sdmVEYXRhKHNpZ25hbCkge1xuICAgIGxldCBhYm9ydGVkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmRvbmUpIHtcbiAgICAgIGxldCBvbkFib3J0ID0gKCkgPT4gdGhpcy5jYW5jZWwoKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICBhYm9ydGVkID0gYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKGFib3J0ZWQgPT4ge1xuICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICAgICAgaWYgKGFib3J0ZWQgfHwgdGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKGFib3J0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFib3J0ZWQ7XG4gIH1cbiAgZ2V0IGRvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ0tleXNTZXQuc2l6ZSA9PT0gMDtcbiAgfVxuICBnZXQgdW53cmFwcGVkRGF0YSgpIHtcbiAgICBpbnZhcmlhbnQodGhpcy5kYXRhICE9PSBudWxsICYmIHRoaXMuZG9uZSwgXCJDYW4gb25seSB1bndyYXAgZGF0YSBvbiBpbml0aWFsaXplZCBhbmQgc2V0dGxlZCBkZWZlcnJlZHNcIik7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMuZGF0YSkucmVkdWNlKChhY2MsIF9yZWYzKSA9PiB7XG4gICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjM7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2MsIHtcbiAgICAgICAgW2tleV06IHVud3JhcFRyYWNrZWRQcm9taXNlKHZhbHVlKVxuICAgICAgfSk7XG4gICAgfSwge30pO1xuICB9XG4gIGdldCBwZW5kaW5nS2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdLZXlzU2V0KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUcmFja2VkUHJvbWlzZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlICYmIHZhbHVlLl90cmFja2VkID09PSB0cnVlO1xufVxuZnVuY3Rpb24gdW53cmFwVHJhY2tlZFByb21pc2UodmFsdWUpIHtcbiAgaWYgKCFpc1RyYWNrZWRQcm9taXNlKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUuX2Vycm9yKSB7XG4gICAgdGhyb3cgdmFsdWUuX2Vycm9yO1xuICB9XG4gIHJldHVybiB2YWx1ZS5fZGF0YTtcbn1cbmNvbnN0IGRlZmVyID0gZnVuY3Rpb24gZGVmZXIoZGF0YSwgaW5pdCkge1xuICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdCA9IHt9O1xuICB9XG4gIGxldCByZXNwb25zZUluaXQgPSB0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICBzdGF0dXM6IGluaXRcbiAgfSA6IGluaXQ7XG4gIHJldHVybiBuZXcgRGVmZXJyZWREYXRhKGRhdGEsIHJlc3BvbnNlSW5pdCk7XG59O1xuLyoqXG4gKiBBIHJlZGlyZWN0IHJlc3BvbnNlLiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuY29uc3QgcmVkaXJlY3QgPSBmdW5jdGlvbiByZWRpcmVjdCh1cmwsIGluaXQpIHtcbiAgaWYgKGluaXQgPT09IHZvaWQgMCkge1xuICAgIGluaXQgPSAzMDI7XG4gIH1cbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG4gIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0ge1xuICAgICAgc3RhdHVzOiByZXNwb25zZUluaXRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZUluaXQuc3RhdHVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzcG9uc2VJbml0LnN0YXR1cyA9IDMwMjtcbiAgfVxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIF9leHRlbmRzKHt9LCByZXNwb25zZUluaXQsIHtcbiAgICBoZWFkZXJzXG4gIH0pKTtcbn07XG4vKipcbiAqIEEgcmVkaXJlY3QgcmVzcG9uc2UgdGhhdCB3aWxsIGZvcmNlIGEgZG9jdW1lbnQgcmVsb2FkIHRvIHRoZSBuZXcgbG9jYXRpb24uXG4gKiBTZXRzIHRoZSBzdGF0dXMgY29kZSBhbmQgdGhlIGBMb2NhdGlvbmAgaGVhZGVyLlxuICogRGVmYXVsdHMgdG8gXCIzMDIgRm91bmRcIi5cbiAqL1xuY29uc3QgcmVkaXJlY3REb2N1bWVudCA9ICh1cmwsIGluaXQpID0+IHtcbiAgbGV0IHJlc3BvbnNlID0gcmVkaXJlY3QodXJsLCBpbml0KTtcbiAgcmVzcG9uc2UuaGVhZGVycy5zZXQoXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiLCBcInRydWVcIik7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKiBVdGlsaXR5IGNsYXNzIHdlIHVzZSB0byBob2xkIGF1dG8tdW53cmFwcGVkIDR4eC81eHggUmVzcG9uc2UgYm9kaWVzXG4gKlxuICogV2UgZG9uJ3QgZXhwb3J0IHRoZSBjbGFzcyBmb3IgcHVibGljIHVzZSBzaW5jZSBpdCdzIGFuIGltcGxlbWVudGF0aW9uXG4gKiBkZXRhaWwsIGJ1dCB3ZSBleHBvcnQgdGhlIGludGVyZmFjZSBhYm92ZSBzbyBmb2xrcyBjYW4gYnVpbGQgdGhlaXIgb3duXG4gKiBhYnN0cmFjdGlvbnMgYXJvdW5kIGluc3RhbmNlcyB2aWEgaXNSb3V0ZUVycm9yUmVzcG9uc2UoKVxuICovXG5jbGFzcyBFcnJvclJlc3BvbnNlSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YSwgaW50ZXJuYWwpIHtcbiAgICBpZiAoaW50ZXJuYWwgPT09IHZvaWQgMCkge1xuICAgICAgaW50ZXJuYWwgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCB8fCBcIlwiO1xuICAgIHRoaXMuaW50ZXJuYWwgPSBpbnRlcm5hbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICB0aGlzLmVycm9yID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVycm9yIGlzIGFuIEVycm9yUmVzcG9uc2UgZ2VuZXJhdGVkIGZyb20gYSA0eHgvNXh4XG4gKiBSZXNwb25zZSB0aHJvd24gZnJvbSBhbiBhY3Rpb24vbG9hZGVyXG4gKi9cbmZ1bmN0aW9uIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGVycm9yLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLmludGVybmFsID09PSBcImJvb2xlYW5cIiAmJiBcImRhdGFcIiBpbiBlcnJvcjtcbn1cblxuY29uc3QgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIgPSBbXCJwb3N0XCIsIFwicHV0XCIsIFwicGF0Y2hcIiwgXCJkZWxldGVcIl07XG5jb25zdCB2YWxpZE11dGF0aW9uTWV0aG9kcyA9IG5ldyBTZXQodmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIpO1xuY29uc3QgdmFsaWRSZXF1ZXN0TWV0aG9kc0FyciA9IFtcImdldFwiLCAuLi52YWxpZE11dGF0aW9uTWV0aG9kc0Fycl07XG5jb25zdCB2YWxpZFJlcXVlc3RNZXRob2RzID0gbmV3IFNldCh2YWxpZFJlcXVlc3RNZXRob2RzQXJyKTtcbmNvbnN0IHJlZGlyZWN0U3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pO1xuY29uc3QgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzID0gbmV3IFNldChbMzA3LCAzMDhdKTtcbmNvbnN0IElETEVfTkFWSUdBVElPTiA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAganNvbjogdW5kZWZpbmVkLFxuICB0ZXh0OiB1bmRlZmluZWRcbn07XG5jb25zdCBJRExFX0ZFVENIRVIgPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAganNvbjogdW5kZWZpbmVkLFxuICB0ZXh0OiB1bmRlZmluZWRcbn07XG5jb25zdCBJRExFX0JMT0NLRVIgPSB7XG4gIHN0YXRlOiBcInVuYmxvY2tlZFwiLFxuICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gIHJlc2V0OiB1bmRlZmluZWQsXG4gIGxvY2F0aW9uOiB1bmRlZmluZWRcbn07XG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG5jb25zdCBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzID0gcm91dGUgPT4gKHtcbiAgaGFzRXJyb3JCb3VuZGFyeTogQm9vbGVhbihyb3V0ZS5oYXNFcnJvckJvdW5kYXJ5KVxufSk7XG5jb25zdCBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSA9IFwicmVtaXgtcm91dGVyLXRyYW5zaXRpb25zXCI7XG4vLyNlbmRyZWdpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gY3JlYXRlUm91dGVyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBDcmVhdGUgYSByb3V0ZXIgYW5kIGxpc3RlbiB0byBoaXN0b3J5IFBPUCBuYXZpZ2F0aW9uc1xuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXIoaW5pdCkge1xuICBjb25zdCByb3V0ZXJXaW5kb3cgPSBpbml0LndpbmRvdyA/IGluaXQud2luZG93IDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHJvdXRlcldpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygcm91dGVyV2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgY29uc3QgaXNTZXJ2ZXIgPSAhaXNCcm93c2VyO1xuICBpbnZhcmlhbnQoaW5pdC5yb3V0ZXMubGVuZ3RoID4gMCwgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVSb3V0ZXJcIik7XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXM7XG4gIGlmIChpbml0Lm1hcFJvdXRlUHJvcGVydGllcykge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGluaXQubWFwUm91dGVQcm9wZXJ0aWVzO1xuICB9IGVsc2UgaWYgKGluaXQuZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHRoZXkgYXJlIHN0aWxsIHVzaW5nIHRoZSBkZXByZWNhdGVkIHZlcnNpb24sIHdyYXAgaXQgd2l0aCB0aGUgbmV3IEFQSVxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gaW5pdC5kZXRlY3RFcnJvckJvdW5kYXJ5O1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IHJvdXRlID0+ICh7XG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBkZXRlY3RFcnJvckJvdW5kYXJ5KHJvdXRlKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH1cbiAgLy8gUm91dGVzIGtleWVkIGJ5IElEXG4gIGxldCBtYW5pZmVzdCA9IHt9O1xuICAvLyBSb3V0ZXMgaW4gdHJlZSBmb3JtYXQgZm9yIG1hdGNoaW5nXG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhpbml0LnJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCB1bmRlZmluZWQsIG1hbmlmZXN0KTtcbiAgbGV0IGluRmxpZ2h0RGF0YVJvdXRlcztcbiAgbGV0IGJhc2VuYW1lID0gaW5pdC5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgLy8gQ29uZmlnIGRyaXZlbiBiZWhhdmlvciBmbGFnc1xuICBsZXQgZnV0dXJlID0gX2V4dGVuZHMoe1xuICAgIHY3X2ZldGNoZXJQZXJzaXN0OiBmYWxzZSxcbiAgICB2N19ub3JtYWxpemVGb3JtTWV0aG9kOiBmYWxzZSxcbiAgICB2N19wYXJ0aWFsSHlkcmF0aW9uOiBmYWxzZSxcbiAgICB2N19wcmVwZW5kQmFzZW5hbWU6IGZhbHNlLFxuICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBmYWxzZVxuICB9LCBpbml0LmZ1dHVyZSk7XG4gIC8vIENsZWFudXAgZnVuY3Rpb24gZm9yIGhpc3RvcnlcbiAgbGV0IHVubGlzdGVuSGlzdG9yeSA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb25zIHRvIGNhbGwgb24gYWxsIHN0YXRlIGNoYW5nZXNcbiAgbGV0IHN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIG9iamVjdCB0byBob2xkIHNjcm9sbCByZXN0b3JhdGlvbiBsb2NhdGlvbnMgZHVyaW5nIHJvdXRpbmdcbiAgbGV0IHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gbnVsbDtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbiB0byBnZXQgc2Nyb2xsIHJlc3RvcmF0aW9uIGtleXNcbiAgbGV0IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ID0gbnVsbDtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBmdW5jdGlvbiB0byBnZXQgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgbGV0IGdldFNjcm9sbFBvc2l0aW9uID0gbnVsbDtcbiAgLy8gT25lLXRpbWUgZmxhZyB0byBjb250cm9sIHRoZSBpbml0aWFsIGh5ZHJhdGlvbiBzY3JvbGwgcmVzdG9yYXRpb24uICBCZWNhdXNlXG4gIC8vIHdlIGRvbid0IGdldCB0aGUgc2F2ZWQgcG9zaXRpb25zIGZyb20gPFNjcm9sbFJlc3RvcmF0aW9uIC8+IHVudGlsIF9hZnRlcl9cbiAgLy8gdGhlIGluaXRpYWwgcmVuZGVyLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHRyaWdnZXIgYSBzZXBhcmF0ZSB1cGRhdGVTdGF0ZSB0b1xuICAvLyBzZW5kIGFsb25nIHRoZSByZXN0b3JlU2Nyb2xsUG9zaXRpb25cbiAgLy8gU2V0IHRvIHRydWUgaWYgd2UgaGF2ZSBgaHlkcmF0aW9uRGF0YWAgc2luY2Ugd2UgYXNzdW1lIHdlIHdlcmUgU1NSJ2QgYW5kIHRoYXRcbiAgLy8gU1NSIGRpZCB0aGUgaW5pdGlhbCBzY3JvbGwgcmVzdG9yYXRpb24uXG4gIGxldCBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbDtcbiAgbGV0IGluaXRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgaW5pdC5oaXN0b3J5LmxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gIGxldCBpbml0aWFsRXJyb3JzID0gbnVsbDtcbiAgaWYgKGluaXRpYWxNYXRjaGVzID09IG51bGwpIHtcbiAgICAvLyBJZiB3ZSBkbyBub3QgbWF0Y2ggYSB1c2VyLXByb3ZpZGVkLXJvdXRlLCBmYWxsIGJhY2sgdG8gdGhlIHJvb3RcbiAgICAvLyB0byBhbGxvdyB0aGUgZXJyb3IgYm91bmRhcnkgdG8gdGFrZSBvdmVyXG4gICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgIHBhdGhuYW1lOiBpbml0Lmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWVcbiAgICB9KTtcbiAgICBsZXQge1xuICAgICAgbWF0Y2hlcyxcbiAgICAgIHJvdXRlXG4gICAgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGluaXRpYWxFcnJvcnMgPSB7XG4gICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgIH07XG4gIH1cbiAgbGV0IGluaXRpYWxpemVkO1xuICBsZXQgaGFzTGF6eVJvdXRlcyA9IGluaXRpYWxNYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmxhenkpO1xuICBsZXQgaGFzTG9hZGVycyA9IGluaXRpYWxNYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmxvYWRlcik7XG4gIGlmIChoYXNMYXp5Um91dGVzKSB7XG4gICAgLy8gQWxsIGluaXRpYWxNYXRjaGVzIG5lZWQgdG8gYmUgbG9hZGVkIGJlZm9yZSB3ZSdyZSByZWFkeS4gIElmIHdlIGhhdmUgbGF6eVxuICAgIC8vIGZ1bmN0aW9ucyBhcm91bmQgc3RpbGwgdGhlbiB3ZSdsbCBuZWVkIHRvIHJ1biB0aGVtIGluIGluaXRpYWxpemUoKVxuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoIWhhc0xvYWRlcnMpIHtcbiAgICAvLyBJZiB3ZSd2ZSBnb3Qgbm8gbG9hZGVycyB0byBydW4sIHRoZW4gd2UncmUgZ29vZCB0byBnb1xuICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbikge1xuICAgIC8vIElmIHBhcnRpYWwgaHlkcmF0aW9uIGlzIGVuYWJsZWQsIHdlJ3JlIGluaXRpYWxpemVkIHNvIGxvbmcgYXMgd2Ugd2VyZVxuICAgIC8vIHByb3ZpZGVkIHdpdGggaHlkcmF0aW9uRGF0YSBmb3IgZXZlcnkgcm91dGUgd2l0aCBhIGxvYWRlciwgYW5kIG5vIGxvYWRlcnNcbiAgICAvLyB3ZXJlIG1hcmtlZCBmb3IgZXhwbGljaXQgaHlkcmF0aW9uXG4gICAgbGV0IGxvYWRlckRhdGEgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgPyBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSA6IG51bGw7XG4gICAgbGV0IGVycm9ycyA9IGluaXQuaHlkcmF0aW9uRGF0YSA/IGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMgOiBudWxsO1xuICAgIGluaXRpYWxpemVkID0gaW5pdGlhbE1hdGNoZXMuZXZlcnkobSA9PiBtLnJvdXRlLmxvYWRlciAmJiBtLnJvdXRlLmxvYWRlci5oeWRyYXRlICE9PSB0cnVlICYmIChsb2FkZXJEYXRhICYmIGxvYWRlckRhdGFbbS5yb3V0ZS5pZF0gIT09IHVuZGVmaW5lZCB8fCBlcnJvcnMgJiYgZXJyb3JzW20ucm91dGUuaWRdICE9PSB1bmRlZmluZWQpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXaXRob3V0IHBhcnRpYWwgaHlkcmF0aW9uIC0gd2UncmUgaW5pdGlhbGl6ZWQgaWYgd2Ugd2VyZSBwcm92aWRlZCBhbnlcbiAgICAvLyBoeWRyYXRpb25EYXRhIC0gd2hpY2ggaXMgZXhwZWN0ZWQgdG8gYmUgY29tcGxldGVcbiAgICBpbml0aWFsaXplZCA9IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsO1xuICB9XG4gIGxldCByb3V0ZXI7XG4gIGxldCBzdGF0ZSA9IHtcbiAgICBoaXN0b3J5QWN0aW9uOiBpbml0Lmhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBpbml0Lmhpc3RvcnkubG9jYXRpb24sXG4gICAgbWF0Y2hlczogaW5pdGlhbE1hdGNoZXMsXG4gICAgaW5pdGlhbGl6ZWQsXG4gICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgIC8vIERvbid0IHJlc3RvcmUgb24gaW5pdGlhbCB1cGRhdGVTdGF0ZSgpIGlmIHdlIHdlcmUgU1NSJ2RcbiAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGluaXQuaHlkcmF0aW9uRGF0YSAhPSBudWxsID8gZmFsc2UgOiBudWxsLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldDogZmFsc2UsXG4gICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcbiAgICBsb2FkZXJEYXRhOiBpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmxvYWRlckRhdGEgfHwge30sXG4gICAgYWN0aW9uRGF0YTogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5hY3Rpb25EYXRhIHx8IG51bGwsXG4gICAgZXJyb3JzOiBpbml0Lmh5ZHJhdGlvbkRhdGEgJiYgaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycyB8fCBpbml0aWFsRXJyb3JzLFxuICAgIGZldGNoZXJzOiBuZXcgTWFwKCksXG4gICAgYmxvY2tlcnM6IG5ldyBNYXAoKVxuICB9O1xuICAvLyAtLSBTdGF0ZWZ1bCBpbnRlcm5hbCB2YXJpYWJsZXMgdG8gbWFuYWdlIG5hdmlnYXRpb25zIC0tXG4gIC8vIEN1cnJlbnQgbmF2aWdhdGlvbiBpbiBwcm9ncmVzcyAodG8gYmUgY29tbWl0dGVkIGluIGNvbXBsZXRlTmF2aWdhdGlvbilcbiAgbGV0IHBlbmRpbmdBY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAvLyBTaG91bGQgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBwcmV2ZW50IHRoZSBzY3JvbGwgcmVzZXQgaWYgc2Nyb2xsIGNhbm5vdFxuICAvLyBiZSByZXN0b3JlZD9cbiAgbGV0IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgLy8gQWJvcnRDb250cm9sbGVyIGZvciB0aGUgYWN0aXZlIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcjtcbiAgLy8gU2hvdWxkIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gZW5hYmxlIGRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24/XG4gIGxldCBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gZmFsc2U7XG4gIC8vIFN0b3JlIGFwcGxpZWQgdmlldyB0cmFuc2l0aW9ucyBzbyB3ZSBjYW4gYXBwbHkgdGhlbSBvbiBQT1BcbiAgbGV0IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMgPSBuZXcgTWFwKCk7XG4gIC8vIENsZWFudXAgZnVuY3Rpb24gZm9yIHBlcnNpc3RpbmcgYXBwbGllZCB0cmFuc2l0aW9ucyB0byBzZXNzaW9uU3RvcmFnZVxuICBsZXQgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyID0gbnVsbDtcbiAgLy8gV2UgdXNlIHRoaXMgdG8gYXZvaWQgdG91Y2hpbmcgaGlzdG9yeSBpbiBjb21wbGV0ZU5hdmlnYXRpb24gaWYgYVxuICAvLyByZXZhbGlkYXRpb24gaXMgZW50aXJlbHkgdW5pbnRlcnJ1cHRlZFxuICBsZXQgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGZsYWcgdG8gZm9yY2UgcmV2YWxpZGF0aW9uIG9mIGFsbCBsb2FkZXJzOlxuICAvLyAgLSBzdWJtaXNzaW9ucyAoY29tcGxldGVkIG9yIGludGVycnVwdGVkKVxuICAvLyAgLSB1c2VSZXZhbGlkYXRvcigpXG4gIC8vICAtIFgtUmVtaXgtUmV2YWxpZGF0ZSAoZnJvbSByZWRpcmVjdClcbiAgbGV0IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSBmYWxzZTtcbiAgLy8gVXNlIHRoaXMgaW50ZXJuYWwgYXJyYXkgdG8gY2FwdHVyZSByb3V0ZXMgdGhhdCByZXF1aXJlIHJldmFsaWRhdGlvbiBkdWVcbiAgLy8gdG8gYSBjYW5jZWxsZWQgZGVmZXJyZWQgb24gYWN0aW9uIHN1Ym1pc3Npb25cbiAgbGV0IGNhbmNlbGxlZERlZmVycmVkUm91dGVzID0gW107XG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGFycmF5IHRvIGNhcHR1cmUgZmV0Y2hlciBsb2FkcyB0aGF0IHdlcmUgY2FuY2VsbGVkIGJ5IGFuXG4gIC8vIGFjdGlvbiBuYXZpZ2F0aW9uIGFuZCByZXF1aXJlIHJldmFsaWRhdGlvblxuICBsZXQgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gW107XG4gIC8vIEFib3J0Q29udHJvbGxlcnMgZm9yIGFueSBpbi1mbGlnaHQgZmV0Y2hlcnNcbiAgbGV0IGZldGNoQ29udHJvbGxlcnMgPSBuZXcgTWFwKCk7XG4gIC8vIFRyYWNrIGxvYWRzIGJhc2VkIG9uIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHN0YXJ0ZWRcbiAgbGV0IGluY3JlbWVudGluZ0xvYWRJZCA9IDA7XG4gIC8vIFRyYWNrIHRoZSBvdXRzdGFuZGluZyBwZW5kaW5nIG5hdmlnYXRpb24gZGF0YSBsb2FkIHRvIGJlIGNvbXBhcmVkIGFnYWluc3RcbiAgLy8gdGhlIGdsb2JhbGx5IGluY3JlbWVudGluZyBsb2FkIHdoZW4gYSBmZXRjaGVyIGxvYWQgbGFuZHMgYWZ0ZXIgYSBjb21wbGV0ZWRcbiAgLy8gbmF2aWdhdGlvblxuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSAtMTtcbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgZGF0YSByZWxvYWRzIGFzIGEgcmVzdWx0IG9mIHRoZWlyIGFjdGlvbnNcbiAgbGV0IGZldGNoUmVsb2FkSWRzID0gbmV3IE1hcCgpO1xuICAvLyBGZXRjaGVycyB0aGF0IHRyaWdnZXJlZCByZWRpcmVjdCBuYXZpZ2F0aW9uc1xuICBsZXQgZmV0Y2hSZWRpcmVjdElkcyA9IG5ldyBTZXQoKTtcbiAgLy8gTW9zdCByZWNlbnQgaHJlZi9tYXRjaCBmb3IgZmV0Y2hlci5sb2FkIGNhbGxzIGZvciBmZXRjaGVyc1xuICBsZXQgZmV0Y2hMb2FkTWF0Y2hlcyA9IG5ldyBNYXAoKTtcbiAgLy8gUmVmLWNvdW50IG1vdW50ZWQgZmV0Y2hlcnMgc28gd2Uga25vdyB3aGVuIGl0J3Mgb2sgdG8gY2xlYW4gdGhlbSB1cFxuICBsZXQgYWN0aXZlRmV0Y2hlcnMgPSBuZXcgTWFwKCk7XG4gIC8vIEZldGNoZXJzIHRoYXQgaGF2ZSByZXF1ZXN0ZWQgYSBkZWxldGUgd2hlbiB1c2luZyB2N19mZXRjaGVyUGVyc2lzdCxcbiAgLy8gdGhleSdsbCBiZSBvZmZpY2lhbGx5IHJlbW92ZWQgYWZ0ZXIgdGhleSByZXR1cm4gdG8gaWRsZVxuICBsZXQgZGVsZXRlZEZldGNoZXJzID0gbmV3IFNldCgpO1xuICAvLyBTdG9yZSBEZWZlcnJlZERhdGEgaW5zdGFuY2VzIGZvciBhY3RpdmUgcm91dGUgbWF0Y2hlcy4gIFdoZW4gYVxuICAvLyByb3V0ZSBsb2FkZXIgcmV0dXJucyBkZWZlcigpIHdlIHN0aWNrIG9uZSBpbiBoZXJlLiAgVGhlbiwgd2hlbiBhIG5lc3RlZFxuICAvLyBwcm9taXNlIHJlc29sdmVzIHdlIHVwZGF0ZSBsb2FkZXJEYXRhLiAgSWYgYSBuZXcgbmF2aWdhdGlvbiBzdGFydHMgd2VcbiAgLy8gY2FuY2VsIGFjdGl2ZSBkZWZlcnJlZHMgZm9yIGVsaW1pbmF0ZWQgcm91dGVzLlxuICBsZXQgYWN0aXZlRGVmZXJyZWRzID0gbmV3IE1hcCgpO1xuICAvLyBTdG9yZSBibG9ja2VyIGZ1bmN0aW9ucyBpbiBhIHNlcGFyYXRlIE1hcCBvdXRzaWRlIG9mIHJvdXRlciBzdGF0ZSBzaW5jZVxuICAvLyB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSBVSSBzdGF0ZSBpZiB0aGV5IGNoYW5nZVxuICBsZXQgYmxvY2tlckZ1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgLy8gRmxhZyB0byBpZ25vcmUgdGhlIG5leHQgaGlzdG9yeSB1cGRhdGUsIHNvIHdlIGNhbiByZXZlcnQgdGhlIFVSTCBjaGFuZ2Ugb25cbiAgLy8gYSBQT1AgbmF2aWdhdGlvbiB0aGF0IHdhcyBibG9ja2VkIGJ5IHRoZSB1c2VyIHdpdGhvdXQgdG91Y2hpbmcgcm91dGVyIHN0YXRlXG4gIGxldCBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBJbml0aWFsaXplIHRoZSByb3V0ZXIsIGFsbCBzaWRlIGVmZmVjdHMgc2hvdWxkIGJlIGtpY2tlZCBvZmYgZnJvbSBoZXJlLlxuICAvLyBJbXBsZW1lbnRlZCBhcyBhIEZsdWVudCBBUEkgZm9yIGVhc2Ugb2Y6XG4gIC8vICAgbGV0IHJvdXRlciA9IGNyZWF0ZVJvdXRlcihpbml0KS5pbml0aWFsaXplKCk7XG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgLy8gSWYgaGlzdG9yeSBpbmZvcm1zIHVzIG9mIGEgUE9QIG5hdmlnYXRpb24sIHN0YXJ0IHRoZSBuYXZpZ2F0aW9uIGJ1dCBkbyBub3QgdXBkYXRlXG4gICAgLy8gc3RhdGUuICBXZSdsbCB1cGRhdGUgb3VyIG93biBzdGF0ZSBvbmNlIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlc1xuICAgIHVubGlzdGVuSGlzdG9yeSA9IGluaXQuaGlzdG9yeS5saXN0ZW4oX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBhY3Rpb246IGhpc3RvcnlBY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBkZWx0YVxuICAgICAgfSA9IF9yZWY7XG4gICAgICAvLyBJZ25vcmUgdGhpcyBldmVudCBpZiBpdCB3YXMganVzdCB1cyByZXNldHRpbmcgdGhlIFVSTCBmcm9tIGFcbiAgICAgIC8vIGJsb2NrZWQgUE9QIG5hdmlnYXRpb25cbiAgICAgIGlmIChpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSkge1xuICAgICAgICBpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3YXJuaW5nKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCB8fCBkZWx0YSAhPSBudWxsLCBcIllvdSBhcmUgdHJ5aW5nIHRvIHVzZSBhIGJsb2NrZXIgb24gYSBQT1AgbmF2aWdhdGlvbiB0byBhIGxvY2F0aW9uIFwiICsgXCJ0aGF0IHdhcyBub3QgY3JlYXRlZCBieSBAcmVtaXgtcnVuL3JvdXRlci4gVGhpcyB3aWxsIGZhaWwgc2lsZW50bHkgaW4gXCIgKyBcInByb2R1Y3Rpb24uIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgYXJlIG5hdmlnYXRpbmcgb3V0c2lkZSB0aGUgcm91dGVyIFwiICsgXCJ2aWEgYHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZWAvYHdpbmRvdy5sb2NhdGlvbi5oYXNoYCBpbnN0ZWFkIG9mIHVzaW5nIFwiICsgXCJyb3V0ZXIgbmF2aWdhdGlvbiBBUElzLiAgVGhpcyBjYW4gYWxzbyBoYXBwZW4gaWYgeW91IGFyZSB1c2luZyBcIiArIFwiY3JlYXRlSGFzaFJvdXRlciBhbmQgdGhlIHVzZXIgbWFudWFsbHkgY2hhbmdlcyB0aGUgVVJMLlwiKTtcbiAgICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgaGlzdG9yeUFjdGlvblxuICAgICAgfSk7XG4gICAgICBpZiAoYmxvY2tlcktleSAmJiBkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIFVSTCB0byBtYXRjaCB0aGUgY3VycmVudCBVSSwgYnV0IGRvbid0IHVwZGF0ZSByb3V0ZXIgc3RhdGVcbiAgICAgICAgaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUgPSB0cnVlO1xuICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEgKiAtMSk7XG4gICAgICAgIC8vIFB1dCB0aGUgYmxvY2tlciBpbnRvIGEgYmxvY2tlZCBzdGF0ZVxuICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICBzdGF0ZTogXCJibG9ja2VkXCIsXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICAgIHByb2NlZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgbG9jYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gUmUtZG8gdGhlIHNhbWUgUE9QIG5hdmlnYXRpb24gd2UganVzdCBibG9ja2VkXG4gICAgICAgICAgICBpbml0Lmhpc3RvcnkuZ28oZGVsdGEpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICAgIGJsb2NrZXJzLnNldChibG9ja2VyS2V5LCBJRExFX0JMT0NLRVIpO1xuICAgICAgICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICAgICAgICBibG9ja2Vyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbik7XG4gICAgfSk7XG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgLy8gRklYTUU6IFRoaXMgZmVlbHMgZ3Jvc3MuICBIb3cgY2FuIHdlIGNsZWFudXAgdGhlIGxpbmVzIGJldHdlZW5cbiAgICAgIC8vIHNjcm9sbFJlc3RvcmF0aW9uL2FwcGxpZWRUcmFuc2l0aW9ucyBwZXJzaXN0YW5jZT9cbiAgICAgIHJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIGxldCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyA9ICgpID0+IHBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIHJvdXRlcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMpO1xuICAgICAgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyID0gKCkgPT4gcm91dGVyV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyk7XG4gICAgfVxuICAgIC8vIEtpY2sgb2ZmIGluaXRpYWwgZGF0YSBsb2FkIGlmIG5lZWRlZC4gIFVzZSBQb3AgdG8gYXZvaWQgbW9kaWZ5aW5nIGhpc3RvcnlcbiAgICAvLyBOb3RlIHdlIGRvbid0IGRvIGFueSBoYW5kbGluZyBvZiBsYXp5IGhlcmUuICBGb3IgU1BBJ3MgaXQnbGwgZ2V0IGhhbmRsZWRcbiAgICAvLyBpbiB0aGUgbm9ybWFsIG5hdmlnYXRpb24gZmxvdy4gIEZvciBTU1IgaXQncyBleHBlY3RlZCB0aGF0IGxhenkgbW9kdWxlcyBhcmVcbiAgICAvLyByZXNvbHZlZCBwcmlvciB0byByb3V0ZXIgY3JlYXRpb24gc2luY2Ugd2UgY2FuJ3QgZ28gaW50byBhIGZhbGxiYWNrRWxlbWVudFxuICAgIC8vIFVJIGZvciBTU1InZCBhcHBzXG4gICAgaWYgKCFzdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgc3RhcnROYXZpZ2F0aW9uKEFjdGlvbi5Qb3AsIHN0YXRlLmxvY2F0aW9uLCB7XG4gICAgICAgIGluaXRpYWxIeWRyYXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGVyO1xuICB9XG4gIC8vIENsZWFuIHVwIGEgcm91dGVyIGFuZCBpdCdzIHNpZGUgZWZmZWN0c1xuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICh1bmxpc3Rlbkhpc3RvcnkpIHtcbiAgICAgIHVubGlzdGVuSGlzdG9yeSgpO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyKSB7XG4gICAgICByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIoKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoXywga2V5KSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xuICAgIHN0YXRlLmJsb2NrZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlQmxvY2tlcihrZXkpKTtcbiAgfVxuICAvLyBTdWJzY3JpYmUgdG8gc3RhdGUgdXBkYXRlcyBmb3IgdGhlIHJvdXRlclxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZm4pIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoZm4pO1xuICAgIHJldHVybiAoKSA9PiBzdWJzY3JpYmVycy5kZWxldGUoZm4pO1xuICB9XG4gIC8vIFVwZGF0ZSBvdXIgc3RhdGUgYW5kIG5vdGlmeSB0aGUgY2FsbGluZyBjb250ZXh0IG9mIHRoZSBjaGFuZ2VcbiAgZnVuY3Rpb24gdXBkYXRlU3RhdGUobmV3U3RhdGUsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIHN0YXRlID0gX2V4dGVuZHMoe30sIHN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgLy8gUHJlcCBmZXRjaGVyIGNsZWFudXAgc28gd2UgY2FuIHRlbGwgdGhlIFVJIHdoaWNoIGZldGNoZXIgZGF0YSBlbnRyaWVzXG4gICAgLy8gY2FuIGJlIHJlbW92ZWRcbiAgICBsZXQgY29tcGxldGVkRmV0Y2hlcnMgPSBbXTtcbiAgICBsZXQgZGVsZXRlZEZldGNoZXJzS2V5cyA9IFtdO1xuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QpIHtcbiAgICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKGZldGNoZXIsIGtleSkgPT4ge1xuICAgICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgICBpZiAoZGVsZXRlZEZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAvLyBVbm1vdW50ZWQgZnJvbSB0aGUgVUkgYW5kIGNhbiBiZSB0b3RhbGx5IHJlbW92ZWRcbiAgICAgICAgICAgIGRlbGV0ZWRGZXRjaGVyc0tleXMucHVzaChrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXR1cm5lZCB0byBpZGxlIGJ1dCBzdGlsbCBtb3VudGVkIGluIHRoZSBVSSwgc28gc2VtaS1yZW1haW5zIGZvclxuICAgICAgICAgICAgLy8gcmV2YWxpZGF0aW9ucyBhbmQgc3VjaFxuICAgICAgICAgICAgY29tcGxldGVkRmV0Y2hlcnMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEl0ZXJhdGUgb3ZlciBhIGxvY2FsIGNvcHkgc28gdGhhdCBpZiBmbHVzaFN5bmMgaXMgdXNlZCBhbmQgd2UgZW5kIHVwXG4gICAgLy8gcmVtb3ZpbmcgYW5kIGFkZGluZyBhIG5ldyBzdWJzY3JpYmVyIGR1ZSB0byB0aGUgdXNlQ2FsbGJhY2sgZGVwZW5kZW5jaWVzLFxuICAgIC8vIHdlIGRvbid0IGdldCBvdXJzZWx2ZXMgaW50byBhIGxvb3AgY2FsbGluZyB0aGUgbmV3IHN1YnNjcmliZXIgaW1tZWRpYXRlbHlcbiAgICBbLi4uc3Vic2NyaWJlcnNdLmZvckVhY2goc3Vic2NyaWJlciA9PiBzdWJzY3JpYmVyKHN0YXRlLCB7XG4gICAgICBkZWxldGVkRmV0Y2hlcnM6IGRlbGV0ZWRGZXRjaGVyc0tleXMsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHM6IG9wdHMudmlld1RyYW5zaXRpb25PcHRzLFxuICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgIH0pKTtcbiAgICAvLyBSZW1vdmUgaWRsZSBmZXRjaGVycyBmcm9tIHN0YXRlIHNpbmNlIHdlIG9ubHkgY2FyZSBhYm91dCBpbi1mbGlnaHQgZmV0Y2hlcnMuXG4gICAgaWYgKGZ1dHVyZS52N19mZXRjaGVyUGVyc2lzdCkge1xuICAgICAgY29tcGxldGVkRmV0Y2hlcnMuZm9yRWFjaChrZXkgPT4gc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSkpO1xuICAgICAgZGVsZXRlZEZldGNoZXJzS2V5cy5mb3JFYWNoKGtleSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xuICAgIH1cbiAgfVxuICAvLyBDb21wbGV0ZSBhIG5hdmlnYXRpb24gcmV0dXJuaW5nIHRoZSBzdGF0ZS5uYXZpZ2F0aW9uIGJhY2sgdG8gdGhlIElETEVfTkFWSUdBVElPTlxuICAvLyBhbmQgc2V0dGluZyBzdGF0ZS5baGlzdG9yeUFjdGlvbi9sb2NhdGlvbi9tYXRjaGVzXSB0byB0aGUgbmV3IHJvdXRlLlxuICAvLyAtIExvY2F0aW9uIGlzIGEgcmVxdWlyZWQgcGFyYW1cbiAgLy8gLSBOYXZpZ2F0aW9uIHdpbGwgYWx3YXlzIGJlIHNldCB0byBJRExFX05BVklHQVRJT05cbiAgLy8gLSBDYW4gcGFzcyBhbnkgb3RoZXIgc3RhdGUgaW4gbmV3U3RhdGVcbiAgZnVuY3Rpb24gY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBuZXdTdGF0ZSwgX3RlbXApIHtcbiAgICB2YXIgX2xvY2F0aW9uJHN0YXRlLCBfbG9jYXRpb24kc3RhdGUyO1xuICAgIGxldCB7XG4gICAgICBmbHVzaFN5bmNcbiAgICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gICAgLy8gRGVkdWNlIGlmIHdlJ3JlIGluIGEgbG9hZGluZy9hY3Rpb25SZWxvYWQgc3RhdGU6XG4gICAgLy8gLSBXZSBoYXZlIGNvbW1pdHRlZCBhY3Rpb25EYXRhIGluIHRoZSBzdG9yZVxuICAgIC8vIC0gVGhlIGN1cnJlbnQgbmF2aWdhdGlvbiB3YXMgYSBtdXRhdGlvbiBzdWJtaXNzaW9uXG4gICAgLy8gLSBXZSdyZSBwYXN0IHRoZSBzdWJtaXR0aW5nIHN0YXRlIGFuZCBpbnRvIHRoZSBsb2FkaW5nIHN0YXRlXG4gICAgLy8gLSBUaGUgbG9jYXRpb24gYmVpbmcgbG9hZGVkIGlzIG5vdCB0aGUgcmVzdWx0IG9mIGEgcmVkaXJlY3RcbiAgICBsZXQgaXNBY3Rpb25SZWxvYWQgPSBzdGF0ZS5hY3Rpb25EYXRhICE9IG51bGwgJiYgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmICgoX2xvY2F0aW9uJHN0YXRlID0gbG9jYXRpb24uc3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfbG9jYXRpb24kc3RhdGUuX2lzUmVkaXJlY3QpICE9PSB0cnVlO1xuICAgIGxldCBhY3Rpb25EYXRhO1xuICAgIGlmIChuZXdTdGF0ZS5hY3Rpb25EYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMobmV3U3RhdGUuYWN0aW9uRGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICBhY3Rpb25EYXRhID0gbmV3U3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVtcHR5IGFjdGlvbkRhdGEgLT4gY2xlYXIgcHJpb3IgYWN0aW9uRGF0YSBkdWUgdG8gYW4gYWN0aW9uIGVycm9yXG4gICAgICAgIGFjdGlvbkRhdGEgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBY3Rpb25SZWxvYWQpIHtcbiAgICAgIC8vIEtlZXAgdGhlIGN1cnJlbnQgZGF0YSBpZiB3ZSdyZSB3cmFwcGluZyB1cCB0aGUgYWN0aW9uIHJlbG9hZFxuICAgICAgYWN0aW9uRGF0YSA9IHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFyIGFjdGlvbkRhdGEgb24gYW55IG90aGVyIGNvbXBsZXRlZCBuYXZpZ2F0aW9uc1xuICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIC8vIEFsd2F5cyBwcmVzZXJ2ZSBhbnkgZXhpc3RpbmcgbG9hZGVyRGF0YSBmcm9tIHJlLXVzZWQgcm91dGVzXG4gICAgbGV0IGxvYWRlckRhdGEgPSBuZXdTdGF0ZS5sb2FkZXJEYXRhID8gbWVyZ2VMb2FkZXJEYXRhKHN0YXRlLmxvYWRlckRhdGEsIG5ld1N0YXRlLmxvYWRlckRhdGEsIG5ld1N0YXRlLm1hdGNoZXMgfHwgW10sIG5ld1N0YXRlLmVycm9ycykgOiBzdGF0ZS5sb2FkZXJEYXRhO1xuICAgIC8vIE9uIGEgc3VjY2Vzc2Z1bCBuYXZpZ2F0aW9uIHdlIGNhbiBhc3N1bWUgd2UgZ290IHRocm91Z2ggYWxsIGJsb2NrZXJzXG4gICAgLy8gc28gd2UgY2FuIHN0YXJ0IGZyZXNoXG4gICAgbGV0IGJsb2NrZXJzID0gc3RhdGUuYmxvY2tlcnM7XG4gICAgaWYgKGJsb2NrZXJzLnNpemUgPiAwKSB7XG4gICAgICBibG9ja2VycyA9IG5ldyBNYXAoYmxvY2tlcnMpO1xuICAgICAgYmxvY2tlcnMuZm9yRWFjaCgoXywgaykgPT4gYmxvY2tlcnMuc2V0KGssIElETEVfQkxPQ0tFUikpO1xuICAgIH1cbiAgICAvLyBBbHdheXMgcmVzcGVjdCB0aGUgdXNlciBmbGFnLiAgT3RoZXJ3aXNlIGRvbid0IHJlc2V0IG9uIG11dGF0aW9uXG4gICAgLy8gc3VibWlzc2lvbiBuYXZpZ2F0aW9ucyB1bmxlc3MgdGhleSByZWRpcmVjdFxuICAgIGxldCBwcmV2ZW50U2Nyb2xsUmVzZXQgPSBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlIHx8IHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCAhPSBudWxsICYmIGlzTXV0YXRpb25NZXRob2Qoc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kKSAmJiAoKF9sb2NhdGlvbiRzdGF0ZTIgPSBsb2NhdGlvbi5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sb2NhdGlvbiRzdGF0ZTIuX2lzUmVkaXJlY3QpICE9PSB0cnVlO1xuICAgIGlmIChpbkZsaWdodERhdGFSb3V0ZXMpIHtcbiAgICAgIGRhdGFSb3V0ZXMgPSBpbkZsaWdodERhdGFSb3V0ZXM7XG4gICAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pIDsgZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gQWN0aW9uLlBvcCkgOyBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBBY3Rpb24uUHVzaCkge1xuICAgICAgaW5pdC5oaXN0b3J5LnB1c2gobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5SZXBsYWNlKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH1cbiAgICBsZXQgdmlld1RyYW5zaXRpb25PcHRzO1xuICAgIC8vIE9uIFBPUCwgZW5hYmxlIHRyYW5zaXRpb25zIGlmIHRoZXkgd2VyZSBlbmFibGVkIG9uIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uXG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5Qb3ApIHtcbiAgICAgIC8vIEZvcndhcmQgdGFrZXMgcHJlY2VkZW5jZSBzbyB0aGV5IGJlaGF2ZSBsaWtlIHRoZSBvcmlnaW5hbCBuYXZpZ2F0aW9uXG4gICAgICBsZXQgcHJpb3JQYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmIChwcmlvclBhdGhzICYmIHByaW9yUGF0aHMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcHJldmlvdXMgZm9yd2FyZCBuYXYsIGFzc3VtZSB3ZSdyZSBwb3BwaW5nIGJhY2sgdG9cbiAgICAgICAgLy8gdGhlIG5ldyBsb2NhdGlvbiBhbmQgZW5hYmxlIGlmIHRoYXQgbG9jYXRpb24gcHJldmlvdXNseSBlbmFibGVkXG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogc3RhdGUubG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQpIHtcbiAgICAgIC8vIFN0b3JlIHRoZSBhcHBsaWVkIHRyYW5zaXRpb24gb24gUFVTSC9SRVBMQUNFXG4gICAgICBsZXQgdG9QYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmICh0b1BhdGhzKSB7XG4gICAgICAgIHRvUGF0aHMuYWRkKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvUGF0aHMgPSBuZXcgU2V0KFtsb2NhdGlvbi5wYXRobmFtZV0pO1xuICAgICAgICBhcHBsaWVkVmlld1RyYW5zaXRpb25zLnNldChzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSwgdG9QYXRocyk7XG4gICAgICB9XG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKF9leHRlbmRzKHt9LCBuZXdTdGF0ZSwge1xuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBoaXN0b3J5QWN0aW9uOiBwZW5kaW5nQWN0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG5ld1N0YXRlLm1hdGNoZXMgfHwgc3RhdGUubWF0Y2hlcyksXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICBibG9ja2Vyc1xuICAgIH0pLCB7XG4gICAgICB2aWV3VHJhbnNpdGlvbk9wdHMsXG4gICAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgIH0pO1xuICAgIC8vIFJlc2V0IHN0YXRlZnVsIG5hdmlnYXRpb24gdmFyc1xuICAgIHBlbmRpbmdBY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSBmYWxzZTtcbiAgICBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzID0gW107XG4gICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzID0gW107XG4gIH1cbiAgLy8gVHJpZ2dlciBhIG5hdmlnYXRpb24gZXZlbnQsIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBudW1lcmljYWwgUE9QIG9yIGEgUFVTSFxuICAvLyByZXBsYWNlIHdpdGggYW4gb3B0aW9uYWwgc3VibWlzc2lvblxuICBhc3luYyBmdW5jdGlvbiBuYXZpZ2F0ZSh0bywgb3B0cykge1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5nbyh0byk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3ByZXBlbmRCYXNlbmFtZSwgdG8sIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mcm9tUm91dGVJZCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZWxhdGl2ZSk7XG4gICAgbGV0IHtcbiAgICAgIHBhdGgsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZXJyb3JcbiAgICB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKGZ1dHVyZS52N19ub3JtYWxpemVGb3JtTWV0aG9kLCBmYWxzZSwgbm9ybWFsaXplZFBhdGgsIG9wdHMpO1xuICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIHBhdGgsIG9wdHMgJiYgb3B0cy5zdGF0ZSk7XG4gICAgLy8gV2hlbiB1c2luZyBuYXZpZ2F0ZSBhcyBhIFBVU0gvUkVQTEFDRSB3ZSBhcmVuJ3QgcmVhZGluZyBhbiBhbHJlYWR5LWVuY29kZWRcbiAgICAvLyBVUkwgZnJvbSB3aW5kb3cubG9jYXRpb24sIHNvIHdlIG5lZWQgdG8gZW5jb2RlIGl0IGhlcmUgc28gdGhlIGJlaGF2aW9yXG4gICAgLy8gcmVtYWlucyB0aGUgc2FtZSBhcyBQT1AgYW5kIG5vbi1kYXRhLXJvdXRlciB1c2FnZXMuICBuZXcgVVJMKCkgZG9lcyBhbGxcbiAgICAvLyB0aGUgc2FtZSBlbmNvZGluZyB3ZSdkIGdldCBmcm9tIGEgaGlzdG9yeS5wdXNoU3RhdGUvd2luZG93LmxvY2F0aW9uIHJlYWRcbiAgICAvLyB3aXRob3V0IGhhdmluZyB0byB0b3VjaCBoaXN0b3J5XG4gICAgbmV4dExvY2F0aW9uID0gX2V4dGVuZHMoe30sIG5leHRMb2NhdGlvbiwgaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKG5leHRMb2NhdGlvbikpO1xuICAgIGxldCB1c2VyUmVwbGFjZSA9IG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwgPyBvcHRzLnJlcGxhY2UgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGhpc3RvcnlBY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICBpZiAodXNlclJlcGxhY2UgPT09IHRydWUpIHtcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICB9IGVsc2UgaWYgKHVzZXJSZXBsYWNlID09PSBmYWxzZSkgOyBlbHNlIGlmIChzdWJtaXNzaW9uICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpICYmIHN1Ym1pc3Npb24uZm9ybUFjdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIC8vIEJ5IGRlZmF1bHQgb24gc3VibWlzc2lvbnMgdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24gd2UgUkVQTEFDRSBzbyB0aGF0XG4gICAgICAvLyB1c2VycyBkb24ndCBoYXZlIHRvIGRvdWJsZS1jbGljayB0aGUgYmFjayBidXR0b24gdG8gZ2V0IHRvIHRoZSBwcmlvclxuICAgICAgLy8gbG9jYXRpb24uICBJZiB0aGUgdXNlciByZWRpcmVjdHMgdG8gYSBkaWZmZXJlbnQgbG9jYXRpb24gZnJvbSB0aGVcbiAgICAgIC8vIGFjdGlvbi9sb2FkZXIgdGhpcyB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSByZWRpcmVjdCB3aWxsIGJlIGEgUFVTSFxuICAgICAgaGlzdG9yeUFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIH1cbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID0gb3B0cyAmJiBcInByZXZlbnRTY3JvbGxSZXNldFwiIGluIG9wdHMgPyBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy51bnN0YWJsZV9mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9KTtcbiAgICBpZiAoYmxvY2tlcktleSkge1xuICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBTZW5kIHRoZSBzYW1lIG5hdmlnYXRpb24gdGhyb3VnaFxuICAgICAgICAgIG5hdmlnYXRlKHRvLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICAgICAgYmxvY2tlcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbmV4dExvY2F0aW9uLCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgLy8gU2VuZCB0aHJvdWdoIHRoZSBmb3JtRGF0YSBzZXJpYWxpemF0aW9uIGVycm9yIGlmIHdlIGhhdmUgb25lIHNvIHdlIGNhblxuICAgICAgLy8gcmVuZGVyIGF0IHRoZSByaWdodCBlcnJvciBib3VuZGFyeSBhZnRlciB3ZSBtYXRjaCByb3V0ZXNcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZXBsYWNlOiBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBvcHRzICYmIG9wdHMudW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgfVxuICAvLyBSZXZhbGlkYXRlIGFsbCBjdXJyZW50IGxvYWRlcnMuICBJZiBhIG5hdmlnYXRpb24gaXMgaW4gcHJvZ3Jlc3Mgb3IgaWYgdGhpc1xuICAvLyBpcyBpbnRlcnJ1cHRlZCBieSBhIG5hdmlnYXRpb24sIGFsbG93IHRoaXMgdG8gXCJzdWNjZWVkXCIgYnkgY2FsbGluZyBhbGxcbiAgLy8gbG9hZGVycyBkdXJpbmcgdGhlIG5leHQgbG9hZGVyIHJvdW5kXG4gIGZ1bmN0aW9uIHJldmFsaWRhdGUoKSB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICByZXZhbGlkYXRpb246IFwibG9hZGluZ1wiXG4gICAgfSk7XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IHN1Ym1pdHRpbmcgYW4gYWN0aW9uLCB3ZSBkb24ndCBuZWVkIHRvIHN0YXJ0IGEgbmV3XG4gICAgLy8gbmF2aWdhdGlvbiwgd2UnbGwganVzdCBsZXQgdGhlIGZvbGxvdyB1cCBsb2FkZXIgZXhlY3V0aW9uIGNhbGwgYWxsIGxvYWRlcnNcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJzdWJtaXR0aW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluIGFuIGlkbGUgc3RhdGUsIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24gZm9yIHRoZSBjdXJyZW50XG4gICAgLy8gYWN0aW9uL2xvY2F0aW9uIGFuZCBtYXJrIGl0IGFzIHVuaW50ZXJydXB0ZWQsIHdoaWNoIHdpbGwgc2tpcCB0aGUgaGlzdG9yeVxuICAgIC8vIHVwZGF0ZSBpbiBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5sb2NhdGlvbiwge1xuICAgICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGlmIHdlJ3JlIGN1cnJlbnRseSBpbiBhIGxvYWRpbmcgc3RhdGUsIGp1c3Qgc3RhcnQgYSBuZXdcbiAgICAvLyBuYXZpZ2F0aW9uIHRvIHRoZSBuYXZpZ2F0aW9uLmxvY2F0aW9uIGJ1dCBkbyBub3QgdHJpZ2dlciBhbiB1bmludGVycnVwdGVkXG4gICAgLy8gcmV2YWxpZGF0aW9uIHNvIHRoYXQgaGlzdG9yeSBjb3JyZWN0bHkgdXBkYXRlcyBvbmNlIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlc1xuICAgIHN0YXJ0TmF2aWdhdGlvbihwZW5kaW5nQWN0aW9uIHx8IHN0YXRlLmhpc3RvcnlBY3Rpb24sIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIHtcbiAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbjogc3RhdGUubmF2aWdhdGlvblxuICAgIH0pO1xuICB9XG4gIC8vIFN0YXJ0IGEgbmF2aWdhdGlvbiB0byB0aGUgZ2l2ZW4gYWN0aW9uL2xvY2F0aW9uLiAgQ2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhXG4gIC8vIG92ZXJyaWRlTmF2aWdhdGlvbiB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBub3JtYWxMb2FkIGluIHRoZSBjYXNlIG9mIGEgcmVkaXJlY3RcbiAgLy8gbmF2aWdhdGlvblxuICBhc3luYyBmdW5jdGlvbiBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIG9wdHMpIHtcbiAgICAvLyBBYm9ydCBhbnkgaW4tcHJvZ3Jlc3MgbmF2aWdhdGlvbnMgYW5kIHN0YXJ0IGEgbmV3IG9uZS4gVW5zZXQgYW55IG9uZ29pbmdcbiAgICAvLyB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbnMgdW5sZXNzIHRvbGQgb3RoZXJ3aXNlLCBzaW5jZSB3ZSB3YW50IHRoaXNcbiAgICAvLyBuZXcgbmF2aWdhdGlvbiB0byB1cGRhdGUgaGlzdG9yeSBub3JtYWxseVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBoaXN0b3J5QWN0aW9uO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IChvcHRzICYmIG9wdHMuc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSA9PT0gdHJ1ZTtcbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBldmVyeSB0aW1lIHdlIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24sXG4gICAgLy8gYW5kIHRyYWNrIHdoZXRoZXIgd2Ugc2hvdWxkIHJlc2V0IHNjcm9sbCBvbiBjb21wbGV0aW9uXG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuICAgIHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSAob3B0cyAmJiBvcHRzLmVuYWJsZVZpZXdUcmFuc2l0aW9uKSA9PT0gdHJ1ZTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvcHRzICYmIG9wdHMub3ZlcnJpZGVOYXZpZ2F0aW9uO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcbiAgICAvLyBTaG9ydCBjaXJjdWl0IHdpdGggYSA0MDQgb24gdGhlIHJvb3QgZXJyb3IgYm91bmRhcnkgaWYgd2UgbWF0Y2ggbm90aGluZ1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KTtcbiAgICAgIGxldCB7XG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgcm91dGVcbiAgICAgIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlc1RvVXNlKTtcbiAgICAgIC8vIENhbmNlbCBhbGwgcGVuZGluZyBkZWZlcnJlZCBvbiA0MDRzIHNpbmNlIHdlIGRvbid0IGtlZXAgYW55IHJvdXRlc1xuICAgICAgY2FuY2VsQWN0aXZlRGVmZXJyZWRzKCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIGl0J3Mgb25seSBhIGhhc2ggY2hhbmdlIGFuZCBub3QgYSByZXZhbGlkYXRpb24gb3JcbiAgICAvLyBtdXRhdGlvbiBzdWJtaXNzaW9uLlxuICAgIC8vXG4gICAgLy8gSWdub3JlIG9uIGluaXRpYWwgcGFnZSBsb2FkcyBiZWNhdXNlIHNpbmNlIHRoZSBpbml0aWFsIGxvYWQgd2lsbCBhbHdheXNcbiAgICAvLyBiZSBcInNhbWUgaGFzaFwiLiAgRm9yIGV4YW1wbGUsIG9uIC9wYWdlI2hhc2ggYW5kIHN1Ym1pdCBhIDxGb3JtIG1ldGhvZD1cInBvc3RcIj5cbiAgICAvLyB3aGljaCB3aWxsIGRlZmF1bHQgdG8gYSBuYXZpZ2F0aW9uIHRvIC9wYWdlXG4gICAgaWYgKHN0YXRlLmluaXRpYWxpemVkICYmICFpc1JldmFsaWRhdGlvblJlcXVpcmVkICYmIGlzSGFzaENoYW5nZU9ubHkoc3RhdGUubG9jYXRpb24sIGxvY2F0aW9uKSAmJiAhKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXNcbiAgICAgIH0sIHtcbiAgICAgICAgZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgY29udHJvbGxlci9SZXF1ZXN0IGZvciB0aGlzIG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIGxvY2F0aW9uLCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLCBvcHRzICYmIG9wdHMuc3VibWlzc2lvbik7XG4gICAgbGV0IHBlbmRpbmdBY3Rpb25EYXRhO1xuICAgIGxldCBwZW5kaW5nRXJyb3I7XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5wZW5kaW5nRXJyb3IpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nRXJyb3IsIGl0IG1lYW5zIHRoZSB1c2VyIGF0dGVtcHRlZCBhIEdFVCBzdWJtaXNzaW9uXG4gICAgICAvLyB3aXRoIGJpbmFyeSBGb3JtRGF0YSBzbyBhc3NpZ24gaGVyZSBhbmQgc2tpcCB0byBoYW5kbGVMb2FkZXJzLiAgVGhhdFxuICAgICAgLy8gd2F5IHdlIGhhbmRsZSBjYWxsaW5nIGxvYWRlcnMgYWJvdmUgdGhlIGJvdW5kYXJ5IGV0Yy4gIEl0J3Mgbm90IHJlYWxseVxuICAgICAgLy8gZGlmZmVyZW50IGZyb20gYW4gYWN0aW9uRXJyb3IgaW4gdGhhdCBzZW5zZS5cbiAgICAgIHBlbmRpbmdFcnJvciA9IHtcbiAgICAgICAgW2ZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcykucm91dGUuaWRdOiBvcHRzLnBlbmRpbmdFcnJvclxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICAvLyBDYWxsIGFjdGlvbiBpZiB3ZSByZWNlaXZlZCBhbiBhY3Rpb24gc3VibWlzc2lvblxuICAgICAgbGV0IGFjdGlvbk91dHB1dCA9IGF3YWl0IGhhbmRsZUFjdGlvbihyZXF1ZXN0LCBsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uLCBtYXRjaGVzLCB7XG4gICAgICAgIHJlcGxhY2U6IG9wdHMucmVwbGFjZSxcbiAgICAgICAgZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICAgIGlmIChhY3Rpb25PdXRwdXQuc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkRhdGE7XG4gICAgICBwZW5kaW5nRXJyb3IgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkVycm9yO1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uKTtcbiAgICAgIGZsdXNoU3luYyA9IGZhbHNlO1xuICAgICAgLy8gQ3JlYXRlIGEgR0VUIHJlcXVlc3QgZm9yIHRoZSBsb2FkZXJzXG4gICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENhbGwgbG9hZGVyc1xuICAgIGxldCB7XG4gICAgICBzaG9ydENpcmN1aXRlZCxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9ID0gYXdhaXQgaGFuZGxlTG9hZGVycyhyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgbG9hZGluZ05hdmlnYXRpb24sIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uLCBvcHRzICYmIG9wdHMuZmV0Y2hlclN1Ym1pc3Npb24sIG9wdHMgJiYgb3B0cy5yZXBsYWNlLCBvcHRzICYmIG9wdHMuaW5pdGlhbEh5ZHJhdGlvbiA9PT0gdHJ1ZSwgZmx1c2hTeW5jLCBwZW5kaW5nQWN0aW9uRGF0YSwgcGVuZGluZ0Vycm9yKTtcbiAgICBpZiAoc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgbm93IHRoYXQgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgY29tcGxldGVkLiAgRG9uJ3QgY2xlYW4gdXAgaWZcbiAgICAvLyB3ZSBzaG9ydCBjaXJjdWl0ZWQgYmVjYXVzZSBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgd2lsbCBoYXZlIGFscmVhZHlcbiAgICAvLyBiZWVuIGFzc2lnbmVkIHRvIGEgbmV3IGNvbnRyb2xsZXIgZm9yIHRoZSBuZXh0IG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIGNvbXBsZXRlTmF2aWdhdGlvbihsb2NhdGlvbiwgX2V4dGVuZHMoe1xuICAgICAgbWF0Y2hlc1xuICAgIH0sIHBlbmRpbmdBY3Rpb25EYXRhID8ge1xuICAgICAgYWN0aW9uRGF0YTogcGVuZGluZ0FjdGlvbkRhdGFcbiAgICB9IDoge30sIHtcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9KSk7XG4gIH1cbiAgLy8gQ2FsbCB0aGUgYWN0aW9uIG1hdGNoZWQgYnkgdGhlIGxlYWYgcm91dGUgZm9yIHRoaXMgbmF2aWdhdGlvbiBhbmQgaGFuZGxlXG4gIC8vIHJlZGlyZWN0cy9lcnJvcnNcbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlQWN0aW9uKHJlcXVlc3QsIGxvY2F0aW9uLCBzdWJtaXNzaW9uLCBtYXRjaGVzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIC8vIFB1dCB1cyBpbiBhIHN1Ym1pdHRpbmcgc3RhdGVcbiAgICBsZXQgbmF2aWdhdGlvbiA9IGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICBuYXZpZ2F0aW9uXG4gICAgfSwge1xuICAgICAgZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZVxuICAgIH0pO1xuICAgIC8vIENhbGwgb3VyIGFjdGlvbiBhbmQgZ2V0IHRoZSByZXN1bHRcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBhY3Rpb25NYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFwiYWN0aW9uXCIsIHJlcXVlc3QsIGFjdGlvbk1hdGNoLCBtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IHJlcGxhY2U7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCkge1xuICAgICAgICByZXBsYWNlID0gb3B0cy5yZXBsYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZGlkbid0IGV4cGxpY2l0eSBpbmRpY2F0ZSByZXBsYWNlIGJlaGF2aW9yLCByZXBsYWNlIGlmXG4gICAgICAgIC8vIHdlIHJlZGlyZWN0ZWQgdG8gdGhlIGV4YWN0IHNhbWUgbG9jYXRpb24gd2UncmUgY3VycmVudGx5IGF0IHRvIGF2b2lkXG4gICAgICAgIC8vIGRvdWJsZSBiYWNrLWJ1dHRvbnNcbiAgICAgICAgcmVwbGFjZSA9IHJlc3VsdC5sb2NhdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVzdWx0LCB7XG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIHJlcGxhY2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIGFsbCBzdWJtaXNzaW9ucyBhcmUgUkVQTEFDRSBuYXZpZ2F0aW9ucywgYnV0IGlmIHRoZVxuICAgICAgLy8gYWN0aW9uIHRocmV3IGFuIGVycm9yIHRoYXQnbGwgYmUgcmVuZGVyZWQgaW4gYW4gZXJyb3JFbGVtZW50LCB3ZSBmYWxsXG4gICAgICAvLyBiYWNrIHRvIFBVU0ggc28gdGhhdCB0aGUgdXNlciBjYW4gdXNlIHRoZSBiYWNrIGJ1dHRvbiB0byBnZXQgYmFjayB0b1xuICAgICAgLy8gdGhlIHByZS1zdWJtaXNzaW9uIGZvcm0gbG9jYXRpb24gdG8gdHJ5IGFnYWluXG4gICAgICBpZiAoKG9wdHMgJiYgb3B0cy5yZXBsYWNlKSAhPT0gdHJ1ZSkge1xuICAgICAgICBwZW5kaW5nQWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBTZW5kIGJhY2sgYW4gZW1wdHkgb2JqZWN0IHdlIGNhbiB1c2UgdG8gY2xlYXIgb3V0IGFueSBwcmlvciBhY3Rpb25EYXRhXG4gICAgICAgIHBlbmRpbmdBY3Rpb25EYXRhOiB7fSxcbiAgICAgICAgcGVuZGluZ0FjdGlvbkVycm9yOiB7XG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgdHlwZTogXCJkZWZlci1hY3Rpb25cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLy8gQ2FsbCBhbGwgYXBwbGljYWJsZSBsb2FkZXJzIGZvciB0aGUgZ2l2ZW4gbWF0Y2hlcywgaGFuZGxpbmcgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVycyhyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgb3ZlcnJpZGVOYXZpZ2F0aW9uLCBzdWJtaXNzaW9uLCBmZXRjaGVyU3VibWlzc2lvbiwgcmVwbGFjZSwgaW5pdGlhbEh5ZHJhdGlvbiwgZmx1c2hTeW5jLCBwZW5kaW5nQWN0aW9uRGF0YSwgcGVuZGluZ0Vycm9yKSB7XG4gICAgLy8gRmlndXJlIG91dCB0aGUgcmlnaHQgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIHVzZSBmb3IgZGF0YSBsb2FkaW5nXG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3ZlcnJpZGVOYXZpZ2F0aW9uIHx8IGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICAvLyBJZiB0aGlzIHdhcyBhIHJlZGlyZWN0IGZyb20gYW4gYWN0aW9uIHdlIGRvbid0IGhhdmUgYSBcInN1Ym1pc3Npb25cIiBidXRcbiAgICAvLyB3ZSBoYXZlIGl0IG9uIHRoZSBsb2FkaW5nIG5hdmlnYXRpb24gc28gdXNlIHRoYXQgaWYgYXZhaWxhYmxlXG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uIHx8IGZldGNoZXJTdWJtaXNzaW9uIHx8IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihsb2FkaW5nTmF2aWdhdGlvbik7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IFttYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVyc10gPSBnZXRNYXRjaGVzVG9Mb2FkKGluaXQuaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIGFjdGl2ZVN1Ym1pc3Npb24sIGxvY2F0aW9uLCBmdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbiAmJiBpbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcywgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBkZWxldGVkRmV0Y2hlcnMsIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwgcGVuZGluZ0FjdGlvbkRhdGEsIHBlbmRpbmdFcnJvcik7XG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgZGVmZXJyZWRzIGZvciBuby1sb25nZXItbWF0Y2hlZCByb3V0ZXMgb3Igcm91dGVzIHdlJ3JlXG4gICAgLy8gYWJvdXQgdG8gcmVsb2FkLiAgTm90ZSB0aGF0IGlmIHRoaXMgaXMgYW4gYWN0aW9uIHJlbG9hZCB3ZSB3b3VsZCBoYXZlXG4gICAgLy8gYWxyZWFkeSBjYW5jZWxsZWQgYWxsIHBlbmRpbmcgZGVmZXJyZWRzIHNvIHRoaXMgd291bGQgYmUgYSBuby1vcFxuICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhyb3V0ZUlkID0+ICEobWF0Y2hlcyAmJiBtYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSkgfHwgbWF0Y2hlc1RvTG9hZCAmJiBtYXRjaGVzVG9Mb2FkLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW5cbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDAgJiYgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBfZXh0ZW5kcyh7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAvLyBDb21taXQgcGVuZGluZyBlcnJvciBpZiB3ZSdyZSBzaG9ydCBjaXJjdWl0aW5nXG4gICAgICAgIGVycm9yczogcGVuZGluZ0Vycm9yIHx8IG51bGxcbiAgICAgIH0sIHBlbmRpbmdBY3Rpb25EYXRhID8ge1xuICAgICAgICBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YVxuICAgICAgfSA6IHt9LCB1cGRhdGVkRmV0Y2hlcnMgPyB7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSA6IHt9KSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgYW4gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb24sIHdlIHJlbWFpbiBpbiBvdXIgY3VycmVudCBpZGxlXG4gICAgLy8gc3RhdGUuICBJZiBub3QsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIG91ciBsb2FkaW5nIHN0YXRlIGFuZCBsb2FkIGRhdGEsXG4gICAgLy8gcHJlc2VydmluZyBhbnkgbmV3IGFjdGlvbiBkYXRhIG9yIGV4aXN0aW5nIGFjdGlvbiBkYXRhIChpbiB0aGUgY2FzZSBvZlxuICAgIC8vIGEgcmV2YWxpZGF0aW9uIGludGVycnVwdGluZyBhbiBhY3Rpb25SZWxvYWQpXG4gICAgLy8gSWYgd2UgaGF2ZSBwYXJ0aWFsSHlkcmF0aW9uIGVuYWJsZWQsIHRoZW4gZG9uJ3QgdXBkYXRlIHRoZSBzdGF0ZSBmb3IgdGhlXG4gICAgLy8gaW5pdGlhbCBkYXRhIGxvYWQgc2luY2UgaW90J3Mgbm90IGEgXCJuYXZpZ2F0aW9uXCJcbiAgICBpZiAoIWlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiAmJiAoIWZ1dHVyZS52N19wYXJ0aWFsSHlkcmF0aW9uIHx8ICFpbml0aWFsSHlkcmF0aW9uKSkge1xuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChyZiA9PiB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHJmLmtleSk7XG4gICAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIodW5kZWZpbmVkLCBmZXRjaGVyID8gZmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkKTtcbiAgICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHJmLmtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgICB9KTtcbiAgICAgIGxldCBhY3Rpb25EYXRhID0gcGVuZGluZ0FjdGlvbkRhdGEgfHwgc3RhdGUuYWN0aW9uRGF0YTtcbiAgICAgIHVwZGF0ZVN0YXRlKF9leHRlbmRzKHtcbiAgICAgICAgbmF2aWdhdGlvbjogbG9hZGluZ05hdmlnYXRpb25cbiAgICAgIH0sIGFjdGlvbkRhdGEgPyBPYmplY3Qua2V5cyhhY3Rpb25EYXRhKS5sZW5ndGggPT09IDAgPyB7XG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGxcbiAgICAgIH0gOiB7XG4gICAgICAgIGFjdGlvbkRhdGFcbiAgICAgIH0gOiB7fSwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9IDoge30pLCB7XG4gICAgICAgIGZsdXNoU3luY1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2gocmYgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKHJmLmtleSkpIHtcbiAgICAgICAgYWJvcnRGZXRjaGVyKHJmLmtleSk7XG4gICAgICB9XG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICAvLyBGZXRjaGVycyB1c2UgYW4gaW5kZXBlbmRlbnQgQWJvcnRDb250cm9sbGVyIHNvIHRoYXQgYWJvcnRpbmcgYSBmZXRjaGVyXG4gICAgICAgIC8vICh2aWEgZGVsZXRlRmV0Y2hlcikgZG9lcyBub3QgYWJvcnQgdGhlIHRyaWdnZXJpbmcgbmF2aWdhdGlvbiB0aGF0XG4gICAgICAgIC8vIHRyaWdnZXJlZCB0aGUgcmV2YWxpZGF0aW9uXG4gICAgICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KHJmLmtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gUHJveHkgbmF2aWdhdGlvbiBhYm9ydCB0aHJvdWdoIHRvIHJldmFsaWRhdGlvbiBmZXRjaGVyc1xuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PiByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKGYgPT4gYWJvcnRGZXRjaGVyKGYua2V5KSk7XG4gICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikge1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zKTtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHJlc3VsdHMsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICB9ID0gYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKHN0YXRlLm1hdGNoZXMsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCByZXF1ZXN0KTtcbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIF9hZnRlcl8gbG9hZGVycyBoYXZlIGNvbXBsZXRlZC4gIERvbid0IGNsZWFuIHVwIGlmIHdlIHNob3J0XG4gICAgLy8gY2lyY3VpdGVkIGJlY2F1c2UgZmV0Y2hDb250cm9sbGVycyB3b3VsZCBoYXZlIGJlZW4gYWJvcnRlZCBhbmRcbiAgICAvLyByZWFzc2lnbmVkIHRvIG5ldyBjb250cm9sbGVycyBmb3IgdGhlIG5leHQgbmF2aWdhdGlvblxuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XG4gICAgfVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2gocmYgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUocmYua2V5KSk7XG4gICAgLy8gSWYgYW55IGxvYWRlcnMgcmV0dXJuZWQgYSByZWRpcmVjdCBSZXNwb25zZSwgc3RhcnQgYSBuZXcgUkVQTEFDRSBuYXZpZ2F0aW9uXG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KHJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgaWYgKHJlZGlyZWN0LmlkeCA+PSBtYXRjaGVzVG9Mb2FkLmxlbmd0aCkge1xuICAgICAgICAvLyBJZiB0aGlzIHJlZGlyZWN0IGNhbWUgZnJvbSBhIGZldGNoZXIgbWFrZSBzdXJlIHdlIG1hcmsgaXQgaW5cbiAgICAgICAgLy8gZmV0Y2hSZWRpcmVjdElkcyBzbyBpdCBkb2Vzbid0IGdldCByZXZhbGlkYXRlZCBvbiB0aGUgbmV4dCBzZXQgb2ZcbiAgICAgICAgLy8gbG9hZGVyIGV4ZWN1dGlvbnNcbiAgICAgICAgbGV0IGZldGNoZXJLZXkgPSByZXZhbGlkYXRpbmdGZXRjaGVyc1tyZWRpcmVjdC5pZHggLSBtYXRjaGVzVG9Mb2FkLmxlbmd0aF0ua2V5O1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChmZXRjaGVyS2V5KTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZWRpcmVjdC5yZXN1bHQsIHtcbiAgICAgICAgcmVwbGFjZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaG9ydENpcmN1aXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQge1xuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShzdGF0ZSwgbWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgbG9hZGVyUmVzdWx0cywgcGVuZGluZ0Vycm9yLCByZXZhbGlkYXRpbmdGZXRjaGVycywgZmV0Y2hlclJlc3VsdHMsIGFjdGl2ZURlZmVycmVkcyk7XG4gICAgLy8gV2lyZSB1cCBzdWJzY3JpYmVycyB0byB1cGRhdGUgbG9hZGVyRGF0YSBhcyBwcm9taXNlcyBzZXR0bGVcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGVmZXJyZWREYXRhLCByb3V0ZUlkKSA9PiB7XG4gICAgICBkZWZlcnJlZERhdGEuc3Vic2NyaWJlKGFib3J0ZWQgPT4ge1xuICAgICAgICAvLyBOb3RlOiBObyBuZWVkIHRvIHVwZGF0ZVN0YXRlIGhlcmUgc2luY2UgdGhlIFRyYWNrZWRQcm9taXNlIG9uXG4gICAgICAgIC8vIGxvYWRlckRhdGEgaXMgc3RhYmxlIGFjcm9zcyByZXNvbHZlL3JlamVjdFxuICAgICAgICAvLyBSZW1vdmUgdGhpcyBpbnN0YW5jZSBpZiB3ZSB3ZXJlIGFib3J0ZWQgb3IgaWYgcHJvbWlzZXMgaGF2ZSBzZXR0bGVkXG4gICAgICAgIGlmIChhYm9ydGVkIHx8IGRlZmVycmVkRGF0YS5kb25lKSB7XG4gICAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKTtcbiAgICBsZXQgZGlkQWJvcnRGZXRjaExvYWRzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQpO1xuICAgIGxldCBzaG91bGRVcGRhdGVGZXRjaGVycyA9IHVwZGF0ZWRGZXRjaGVycyB8fCBkaWRBYm9ydEZldGNoTG9hZHMgfHwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMDtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0sIHNob3VsZFVwZGF0ZUZldGNoZXJzID8ge1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSA6IHt9KTtcbiAgfVxuICAvLyBUcmlnZ2VyIGEgZmV0Y2hlciBsb2FkL3N1Ym1pdCBmb3IgdGhlIGdpdmVuIGZldGNoZXIga2V5XG4gIGZ1bmN0aW9uIGZldGNoKGtleSwgcm91dGVJZCwgaHJlZiwgb3B0cykge1xuICAgIGlmIChpc1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicm91dGVyLmZldGNoKCkgd2FzIGNhbGxlZCBkdXJpbmcgdGhlIHNlcnZlciByZW5kZXIsIGJ1dCBpdCBzaG91bGRuJ3QgYmUuIFwiICsgXCJZb3UgYXJlIGxpa2VseSBjYWxsaW5nIGEgdXNlRmV0Y2hlcigpIG1ldGhvZCBpbiB0aGUgYm9keSBvZiB5b3VyIGNvbXBvbmVudC4gXCIgKyBcIlRyeSBtb3ZpbmcgaXQgdG8gYSB1c2VFZmZlY3Qgb3IgYSBjYWxsYmFjay5cIik7XG4gICAgfVxuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy51bnN0YWJsZV9mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVRvKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3ByZXBlbmRCYXNlbmFtZSwgaHJlZiwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoLCByb3V0ZUlkLCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnJlbGF0aXZlKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBub3JtYWxpemVkUGF0aCwgYmFzZW5hbWUpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWU6IG5vcm1hbGl6ZWRQYXRoXG4gICAgICB9KSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQge1xuICAgICAgcGF0aCxcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBlcnJvclxuICAgIH0gPSBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMoZnV0dXJlLnY3X25vcm1hbGl6ZUZvcm1NZXRob2QsIHRydWUsIG5vcm1hbGl6ZWRQYXRoLCBvcHRzKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7XG4gICAgICAgIGZsdXNoU3luY1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG4gICAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBoYW5kbGVGZXRjaGVyQWN0aW9uKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIG1hdGNoZXMsIGZsdXNoU3luYywgc3VibWlzc2lvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFN0b3JlIG9mZiB0aGUgbWF0Y2ggc28gd2UgY2FuIGNhbGwgaXQncyBzaG91bGRSZXZhbGlkYXRlIG9uIHN1YnNlcXVlbnRcbiAgICAvLyByZXZhbGlkYXRpb25zXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5zZXQoa2V5LCB7XG4gICAgICByb3V0ZUlkLFxuICAgICAgcGF0aFxuICAgIH0pO1xuICAgIGhhbmRsZUZldGNoZXJMb2FkZXIoa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcywgZmx1c2hTeW5jLCBzdWJtaXNzaW9uKTtcbiAgfVxuICAvLyBDYWxsIHRoZSBhY3Rpb24gZm9yIHRoZSBtYXRjaGVkIGZldGNoZXIuc3VibWl0KCksIGFuZCB0aGVuIGhhbmRsZSByZWRpcmVjdHMsXG4gIC8vIGVycm9ycywgYW5kIHJldmFsaWRhdGlvblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyQWN0aW9uKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIHJlcXVlc3RNYXRjaGVzLCBmbHVzaFN5bmMsIHN1Ym1pc3Npb24pIHtcbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgaWYgKCFtYXRjaC5yb3V0ZS5hY3Rpb24gJiYgIW1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogcGF0aCxcbiAgICAgICAgcm91dGVJZDogcm91dGVJZFxuICAgICAgfSk7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBQdXQgdGhpcyBmZXRjaGVyIGludG8gaXQncyBzdWJtaXR0aW5nIHN0YXRlXG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlciksIHtcbiAgICAgIGZsdXNoU3luY1xuICAgIH0pO1xuICAgIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIGZldGNoZXJcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIHBhdGgsIGFib3J0Q29udHJvbGxlci5zaWduYWwsIHN1Ym1pc3Npb24pO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IGFjdGlvblJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcImFjdGlvblwiLCBmZXRjaFJlcXVlc3QsIG1hdGNoLCByZXF1ZXN0TWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgYmFzZW5hbWUsIGZ1dHVyZS52N19yZWxhdGl2ZVNwbGF0UGF0aCk7XG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91ciBvd24gZmV0Y2hlclxuICAgICAgLy8gcmUtc3VibWl0IHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXaGVuIHVzaW5nIHY3X2ZldGNoZXJQZXJzaXN0LCB3ZSBkb24ndCB3YW50IGVycm9ycyBidWJibGluZyB1cCB0byB0aGUgVUlcbiAgICAvLyBvciByZWRpcmVjdHMgcHJvY2Vzc2VkIGZvciB1bm1vdW50ZWQgZmV0Y2hlcnMgc28gd2UganVzdCByZXZlcnQgdGhlbSB0b1xuICAgIC8vIGlkbGVcbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0ICYmIGRlbGV0ZWRGZXRjaGVycy5oYXMoa2V5KSkge1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSB8fCBpc0Vycm9yUmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodW5kZWZpbmVkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIExldCBTdWNjZXNzUmVzdWx0J3MgZmFsbCB0aHJvdWdoIGZvciByZXZhbGlkYXRpb25cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPiBvcmlnaW5hdGluZ0xvYWRJZCkge1xuICAgICAgICAgIC8vIEEgbmV3IG5hdmlnYXRpb24gd2FzIGtpY2tlZCBvZmYgYWZ0ZXIgb3VyIGFjdGlvbiBzdGFydGVkLCBzbyB0aGF0XG4gICAgICAgICAgLy8gc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcmVkaXJlY3QgbmF2aWdhdGlvbi4gIFdlIGFscmVhZHlcbiAgICAgICAgICAvLyBzZXQgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCBzbyBhbGwgbG9hZGVycyBmb3IgdGhlIG5ldyByb3V0ZSBzaG91bGRcbiAgICAgICAgICAvLyBmaXJlIHVubGVzcyBvcHRlZCBvdXQgdmlhIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uKSk7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCBhY3Rpb25SZXN1bHQsIHtcbiAgICAgICAgICAgIGZldGNoZXJTdWJtaXNzaW9uOiBzdWJtaXNzaW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGFjdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgdHlwZTogXCJkZWZlci1hY3Rpb25cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFN0YXJ0IHRoZSBkYXRhIGxvYWQgZm9yIGN1cnJlbnQgbWF0Y2hlcywgb3IgdGhlIG5leHQgbG9jYXRpb24gaWYgd2UncmVcbiAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGEgbmF2aWdhdGlvblxuICAgIGxldCBuZXh0TG9jYXRpb24gPSBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCByZXZhbGlkYXRpb25SZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaW5pdC5oaXN0b3J5LCBuZXh0TG9jYXRpb24sIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBtYXRjaGVzID0gc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSAhPT0gXCJpZGxlXCIgPyBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwgYmFzZW5hbWUpIDogc3RhdGUubWF0Y2hlcztcbiAgICBpbnZhcmlhbnQobWF0Y2hlcywgXCJEaWRuJ3QgZmluZCBhbnkgbWF0Y2hlcyBhZnRlciBmZXRjaGVyIGFjdGlvblwiKTtcbiAgICBsZXQgbG9hZElkID0gKytpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgZmV0Y2hSZWxvYWRJZHMuc2V0KGtleSwgbG9hZElkKTtcbiAgICBsZXQgbG9hZEZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgbG9hZEZldGNoZXIpO1xuICAgIGxldCBbbWF0Y2hlc1RvTG9hZCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdID0gZ2V0TWF0Y2hlc1RvTG9hZChpbml0Lmhpc3RvcnksIHN0YXRlLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBuZXh0TG9jYXRpb24sIGZhbHNlLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcywgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBkZWxldGVkRmV0Y2hlcnMsIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwge1xuICAgICAgW21hdGNoLnJvdXRlLmlkXTogYWN0aW9uUmVzdWx0LmRhdGFcbiAgICB9LCB1bmRlZmluZWQgLy8gTm8gbmVlZCB0byBzZW5kIHRocm91Z2ggZXJyb3JzIHNpbmNlIHdlIHNob3J0IGNpcmN1aXQgYWJvdmVcbiAgICApO1xuICAgIC8vIFB1dCBhbGwgcmV2YWxpZGF0aW5nIGZldGNoZXJzIGludG8gdGhlIGxvYWRpbmcgc3RhdGUsIGV4Y2VwdCBmb3IgdGhlXG4gICAgLy8gY3VycmVudCBmZXRjaGVyIHdoaWNoIHdlIHdhbnQgdG8ga2VlcCBpbiBpdCdzIGN1cnJlbnQgbG9hZGluZyBzdGF0ZSB3aGljaFxuICAgIC8vIGNvbnRhaW5zIGl0J3MgYWN0aW9uIHN1Ym1pc3Npb24gaW5mbyArIGFjdGlvbiBkYXRhXG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZmlsdGVyKHJmID0+IHJmLmtleSAhPT0ga2V5KS5mb3JFYWNoKHJmID0+IHtcbiAgICAgIGxldCBzdGFsZUtleSA9IHJmLmtleTtcbiAgICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoc3RhbGVLZXkpO1xuICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcih1bmRlZmluZWQsIGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChzdGFsZUtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoc3RhbGVLZXkpKSB7XG4gICAgICAgIGFib3J0RmV0Y2hlcihzdGFsZUtleSk7XG4gICAgICB9XG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChzdGFsZUtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+IHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2gocmYgPT4gYWJvcnRGZXRjaGVyKHJmLmtleSkpO1xuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XG4gICAgbGV0IHtcbiAgICAgIHJlc3VsdHMsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICB9ID0gYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKHN0YXRlLm1hdGNoZXMsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCByZXZhbGlkYXRpb25SZXF1ZXN0KTtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHIgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUoci5rZXkpKTtcbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG4gICAgaWYgKHJlZGlyZWN0KSB7XG4gICAgICBpZiAocmVkaXJlY3QuaWR4ID49IG1hdGNoZXNUb0xvYWQubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcmVkaXJlY3QgY2FtZSBmcm9tIGEgZmV0Y2hlciBtYWtlIHN1cmUgd2UgbWFyayBpdCBpblxuICAgICAgICAvLyBmZXRjaFJlZGlyZWN0SWRzIHNvIGl0IGRvZXNuJ3QgZ2V0IHJldmFsaWRhdGVkIG9uIHRoZSBuZXh0IHNldCBvZlxuICAgICAgICAvLyBsb2FkZXIgZXhlY3V0aW9uc1xuICAgICAgICBsZXQgZmV0Y2hlcktleSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW3JlZGlyZWN0LmlkeCAtIG1hdGNoZXNUb0xvYWQubGVuZ3RoXS5rZXk7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGZldGNoZXJLZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZWRpcmVjdC5yZXN1bHQpO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCB7XG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSA9IHByb2Nlc3NMb2FkZXJEYXRhKHN0YXRlLCBzdGF0ZS5tYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCBsb2FkZXJSZXN1bHRzLCB1bmRlZmluZWQsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCBmZXRjaGVyUmVzdWx0cywgYWN0aXZlRGVmZXJyZWRzKTtcbiAgICAvLyBTaW5jZSB3ZSBsZXQgcmV2YWxpZGF0aW9ucyBjb21wbGV0ZSBldmVuIGlmIHRoZSBzdWJtaXR0aW5nIGZldGNoZXIgd2FzXG4gICAgLy8gZGVsZXRlZCwgb25seSBwdXQgaXQgYmFjayB0byBpZGxlIGlmIGl0IGhhc24ndCBiZWVuIGRlbGV0ZWRcbiAgICBpZiAoc3RhdGUuZmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gICAgYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluIGEgbmF2aWdhdGlvbiBsb2FkaW5nIHN0YXRlIGFuZCB0aGlzIGZldGNoZXIgaXNcbiAgICAvLyBtb3JlIHJlY2VudCB0aGFuIHRoZSBuYXZpZ2F0aW9uLCB3ZSB3YW50IHRoZSBuZXdlciBkYXRhIHNvIGFib3J0IHRoZVxuICAgIC8vIG5hdmlnYXRpb24gYW5kIGNvbXBsZXRlIGl0IHdpdGggdGhlIGZldGNoZXIgZGF0YVxuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBsb2FkSWQgPiBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCkge1xuICAgICAgaW52YXJpYW50KHBlbmRpbmdBY3Rpb24sIFwiRXhwZWN0ZWQgcGVuZGluZyBhY3Rpb25cIik7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHVwZGF0ZSB3aXRoIHRoZSBmZXRjaGVyIGRhdGEsIHByZXNlcnZpbmcgYW55IGV4aXN0aW5nXG4gICAgICAvLyBsb2FkZXJEYXRhIGZvciBsb2FkZXJzIHRoYXQgZGlkIG5vdCBuZWVkIHRvIHJlbG9hZC4gIFdlIGhhdmUgdG9cbiAgICAgIC8vIG1hbnVhbGx5IG1lcmdlIGhlcmUgc2luY2Ugd2UgYXJlbid0IGdvaW5nIHRocm91Z2ggY29tcGxldGVOYXZpZ2F0aW9uXG4gICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgbG9hZGVyRGF0YTogbWVyZ2VMb2FkZXJEYXRhKHN0YXRlLmxvYWRlckRhdGEsIGxvYWRlckRhdGEsIG1hdGNoZXMsIGVycm9ycyksXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIENhbGwgdGhlIG1hdGNoZWQgbG9hZGVyIGZvciBmZXRjaGVyLmxvYWQoKSwgaGFuZGxpbmcgcmVkaXJlY3RzLCBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmV0Y2hlckxvYWRlcihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBmbHVzaFN5bmMsIHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0TG9hZGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgZXhpc3RpbmdGZXRjaGVyID8gZXhpc3RpbmdGZXRjaGVyLmRhdGEgOiB1bmRlZmluZWQpLCB7XG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgICAvLyBDYWxsIHRoZSBsb2FkZXIgZm9yIHRoaXMgZmV0Y2hlciByb3V0ZSBtYXRjaFxuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgcGF0aCwgYWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuICAgIGxldCBvcmlnaW5hdGluZ0xvYWRJZCA9IGluY3JlbWVudGluZ0xvYWRJZDtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFwibG9hZGVyXCIsIGZldGNoUmVxdWVzdCwgbWF0Y2gsIG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGJhc2VuYW1lLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpO1xuICAgIC8vIERlZmVycmVkIGlzbid0IHN1cHBvcnRlZCBmb3IgZmV0Y2hlciBsb2FkcywgYXdhaXQgZXZlcnl0aGluZyBhbmQgdHJlYXQgaXRcbiAgICAvLyBhcyBhIG5vcm1hbCBsb2FkLiAgcmVzb2x2ZURlZmVycmVkRGF0YSB3aWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhpc1xuICAgIC8vIGZldGNoZXIgZ2V0cyBhYm9ydGVkLCBzbyB3ZSBqdXN0IGxlYXZlIHJlc3VsdCB1bnRvdWNoZWQgYW5kIHNob3J0IGNpcmN1aXRcbiAgICAvLyBiZWxvdyBpZiB0aGF0IGhhcHBlbnNcbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSAoYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIGZldGNoUmVxdWVzdC5zaWduYWwsIHRydWUpKSB8fCByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFdlIGNhbiBkZWxldGUgdGhpcyBzbyBsb25nIGFzIHdlIHdlcmVuJ3QgYWJvcnRlZCBieSBvdXIgb3VyIG93biBmZXRjaGVyXG4gICAgLy8gcmUtbG9hZCB3aGljaCB3b3VsZCBoYXZlIHB1dCBfbmV3XyBjb250cm9sbGVyIGlzIGluIGZldGNoQ29udHJvbGxlcnNcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5nZXQoa2V5KSA9PT0gYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXJyb3JzIGJ1YmJsaW5nIHVwIG9yIHJlZGlyZWN0cyBmb2xsb3dlZCBmb3IgdW5tb3VudGVkXG4gICAgLy8gZmV0Y2hlcnMsIHNvIHNob3J0IGNpcmN1aXQgaGVyZSBpZiBpdCB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBVSVxuICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHVuZGVmaW5lZCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbG9hZGVyIHRocmV3IGEgcmVkaXJlY3QgUmVzcG9uc2UsIHN0YXJ0IGEgbmV3IFJFUExBQ0UgbmF2aWdhdGlvblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XG4gICAgICAgIC8vIEEgbmV3IG5hdmlnYXRpb24gd2FzIGtpY2tlZCBvZmYgYWZ0ZXIgb3VyIGxvYWRlciBzdGFydGVkLCBzbyB0aGF0XG4gICAgICAgIC8vIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHJlZGlyZWN0IG5hdmlnYXRpb25cbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodW5kZWZpbmVkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGtleSk7XG4gICAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZXN1bHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgYW55IG5vbi1yZWRpcmVjdCBlcnJvcnMgdGhyb3duXG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgcmVzdWx0LmVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KCFpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCksIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcbiAgICAvLyBQdXQgdGhlIGZldGNoZXIgYmFjayBpbnRvIGFuIGlkbGUgc3RhdGVcbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSkpO1xuICB9XG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGhhbmRsZSByZWRpcmVjdHMgcmV0dXJuZWQgZnJvbSBhbiBhY3Rpb24gb3IgbG9hZGVyLlxuICAgKiBOb3JtYWxseSwgYSByZWRpcmVjdCBcInJlcGxhY2VzXCIgdGhlIG5hdmlnYXRpb24gdGhhdCB0cmlnZ2VyZWQgaXQuICBTbywgZm9yXG4gICAqIGV4YW1wbGU6XG4gICAqXG4gICAqICAtIHVzZXIgaXMgb24gL2FcbiAgICogIC0gdXNlciBjbGlja3MgYSBsaW5rIHRvIC9iXG4gICAqICAtIGxvYWRlciBmb3IgL2IgcmVkaXJlY3RzIHRvIC9jXG4gICAqXG4gICAqIEluIGEgbm9uLUpTIGFwcCB0aGUgYnJvd3NlciB3b3VsZCB0cmFjayB0aGUgaW4tZmxpZ2h0IG5hdmlnYXRpb24gdG8gL2IgYW5kXG4gICAqIHRoZW4gcmVwbGFjZSBpdCB3aXRoIC9jIHdoZW4gaXQgZW5jb3VudGVyZWQgdGhlIHJlZGlyZWN0IHJlc3BvbnNlLiAgSW5cbiAgICogdGhlIGVuZCBpdCB3b3VsZCBvbmx5IGV2ZXIgdXBkYXRlIHRoZSBVUkwgYmFyIHdpdGggL2MuXG4gICAqXG4gICAqIEluIGNsaWVudC1zaWRlIHJvdXRpbmcgdXNpbmcgcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSwgd2UgYWltIHRvIGVtdWxhdGVcbiAgICogdGhpcyBiZWhhdmlvciBhbmQgd2UgYWxzbyBkbyBub3QgdXBkYXRlIGhpc3RvcnkgdW50aWwgdGhlIGVuZCBvZiB0aGVcbiAgICogbmF2aWdhdGlvbiAoaW5jbHVkaW5nIHByb2Nlc3NlZCByZWRpcmVjdHMpLiAgVGhpcyBtZWFucyB0aGF0IHdlIG5ldmVyXG4gICAqIGFjdHVhbGx5IHRvdWNoIGhpc3RvcnkgdW50aWwgd2UndmUgcHJvY2Vzc2VkIHJlZGlyZWN0cywgc28gd2UganVzdCB1c2VcbiAgICogdGhlIGhpc3RvcnkgYWN0aW9uIGZyb20gdGhlIG9yaWdpbmFsIG5hdmlnYXRpb24gKFBVU0ggb3IgUkVQTEFDRSkuXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVkaXJlY3QsIF90ZW1wMikge1xuICAgIGxldCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICByZXBsYWNlXG4gICAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gICAgaWYgKHJlZGlyZWN0LnJldmFsaWRhdGUpIHtcbiAgICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgcmVkaXJlY3RMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCByZWRpcmVjdC5sb2NhdGlvbiwge1xuICAgICAgX2lzUmVkaXJlY3Q6IHRydWVcbiAgICB9KTtcbiAgICBpbnZhcmlhbnQocmVkaXJlY3RMb2NhdGlvbiwgXCJFeHBlY3RlZCBhIGxvY2F0aW9uIG9uIHRoZSByZWRpcmVjdCBuYXZpZ2F0aW9uXCIpO1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIGxldCBpc0RvY3VtZW50UmVsb2FkID0gZmFsc2U7XG4gICAgICBpZiAocmVkaXJlY3QucmVsb2FkRG9jdW1lbnQpIHtcbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgdGhlIHJlc3BvbnNlIGNvbnRhaW5lZCBYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFxuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QocmVkaXJlY3QubG9jYXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGluaXQuaGlzdG9yeS5jcmVhdGVVUkwocmVkaXJlY3QubG9jYXRpb24pO1xuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID1cbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdG8gYSBuZXcgb3JpZ2luXG4gICAgICAgIHVybC5vcmlnaW4gIT09IHJvdXRlcldpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHxcbiAgICAgICAgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdGhhdCBkb2VzIG5vdCBtYXRjaCBvdXIgYmFzZW5hbWVcbiAgICAgICAgc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSA9PSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGlzRG9jdW1lbnRSZWxvYWQpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24ucmVwbGFjZShyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLmFzc2lnbihyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gYWJvcnQgb24gcmVkaXJlY3RzLCBzaW5jZSB3ZSBkb24ndCBkZXRlY3QgdGhlXG4gICAgLy8gcmVkaXJlY3QgdW50aWwgdGhlIGFjdGlvbi9sb2FkZXJzIGhhdmUgc2V0dGxlZFxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgbGV0IHJlZGlyZWN0SGlzdG9yeUFjdGlvbiA9IHJlcGxhY2UgPT09IHRydWUgPyBBY3Rpb24uUmVwbGFjZSA6IEFjdGlvbi5QdXNoO1xuICAgIC8vIFVzZSB0aGUgaW5jb21pbmcgc3VibWlzc2lvbiBpZiBwcm92aWRlZCwgZmFsbGJhY2sgb24gdGhlIGFjdGl2ZSBvbmUgaW5cbiAgICAvLyBzdGF0ZS5uYXZpZ2F0aW9uXG4gICAgbGV0IHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGVcbiAgICB9ID0gc3RhdGUubmF2aWdhdGlvbjtcbiAgICBpZiAoIXN1Ym1pc3Npb24gJiYgIWZldGNoZXJTdWJtaXNzaW9uICYmIGZvcm1NZXRob2QgJiYgZm9ybUFjdGlvbiAmJiBmb3JtRW5jVHlwZSkge1xuICAgICAgc3VibWlzc2lvbiA9IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihzdGF0ZS5uYXZpZ2F0aW9uKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyB3YXMgYSAzMDcvMzA4IHN1Ym1pc3Npb24gd2Ugd2FudCB0byBwcmVzZXJ2ZSB0aGUgSFRUUCBtZXRob2QgYW5kXG4gICAgLy8gcmUtc3VibWl0IHRoZSBHRVQvUE9TVC9QVVQvUEFUQ0gvREVMRVRFIGFzIGEgc3VibWlzc2lvbiBuYXZpZ2F0aW9uIHRvIHRoZVxuICAgIC8vIHJlZGlyZWN0ZWQgbG9jYXRpb25cbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb247XG4gICAgaWYgKHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2Rlcy5oYXMocmVkaXJlY3Quc3RhdHVzKSAmJiBhY3RpdmVTdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2QoYWN0aXZlU3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKHJlZGlyZWN0SGlzdG9yeUFjdGlvbiwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBzdWJtaXNzaW9uOiBfZXh0ZW5kcyh7fSwgYWN0aXZlU3VibWlzc2lvbiwge1xuICAgICAgICAgIGZvcm1BY3Rpb246IHJlZGlyZWN0LmxvY2F0aW9uXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGlzIGZsYWcgYWNyb3NzIHJlZGlyZWN0c1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgbmF2aWdhdGlvbiBzdWJtaXNzaW9uLCB3ZSB3aWxsIHByZXNlcnZlIGl0IHRocm91Z2ggdGhlXG4gICAgICAvLyByZWRpcmVjdCBuYXZpZ2F0aW9uXG4gICAgICBsZXQgb3ZlcnJpZGVOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24ocmVkaXJlY3RMb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbixcbiAgICAgICAgLy8gU2VuZCBmZXRjaGVyIHN1Ym1pc3Npb25zIHRocm91Z2ggZm9yIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShjdXJyZW50TWF0Y2hlcywgbWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgZmV0Y2hlcnNUb0xvYWQsIHJlcXVlc3QpIHtcbiAgICAvLyBDYWxsIGFsbCBuYXZpZ2F0aW9uIGxvYWRlcnMgYW5kIHJldmFsaWRhdGluZyBmZXRjaGVyIGxvYWRlcnMgaW4gcGFyYWxsZWwsXG4gICAgLy8gdGhlbiBzbGljZSBvZmYgdGhlIHJlc3VsdHMgaW50byBzZXBhcmF0ZSBhcnJheXMgc28gd2UgY2FuIGhhbmRsZSB0aGVtXG4gICAgLy8gYWNjb3JkaW5nbHlcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFsuLi5tYXRjaGVzVG9Mb2FkLm1hcChtYXRjaCA9PiBjYWxsTG9hZGVyT3JBY3Rpb24oXCJsb2FkZXJcIiwgcmVxdWVzdCwgbWF0Y2gsIG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGJhc2VuYW1lLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpKSwgLi4uZmV0Y2hlcnNUb0xvYWQubWFwKGYgPT4ge1xuICAgICAgaWYgKGYubWF0Y2hlcyAmJiBmLm1hdGNoICYmIGYuY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gY2FsbExvYWRlck9yQWN0aW9uKFwibG9hZGVyXCIsIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgZi5wYXRoLCBmLmNvbnRyb2xsZXIuc2lnbmFsKSwgZi5tYXRjaCwgZi5tYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBlcnJvciA9IHtcbiAgICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGYucGF0aFxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9KV0pO1xuICAgIGxldCBsb2FkZXJSZXN1bHRzID0gcmVzdWx0cy5zbGljZSgwLCBtYXRjaGVzVG9Mb2FkLmxlbmd0aCk7XG4gICAgbGV0IGZldGNoZXJSZXN1bHRzID0gcmVzdWx0cy5zbGljZShtYXRjaGVzVG9Mb2FkLmxlbmd0aCk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW3Jlc29sdmVEZWZlcnJlZFJlc3VsdHMoY3VycmVudE1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIGxvYWRlclJlc3VsdHMsIGxvYWRlclJlc3VsdHMubWFwKCgpID0+IHJlcXVlc3Quc2lnbmFsKSwgZmFsc2UsIHN0YXRlLmxvYWRlckRhdGEpLCByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKGN1cnJlbnRNYXRjaGVzLCBmZXRjaGVyc1RvTG9hZC5tYXAoZiA9PiBmLm1hdGNoKSwgZmV0Y2hlclJlc3VsdHMsIGZldGNoZXJzVG9Mb2FkLm1hcChmID0+IGYuY29udHJvbGxlciA/IGYuY29udHJvbGxlci5zaWduYWwgOiBudWxsKSwgdHJ1ZSldKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0cyxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJydXB0QWN0aXZlTG9hZHMoKSB7XG4gICAgLy8gRXZlcnkgaW50ZXJydXB0aW9uIHRyaWdnZXJzIGEgcmV2YWxpZGF0aW9uXG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgcm91dGUtbGV2ZWwgZGVmZXJyZWRzIGFuZCBtYXJrIGNhbmNlbGxlZCByb3V0ZXMgZm9yXG4gICAgLy8gcmV2YWxpZGF0aW9uXG4gICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMucHVzaCguLi5jYW5jZWxBY3RpdmVEZWZlcnJlZHMoKSk7XG4gICAgLy8gQWJvcnQgaW4tZmxpZ2h0IGZldGNoZXIgbG9hZHNcbiAgICBmZXRjaExvYWRNYXRjaGVzLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLnB1c2goa2V5KTtcbiAgICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZmV0Y2hlciwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSwge1xuICAgICAgZmx1c2hTeW5jOiAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIHJvdXRlSWQpO1xuICAgIGRlbGV0ZUZldGNoZXIoa2V5KTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICBlcnJvcnM6IHtcbiAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiBlcnJvclxuICAgICAgfSxcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0sIHtcbiAgICAgIGZsdXNoU3luYzogKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RmV0Y2hlcihrZXkpIHtcbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0KSB7XG4gICAgICBhY3RpdmVGZXRjaGVycy5zZXQoa2V5LCAoYWN0aXZlRmV0Y2hlcnMuZ2V0KGtleSkgfHwgMCkgKyAxKTtcbiAgICAgIC8vIElmIHRoaXMgZmV0Y2hlciB3YXMgcHJldmlvdXNseSBtYXJrZWQgZm9yIGRlbGV0aW9uLCB1bm1hcmsgaXQgc2luY2Ugd2VcbiAgICAgIC8vIGhhdmUgYSBuZXcgaW5zdGFuY2VcbiAgICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5KSB7XG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAvLyBEb24ndCBhYm9ydCB0aGUgY29udHJvbGxlciBpZiB0aGlzIGlzIGEgZGVsZXRpb24gb2YgYSBmZXRjaGVyLnN1Ym1pdCgpXG4gICAgLy8gaW4gaXQncyBsb2FkaW5nIHBoYXNlIHNpbmNlIC0gd2UgZG9uJ3Qgd2FudCB0byBhYm9ydCB0aGUgY29ycmVzcG9uZGluZ1xuICAgIC8vIHJldmFsaWRhdGlvbiBhbmQgd2FudCB0aGVtIHRvIGNvbXBsZXRlIGFuZCBsYW5kXG4gICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKGtleSkgJiYgIShmZXRjaGVyICYmIGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGZldGNoUmVsb2FkSWRzLmhhcyhrZXkpKSkge1xuICAgICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgfVxuICAgIGZldGNoTG9hZE1hdGNoZXMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICBkZWxldGVkRmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlckFuZFVwZGF0ZVN0YXRlKGtleSkge1xuICAgIGlmIChmdXR1cmUudjdfZmV0Y2hlclBlcnNpc3QpIHtcbiAgICAgIGxldCBjb3VudCA9IChhY3RpdmVGZXRjaGVycy5nZXQoa2V5KSB8fCAwKSAtIDE7XG4gICAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgICBhY3RpdmVGZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgZGVsZXRlZEZldGNoZXJzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlRmV0Y2hlcnMuc2V0KGtleSwgY291bnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVGZXRjaGVyKGtleSk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSk7XG4gICAgaW52YXJpYW50KGNvbnRyb2xsZXIsIFwiRXhwZWN0ZWQgZmV0Y2ggY29udHJvbGxlcjogXCIgKyBrZXkpO1xuICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaGVyc0RvbmUoa2V5cykge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGZldGNoZXIuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcmtGZXRjaFJlZGlyZWN0c0RvbmUoKSB7XG4gICAgbGV0IGRvbmVLZXlzID0gW107XG4gICAgbGV0IHVwZGF0ZWRGZXRjaGVycyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBmZXRjaFJlZGlyZWN0SWRzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgaW52YXJpYW50KGZldGNoZXIsIFwiRXhwZWN0ZWQgZmV0Y2hlcjogXCIgKyBrZXkpO1xuICAgICAgaWYgKGZldGNoZXIuc3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgICAgIGRvbmVLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgdXBkYXRlZEZldGNoZXJzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0ZldGNoZXJzRG9uZShkb25lS2V5cyk7XG4gICAgcmV0dXJuIHVwZGF0ZWRGZXRjaGVycztcbiAgfVxuICBmdW5jdGlvbiBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhsYW5kZWRJZCkge1xuICAgIGxldCB5ZWV0ZWRLZXlzID0gW107XG4gICAgZm9yIChsZXQgW2tleSwgaWRdIG9mIGZldGNoUmVsb2FkSWRzKSB7XG4gICAgICBpZiAoaWQgPCBsYW5kZWRJZCkge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgXCJFeHBlY3RlZCBmZXRjaGVyOiBcIiArIGtleSk7XG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoeWVldGVkS2V5cyk7XG4gICAgcmV0dXJuIHllZXRlZEtleXMubGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBnZXRCbG9ja2VyKGtleSwgZm4pIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5nZXQoa2V5KSAhPT0gZm4pIHtcbiAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2V0KGtleSwgZm4pO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tlcjtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVCbG9ja2VyKGtleSkge1xuICAgIHN0YXRlLmJsb2NrZXJzLmRlbGV0ZShrZXkpO1xuICAgIGJsb2NrZXJGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbiB0byB1cGRhdGUgYmxvY2tlcnMsIGVuc3VyaW5nIHZhbGlkIHN0YXRlIHRyYW5zaXRpb25zXG4gIGZ1bmN0aW9uIHVwZGF0ZUJsb2NrZXIoa2V5LCBuZXdCbG9ja2VyKSB7XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoa2V5KSB8fCBJRExFX0JMT0NLRVI7XG4gICAgLy8gUG9vciBtYW5zIHN0YXRlIG1hY2hpbmUgOilcbiAgICAvLyBodHRwczovL21lcm1haWQubGl2ZS9lZGl0I3Bha286ZU5xVmtjOU93ekFNeGw4bDhubmpBWXJFdERJT0hFQklnd3ZLSlRSZUd5M19sRHBJcU8yN2s2YXdNRzBYY3JMbG56ODdud2RvbkVTb2dLWFhCdUU3OXJxNzVYWk8zLXlIZHMwUkpWdXY3MFlyUGxVckNFZTJIZnJPUlMzcnVicVpmdWh0cGc1Qzl3azV0WjRWS2NSVXE4OHE5WjhSUzAtNDhjRTFpSEprTDB1Z2JIdUZMdXM5TDZzcFp5OG5YOU1QMkNOZG9tVmFwb3NxdTNmR2F5VDhUOC1qSlF3aGVwb19VdHBnQlFhREVVb20wNGRaaEFOMWFKQkRsVUtKQnhFMWNlQjJTbWowTWxuLUlCVzVBRlUyZHdVaWt0dF8yUWFxMmRCZmFLZEV1cDg1VVY3WWQtZEtqbG5rYWJsMlB2cjBEVGtUcmVNXG4gICAgaW52YXJpYW50KGJsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiB8fCBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIiAmJiBuZXdCbG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiLCBcIkludmFsaWQgYmxvY2tlciBzdGF0ZSB0cmFuc2l0aW9uOiBcIiArIGJsb2NrZXIuc3RhdGUgKyBcIiAtPiBcIiArIG5ld0Jsb2NrZXIuc3RhdGUpO1xuICAgIGxldCBibG9ja2VycyA9IG5ldyBNYXAoc3RhdGUuYmxvY2tlcnMpO1xuICAgIGJsb2NrZXJzLnNldChrZXksIG5ld0Jsb2NrZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGJsb2NrZXJzXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKF9yZWYyKSB7XG4gICAgbGV0IHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9ID0gX3JlZjI7XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXZSBvbnkgc3VwcG9ydCBhIHNpbmdsZSBhY3RpdmUgYmxvY2tlciBhdCB0aGUgbW9tZW50IHNpbmNlIHdlIGRvbid0IGhhdmVcbiAgICAvLyBhbnkgY29tcGVsbGluZyB1c2UgY2FzZXMgZm9yIG11bHRpLWJsb2NrZXIgeWV0XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA+IDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiQSByb3V0ZXIgb25seSBzdXBwb3J0cyBvbmUgYmxvY2tlciBhdCBhIHRpbWVcIik7XG4gICAgfVxuICAgIGxldCBlbnRyaWVzID0gQXJyYXkuZnJvbShibG9ja2VyRnVuY3Rpb25zLmVudHJpZXMoKSk7XG4gICAgbGV0IFtibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb25dID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdO1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGJsb2NrZXJLZXkpO1xuICAgIGlmIChibG9ja2VyICYmIGJsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiKSB7XG4gICAgICAvLyBJZiB0aGUgYmxvY2tlciBpcyBjdXJyZW50bHkgcHJvY2VlZGluZywgd2UgZG9uJ3QgbmVlZCB0byByZS1jaGVja1xuICAgICAgLy8gaXQgYW5kIGNhbiBsZXQgdGhpcyBuYXZpZ2F0aW9uIGNvbnRpbnVlXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgd2UncmUgdW5ibG9ja2VkL2Jsb2NrZWQgc28gd2UgbmVlZCB0byBjaGVjayB0aGVcbiAgICAvLyB1c2VyLXByb3ZpZGVkIGJsb2NrZXIgZnVuY3Rpb25cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9uKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9KSkge1xuICAgICAgcmV0dXJuIGJsb2NrZXJLZXk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhwcmVkaWNhdGUpIHtcbiAgICBsZXQgY2FuY2VsbGVkUm91dGVJZHMgPSBbXTtcbiAgICBhY3RpdmVEZWZlcnJlZHMuZm9yRWFjaCgoZGZkLCByb3V0ZUlkKSA9PiB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUocm91dGVJZCkpIHtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBkZWZlcnJlZCAtIGJ1dCBkbyBub3QgcmVtb3ZlIGZyb20gYWN0aXZlRGVmZXJyZWRzIGhlcmUgLVxuICAgICAgICAvLyB3ZSByZWx5IG9uIHRoZSBzdWJzY3JpYmVycyB0byBkbyB0aGF0IHNvIG91ciB0ZXN0cyBjYW4gYXNzZXJ0IHByb3BlclxuICAgICAgICAvLyBjbGVhbnVwIHZpYSBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHNcbiAgICAgICAgZGZkLmNhbmNlbCgpO1xuICAgICAgICBjYW5jZWxsZWRSb3V0ZUlkcy5wdXNoKHJvdXRlSWQpO1xuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuZGVsZXRlKHJvdXRlSWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjYW5jZWxsZWRSb3V0ZUlkcztcbiAgfVxuICAvLyBPcHQgaW4gdG8gY2FwdHVyaW5nIGFuZCByZXBvcnRpbmcgc2Nyb2xsIHBvc2l0aW9ucyBkdXJpbmcgbmF2aWdhdGlvbnMsXG4gIC8vIHVzZWQgYnkgdGhlIDxTY3JvbGxSZXN0b3JhdGlvbj4gY29tcG9uZW50XG4gIGZ1bmN0aW9uIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKHBvc2l0aW9ucywgZ2V0UG9zaXRpb24sIGdldEtleSkge1xuICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgIGdldFNjcm9sbFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4gICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBnZXRLZXkgfHwgbnVsbDtcbiAgICAvLyBQZXJmb3JtIGluaXRpYWwgaHlkcmF0aW9uIHNjcm9sbCByZXN0b3JhdGlvbiwgc2luY2Ugd2UgbWlzcyB0aGUgYm9hdCBvblxuICAgIC8vIHRoZSBpbml0aWFsIHVwZGF0ZVN0YXRlKCkgYmVjYXVzZSB3ZSd2ZSBub3QgeWV0IHJlbmRlcmVkIDxTY3JvbGxSZXN0b3JhdGlvbi8+XG4gICAgLy8gYW5kIHRoZXJlZm9yZSBoYXZlIG5vIHNhdmVkU2Nyb2xsUG9zaXRpb25zIGF2YWlsYWJsZVxuICAgIGlmICghaW5pdGlhbFNjcm9sbFJlc3RvcmVkICYmIHN0YXRlLm5hdmlnYXRpb24gPT09IElETEVfTkFWSUdBVElPTikge1xuICAgICAgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gdHJ1ZTtcbiAgICAgIGxldCB5ID0gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb246IHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gICAgICBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IG51bGw7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTY3JvbGxLZXkobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgbWF0Y2hlcy5tYXAobSA9PiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtLCBzdGF0ZS5sb2FkZXJEYXRhKSkpO1xuICAgICAgcmV0dXJuIGtleSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhdGlvbi5rZXk7XG4gIH1cbiAgZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zICYmIGdldFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIGxldCB5ID0gc2F2ZWRTY3JvbGxQb3NpdGlvbnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4geTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gX2ludGVybmFsU2V0Um91dGVzKG5ld1JvdXRlcykge1xuICAgIG1hbmlmZXN0ID0ge307XG4gICAgaW5GbGlnaHREYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhuZXdSb3V0ZXMsIG1hcFJvdXRlUHJvcGVydGllcywgdW5kZWZpbmVkLCBtYW5pZmVzdCk7XG4gIH1cbiAgcm91dGVyID0ge1xuICAgIGdldCBiYXNlbmFtZSgpIHtcbiAgICAgIHJldHVybiBiYXNlbmFtZTtcbiAgICB9LFxuICAgIGdldCBmdXR1cmUoKSB7XG4gICAgICByZXR1cm4gZnV0dXJlO1xuICAgIH0sXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgZ2V0IHdpbmRvdygpIHtcbiAgICAgIHJldHVybiByb3V0ZXJXaW5kb3c7XG4gICAgfSxcbiAgICBpbml0aWFsaXplLFxuICAgIHN1YnNjcmliZSxcbiAgICBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbixcbiAgICBuYXZpZ2F0ZSxcbiAgICBmZXRjaCxcbiAgICByZXZhbGlkYXRlLFxuICAgIC8vIFBhc3N0aHJvdWdoIHRvIGhpc3RvcnktYXdhcmUgY3JlYXRlSHJlZiB1c2VkIGJ5IHVzZUhyZWYgc28gd2UgZ2V0IHByb3BlclxuICAgIC8vIGhhc2gtYXdhcmUgVVJMcyBpbiBET00gcGF0aHNcbiAgICBjcmVhdGVIcmVmOiB0byA9PiBpbml0Lmhpc3RvcnkuY3JlYXRlSHJlZih0byksXG4gICAgZW5jb2RlTG9jYXRpb246IHRvID0+IGluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbih0byksXG4gICAgZ2V0RmV0Y2hlcixcbiAgICBkZWxldGVGZXRjaGVyOiBkZWxldGVGZXRjaGVyQW5kVXBkYXRlU3RhdGUsXG4gICAgZGlzcG9zZSxcbiAgICBnZXRCbG9ja2VyLFxuICAgIGRlbGV0ZUJsb2NrZXIsXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogZmV0Y2hDb250cm9sbGVycyxcbiAgICBfaW50ZXJuYWxBY3RpdmVEZWZlcnJlZHM6IGFjdGl2ZURlZmVycmVkcyxcbiAgICAvLyBUT0RPOiBSZW1vdmUgc2V0Um91dGVzLCBpdCdzIHRlbXBvcmFyeSB0byBhdm9pZCBkZWFsaW5nIHdpdGhcbiAgICAvLyB1cGRhdGluZyB0aGUgdHJlZSB3aGlsZSB2YWxpZGF0aW5nIHRoZSB1cGRhdGUgYWxnb3JpdGhtLlxuICAgIF9pbnRlcm5hbFNldFJvdXRlc1xuICB9O1xuICByZXR1cm4gcm91dGVyO1xufVxuLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBVTlNBRkVfREVGRVJSRURfU1lNQk9MID0gU3ltYm9sKFwiZGVmZXJyZWRcIik7XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyKHJvdXRlcywgb3B0cykge1xuICBpbnZhcmlhbnQocm91dGVzLmxlbmd0aCA+IDAsIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlU3RhdGljSGFuZGxlclwiKTtcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIGxldCBiYXNlbmFtZSA9IChvcHRzID8gb3B0cy5iYXNlbmFtZSA6IG51bGwpIHx8IFwiL1wiO1xuICBsZXQgbWFwUm91dGVQcm9wZXJ0aWVzO1xuICBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMubWFwUm91dGVQcm9wZXJ0aWVzKSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gb3B0cy5tYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH0gZWxzZSBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMuZGV0ZWN0RXJyb3JCb3VuZGFyeSkge1xuICAgIC8vIElmIHRoZXkgYXJlIHN0aWxsIHVzaW5nIHRoZSBkZXByZWNhdGVkIHZlcnNpb24sIHdyYXAgaXQgd2l0aCB0aGUgbmV3IEFQSVxuICAgIGxldCBkZXRlY3RFcnJvckJvdW5kYXJ5ID0gb3B0cy5kZXRlY3RFcnJvckJvdW5kYXJ5O1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IHJvdXRlID0+ICh7XG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBkZXRlY3RFcnJvckJvdW5kYXJ5KHJvdXRlKVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1hcFJvdXRlUHJvcGVydGllcyA9IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH1cbiAgLy8gQ29uZmlnIGRyaXZlbiBiZWhhdmlvciBmbGFnc1xuICBsZXQgZnV0dXJlID0gX2V4dGVuZHMoe1xuICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBmYWxzZVxuICB9LCBvcHRzID8gb3B0cy5mdXR1cmUgOiBudWxsKTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCB1bmRlZmluZWQsIG1hbmlmZXN0KTtcbiAgLyoqXG4gICAqIFRoZSBxdWVyeSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZG9jdW1lbnQgcmVxdWVzdHMsIGluIHdoaWNoIHdlIHdhbnQgdG9cbiAgICogY2FsbCBhbiBvcHRpb25hbCBhY3Rpb24gYW5kIHBvdGVudGlhbGx5IG11bHRpcGxlIGxvYWRlcnMgZm9yIGFsbCBuZXN0ZWRcbiAgICogcm91dGVzLiAgSXQgcmV0dXJucyBhIFN0YXRpY0hhbmRsZXJDb250ZXh0IG9iamVjdCwgd2hpY2ggaXMgdmVyeSBzaW1pbGFyXG4gICAqIHRvIHRoZSByb3V0ZXIgc3RhdGUgKGxvY2F0aW9uLCBsb2FkZXJEYXRhLCBhY3Rpb25EYXRhLCBlcnJvcnMsIGV0Yy4pIGFuZFxuICAgKiBhbHNvIGFkZHMgU1NSLXNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHN0YXR1c0NvZGUgYW5kIGhlYWRlcnNcbiAgICogZnJvbSBhY3Rpb24vbG9hZGVycyBSZXNwb25zZXMuXG4gICAqXG4gICAqIEl0IF9zaG91bGRfIG5ldmVyIHRocm93IGFuZCBzaG91bGQgcmVwb3J0IGFsbCBlcnJvcnMgdGhyb3VnaCB0aGVcbiAgICogcmV0dXJuZWQgY29udGV4dC5lcnJvcnMgb2JqZWN0LCBwcm9wZXJseSBhc3NvY2lhdGluZyBlcnJvcnMgdG8gdGhlaXIgZXJyb3JcbiAgICogYm91bmRhcnkuICBBZGRpdGlvbmFsbHksIGl0IHRyYWNrcyBfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCB3aGljaCBjYW4gYmVcbiAgICogdXNlZCB0byBlbXVsYXRlIFJlYWN0IGVycm9yIGJvdW5kYXJpZXMgZHVyaW5nIFNTciBieSBwZXJmb3JtaW5nIGEgc2Vjb25kXG4gICAqIHBhc3Mgb25seSBkb3duIHRvIHRoZSBib3VuZGFyeUlkLlxuICAgKlxuICAgKiBUaGUgb25lIGV4Y2VwdGlvbiB3aGVyZSB3ZSBkbyBub3QgcmV0dXJuIGEgU3RhdGljSGFuZGxlckNvbnRleHQgaXMgd2hlbiBhXG4gICAqIHJlZGlyZWN0IHJlc3BvbnNlIGlzIHJldHVybmVkIG9yIHRocm93biBmcm9tIGFueSBhY3Rpb24vbG9hZGVyLiAgV2VcbiAgICogcHJvcGFnYXRlIHRoYXQgb3V0IGFuZCByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBzbyB0aGUgSFRUUCBzZXJ2ZXIgY2FuXG4gICAqIHJldHVybiBpdCBkaXJlY3RseS5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5KHJlcXVlc3QsIF90ZW1wMykge1xuICAgIGxldCB7XG4gICAgICByZXF1ZXN0Q29udGV4dFxuICAgIH0gPSBfdGVtcDMgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAzO1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIC8vIFNTUiBzdXBwb3J0cyBIRUFEIHJlcXVlc3RzIHdoaWxlIFNQQSBkb2Vzbid0XG4gICAgaWYgKCFpc1ZhbGlkTWV0aG9kKG1ldGhvZCkgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kXG4gICAgICB9KTtcbiAgICAgIGxldCB7XG4gICAgICAgIG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLFxuICAgICAgICByb3V0ZVxuICAgICAgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHtcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICByb3V0ZVxuICAgICAgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXR1c0NvZGU6IGVycm9yLnN0YXR1cyxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9LFxuICAgICAgICBhY3RpdmVEZWZlcnJlZHM6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0KTtcbiAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBXaGVuIHJldHVybmluZyBTdGF0aWNIYW5kbGVyQ29udGV4dCwgd2UgcGF0Y2ggYmFjayBpbiB0aGUgbG9jYXRpb24gaGVyZVxuICAgIC8vIHNpbmNlIHdlIG5lZWQgaXQgZm9yIFJlYWN0IENvbnRleHQuICBCdXQgdGhpcyBoZWxwcyBrZWVwIG91ciBzdWJtaXQgYW5kXG4gICAgLy8gbG9hZFJvdXRlRGF0YSBvcGVyYXRpbmcgb24gYSBSZXF1ZXN0IGluc3RlYWQgb2YgYSBMb2NhdGlvblxuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIGJhc2VuYW1lXG4gICAgfSwgcmVzdWx0KTtcbiAgfVxuICAvKipcbiAgICogVGhlIHF1ZXJ5Um91dGUoKSBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIHRhcmdldGVkIHJvdXRlIHJlcXVlc3RzLCBlaXRoZXJcbiAgICogZm9yIGZldGNoID9fZGF0YSByZXF1ZXN0cyBvciByZXNvdXJjZSByb3V0ZSByZXF1ZXN0cy4gIEluIHRoaXMgY2FzZSwgd2VcbiAgICogYXJlIG9ubHkgZXZlciBjYWxsaW5nIGEgc2luZ2xlIGFjdGlvbiBvciBsb2FkZXIsIGFuZCB3ZSBhcmUgcmV0dXJuaW5nIHRoZVxuICAgKiByZXR1cm5lZCB2YWx1ZSBkaXJlY3RseS4gIEluIG1vc3QgY2FzZXMsIHRoaXMgd2lsbCBiZSBhIFJlc3BvbnNlIHJldHVybmVkXG4gICAqIGZyb20gdGhlIGFjdGlvbi9sb2FkZXIsIGJ1dCBpdCBtYXkgYmUgYSBwcmltaXRpdmUgb3Igb3RoZXIgdmFsdWUgYXMgd2VsbCAtXG4gICAqIGFuZCBpbiBzdWNoIGNhc2VzIHRoZSBjYWxsaW5nIGNvbnRleHQgc2hvdWxkIGhhbmRsZSB0aGF0IGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBXZSBkbyByZXNwZWN0IHRoZSB0aHJvdy9yZXR1cm4gZGlmZmVyZW50aWF0aW9uLCBzbyBpZiBhbiBhY3Rpb24vbG9hZGVyXG4gICAqIHRocm93cywgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHRocm93IHRoZSB2YWx1ZS4gIFRoaXMgaXMgaW1wb3J0YW50IHNvIHdlXG4gICAqIGNhbiBkbyBwcm9wZXIgYm91bmRhcnkgaWRlbnRpZmljYXRpb24gaW4gUmVtaXggd2hlcmUgYSB0aHJvd24gUmVzcG9uc2VcbiAgICogbXVzdCBnbyB0byB0aGUgQ2F0Y2ggQm91bmRhcnkgYnV0IGEgcmV0dXJuZWQgUmVzcG9uc2UgaXMgaGFwcHktcGF0aC5cbiAgICpcbiAgICogT25lIHRoaW5nIHRvIG5vdGUgaXMgdGhhdCBhbnkgUm91dGVyLWluaXRpYXRlZCBFcnJvcnMgdGhhdCBtYWtlIHNlbnNlXG4gICAqIHRvIGFzc29jaWF0ZSB3aXRoIGEgc3RhdHVzIGNvZGUgd2lsbCBiZSB0aHJvd24gYXMgYW4gRXJyb3JSZXNwb25zZVxuICAgKiBpbnN0YW5jZSB3aGljaCBpbmNsdWRlIHRoZSByYXcgRXJyb3IsIHN1Y2ggdGhhdCB0aGUgY2FsbGluZyBjb250ZXh0IGNhblxuICAgKiBzZXJpYWxpemUgdGhlIGVycm9yIGFzIHRoZXkgc2VlIGZpdCB3aGlsZSBpbmNsdWRpbmcgdGhlIHByb3BlciByZXNwb25zZVxuICAgKiBjb2RlLiAgRXhhbXBsZXMgaGVyZSBhcmUgNDA0IGFuZCA0MDUgZXJyb3JzIHRoYXQgb2NjdXIgcHJpb3IgdG8gcmVhY2hpbmdcbiAgICogYW55IHVzZXItZGVmaW5lZCBsb2FkZXJzLlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnlSb3V0ZShyZXF1ZXN0LCBfdGVtcDQpIHtcbiAgICBsZXQge1xuICAgICAgcm91dGVJZCxcbiAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgfSA9IF90ZW1wNCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDQ7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgLy8gU1NSIHN1cHBvcnRzIEhFQUQgcmVxdWVzdHMgd2hpbGUgU1BBIGRvZXNuJ3RcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiSEVBRFwiICYmIG1ldGhvZCAhPT0gXCJPUFRJT05TXCIpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgIG1ldGhvZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2hlcykge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gcm91dGVJZCA/IG1hdGNoZXMuZmluZChtID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpIDogZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuICAgIGlmIChyb3V0ZUlkICYmICFtYXRjaCkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDMsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGl0IEkgZG9uJ3QgdGhpbms/XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcXVlcnlJbXBsKHJlcXVlc3QsIGxvY2F0aW9uLCBtYXRjaGVzLCByZXF1ZXN0Q29udGV4dCwgbWF0Y2gpO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcnMgPyBPYmplY3QudmFsdWVzKHJlc3VsdC5lcnJvcnMpWzBdIDogdW5kZWZpbmVkO1xuICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB3ZSBnb3QgYmFjayByZXN1bHQuZXJyb3JzLCB0aGF0IG1lYW5zIHRoZSBsb2FkZXIvYWN0aW9uIHRocmV3XG4gICAgICAvLyBfc29tZXRoaW5nXyB0aGF0IHdhc24ndCBhIFJlc3BvbnNlLCBidXQgaXQncyBub3QgZ3VhcmFudGVlZC9yZXF1aXJlZFxuICAgICAgLy8gdG8gYmUgYW4gYGluc3RhbmNlb2YgRXJyb3JgIGVpdGhlciwgc28gd2UgaGF2ZSB0byB1c2UgdGhyb3cgaGVyZSB0b1xuICAgICAgLy8gcHJlc2VydmUgdGhlIFwiZXJyb3JcIiBzdGF0ZSBvdXRzaWRlIG9mIHF1ZXJ5SW1wbC5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBQaWNrIG9mZiB0aGUgcmlnaHQgc3RhdGUgdmFsdWUgdG8gcmV0dXJuXG4gICAgaWYgKHJlc3VsdC5hY3Rpb25EYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHQuYWN0aW9uRGF0YSlbMF07XG4gICAgfVxuICAgIGlmIChyZXN1bHQubG9hZGVyRGF0YSkge1xuICAgICAgdmFyIF9yZXN1bHQkYWN0aXZlRGVmZXJyZTtcbiAgICAgIGxldCBkYXRhID0gT2JqZWN0LnZhbHVlcyhyZXN1bHQubG9hZGVyRGF0YSlbMF07XG4gICAgICBpZiAoKF9yZXN1bHQkYWN0aXZlRGVmZXJyZSA9IHJlc3VsdC5hY3RpdmVEZWZlcnJlZHMpICE9IG51bGwgJiYgX3Jlc3VsdCRhY3RpdmVEZWZlcnJlW21hdGNoLnJvdXRlLmlkXSkge1xuICAgICAgICBkYXRhW1VOU0FGRV9ERUZFUlJFRF9TWU1CT0xdID0gcmVzdWx0LmFjdGl2ZURlZmVycmVkc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBxdWVyeUltcGwocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoKSB7XG4gICAgaW52YXJpYW50KHJlcXVlc3Quc2lnbmFsLCBcInF1ZXJ5KCkvcXVlcnlSb3V0ZSgpIHJlcXVlc3RzIG11c3QgY29udGFpbiBhbiBBYm9ydENvbnRyb2xsZXIgc2lnbmFsXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaXNNdXRhdGlvbk1ldGhvZChyZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgc3VibWl0KHJlcXVlc3QsIG1hdGNoZXMsIHJvdXRlTWF0Y2ggfHwgZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pLCByZXF1ZXN0Q29udGV4dCwgcm91dGVNYXRjaCAhPSBudWxsKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoKTtcbiAgICAgIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQgOiBfZXh0ZW5kcyh7fSwgcmVzdWx0LCB7XG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB0aHJldy9yZXR1cm5lZCBhIFJlc3BvbnNlIGluIGNhbGxMb2FkZXJPckFjdGlvbiwgd2UgdGhyb3dcbiAgICAgIC8vIGl0IHRvIGJhaWwgb3V0IGFuZCB0aGVuIHJldHVybiBvciB0aHJvdyBoZXJlIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHVzZXJcbiAgICAgIC8vIHJldHVybmVkIG9yIHRocmV3XG4gICAgICBpZiAoaXNRdWVyeVJvdXRlUmVzcG9uc2UoZSkpIHtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgICAgICAgIHRocm93IGUucmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUucmVzcG9uc2U7XG4gICAgICB9XG4gICAgICAvLyBSZWRpcmVjdHMgYXJlIGFsd2F5cyByZXR1cm5lZCBzaW5jZSB0aGV5IGRvbid0IHByb3BhZ2F0ZSB0byBjYXRjaFxuICAgICAgLy8gYm91bmRhcmllc1xuICAgICAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShlKSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdChyZXF1ZXN0LCBtYXRjaGVzLCBhY3Rpb25NYXRjaCwgcmVxdWVzdENvbnRleHQsIGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcGF0aG5hbWU6IG5ldyBVUkwocmVxdWVzdC51cmwpLnBhdGhuYW1lLFxuICAgICAgICByb3V0ZUlkOiBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgfSk7XG4gICAgICBpZiAoaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXCJhY3Rpb25cIiwgcmVxdWVzdCwgYWN0aW9uTWF0Y2gsIG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGJhc2VuYW1lLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgsIHtcbiAgICAgICAgaXNTdGF0aWNSZXF1ZXN0OiB0cnVlLFxuICAgICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IGlzUm91dGVSZXF1ZXN0ID8gXCJxdWVyeVJvdXRlXCIgOiBcInF1ZXJ5XCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyBcIigpIGNhbGwgYWJvcnRlZDogXCIgKyByZXF1ZXN0Lm1ldGhvZCArIFwiIFwiICsgcmVxdWVzdC51cmwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBVaGhoaCAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgd2Ugc2hvdWxkIGFsd2F5cyB0aHJvdyB0aGVzZSBmcm9tXG4gICAgICAvLyBjYWxsTG9hZGVyT3JBY3Rpb24sIGJ1dCB0aGUgdHlwZSBuYXJyb3dpbmcgaGVyZSBrZWVwcyBUUyBoYXBweSBhbmQgd2VcbiAgICAgIC8vIGNhbiBnZXQgYmFjayBvbiB0aGUgXCJ0aHJvdyBhbGwgcmVkaXJlY3QgcmVzcG9uc2VzXCIgdHJhaW4gaGVyZSBzaG91bGRcbiAgICAgIC8vIHRoaXMgZXZlciBoYXBwZW4gOi9cbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiByZXN1bHQubG9jYXRpb25cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7XG4gICAgICAgIHR5cGU6IFwiZGVmZXItYWN0aW9uXCJcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAvLyBOb3RlOiBUaGlzIHNob3VsZCBvbmx5IGJlIG5vbi1SZXNwb25zZSB2YWx1ZXMgaWYgd2UgZ2V0IGhlcmUsIHNpbmNlXG4gICAgICAvLyBpc1JvdXRlUmVxdWVzdCBzaG91bGQgdGhyb3cgYW55IFJlc3BvbnNlIHJlY2VpdmVkIGluIGNhbGxMb2FkZXJPckFjdGlvblxuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBbYWN0aW9uTWF0Y2hdLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBvciB2YWx1ZVxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcbiAgICAgIC8vIHRvIGNhbGwgYW5kIHdpbGwgY29tbWl0IGl0IHdoZW4gd2UgY29tcGxldGUgdGhlIG5hdmlnYXRpb25cbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIHVuZGVmaW5lZCwge1xuICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvclxuICAgICAgfSk7XG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dCwge1xuICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMCxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczogX2V4dGVuZHMoe30sIHJlc3VsdC5oZWFkZXJzID8ge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzXG4gICAgICAgIH0gOiB7fSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBHRVQgcmVxdWVzdCBmb3IgdGhlIGxvYWRlcnNcbiAgICBsZXQgbG9hZGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICByZWRpcmVjdDogcmVxdWVzdC5yZWRpcmVjdCxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgICB9KTtcbiAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEobG9hZGVyUmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dCwgcmVzdWx0LnN0YXR1c0NvZGUgPyB7XG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZVxuICAgIH0gOiB7fSwge1xuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgfSxcbiAgICAgIGFjdGlvbkhlYWRlcnM6IF9leHRlbmRzKHt9LCByZXN1bHQuaGVhZGVycyA/IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnNcbiAgICAgIH0gOiB7fSlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoLCBwZW5kaW5nQWN0aW9uRXJyb3IpIHtcbiAgICBsZXQgaXNSb3V0ZVJlcXVlc3QgPSByb3V0ZU1hdGNoICE9IG51bGw7XG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuIChxdWVyeVJvdXRlKCkpXG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0ICYmICEocm91dGVNYXRjaCAhPSBudWxsICYmIHJvdXRlTWF0Y2gucm91dGUubG9hZGVyKSAmJiAhKHJvdXRlTWF0Y2ggIT0gbnVsbCAmJiByb3V0ZU1hdGNoLnJvdXRlLmxhenkpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IHJvdXRlTWF0Y2gucm91dGUuaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgcmVxdWVzdE1hdGNoZXMgPSByb3V0ZU1hdGNoID8gW3JvdXRlTWF0Y2hdIDogZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgT2JqZWN0LmtleXMocGVuZGluZ0FjdGlvbkVycm9yIHx8IHt9KVswXSk7XG4gICAgbGV0IG1hdGNoZXNUb0xvYWQgPSByZXF1ZXN0TWF0Y2hlcy5maWx0ZXIobSA9PiBtLnJvdXRlLmxvYWRlciB8fCBtLnJvdXRlLmxhenkpO1xuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnkoKSlcbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIC8vIEFkZCBhIG51bGwgZm9yIGFsbCBtYXRjaGVkIHJvdXRlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgICAgIGxvYWRlckRhdGE6IG1hdGNoZXMucmVkdWNlKChhY2MsIG0pID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7XG4gICAgICAgICAgW20ucm91dGUuaWRdOiBudWxsXG4gICAgICAgIH0pLCB7fSksXG4gICAgICAgIGVycm9yczogcGVuZGluZ0FjdGlvbkVycm9yIHx8IG51bGwsXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChbLi4ubWF0Y2hlc1RvTG9hZC5tYXAobWF0Y2ggPT4gY2FsbExvYWRlck9yQWN0aW9uKFwibG9hZGVyXCIsIHJlcXVlc3QsIG1hdGNoLCBtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwgZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoLCB7XG4gICAgICBpc1N0YXRpY1JlcXVlc3Q6IHRydWUsXG4gICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgfSkpXSk7XG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArIFwiKCkgY2FsbCBhYm9ydGVkOiBcIiArIHJlcXVlc3QubWV0aG9kICsgXCIgXCIgKyByZXF1ZXN0LnVybCk7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgYW5kIGNvbW1pdCBvdXRwdXQgZnJvbSBsb2FkZXJzXG4gICAgbGV0IGFjdGl2ZURlZmVycmVkcyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgY29udGV4dCA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEobWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgcmVzdWx0cywgcGVuZGluZ0FjdGlvbkVycm9yLCBhY3RpdmVEZWZlcnJlZHMpO1xuICAgIC8vIEFkZCBhIG51bGwgZm9yIGFueSBub24tbG9hZGVyIG1hdGNoZXMgZm9yIHByb3BlciByZXZhbGlkYXRpb24gb24gdGhlIGNsaWVudFxuICAgIGxldCBleGVjdXRlZExvYWRlcnMgPSBuZXcgU2V0KG1hdGNoZXNUb0xvYWQubWFwKG1hdGNoID0+IG1hdGNoLnJvdXRlLmlkKSk7XG4gICAgbWF0Y2hlcy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgIGlmICghZXhlY3V0ZWRMb2FkZXJzLmhhcyhtYXRjaC5yb3V0ZS5pZCkpIHtcbiAgICAgICAgY29udGV4dC5sb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBjb250ZXh0LCB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgYWN0aXZlRGVmZXJyZWRzOiBhY3RpdmVEZWZlcnJlZHMuc2l6ZSA+IDAgPyBPYmplY3QuZnJvbUVudHJpZXMoYWN0aXZlRGVmZXJyZWRzLmVudHJpZXMoKSkgOiBudWxsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhUm91dGVzLFxuICAgIHF1ZXJ5LFxuICAgIHF1ZXJ5Um91dGVcbiAgfTtcbn1cbi8vI2VuZHJlZ2lvblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBIZWxwZXJzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBHaXZlbiBhbiBleGlzdGluZyBTdGF0aWNIYW5kbGVyQ29udGV4dCBhbmQgYW4gZXJyb3IgdGhyb3duIGF0IHJlbmRlciB0aW1lLFxuICogcHJvdmlkZSBhbiB1cGRhdGVkIFN0YXRpY0hhbmRsZXJDb250ZXh0IHN1aXRhYmxlIGZvciBhIHNlY29uZCBTU1IgcmVuZGVyXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3Iocm91dGVzLCBjb250ZXh0LCBlcnJvcikge1xuICBsZXQgbmV3Q29udGV4dCA9IF9leHRlbmRzKHt9LCBjb250ZXh0LCB7XG4gICAgc3RhdHVzQ29kZTogNTAwLFxuICAgIGVycm9yczoge1xuICAgICAgW2NvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgfHwgcm91dGVzWzBdLmlkXTogZXJyb3JcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3Q29udGV4dDtcbn1cbmZ1bmN0aW9uIGlzU3VibWlzc2lvbk5hdmlnYXRpb24ob3B0cykge1xuICByZXR1cm4gb3B0cyAhPSBudWxsICYmIChcImZvcm1EYXRhXCIgaW4gb3B0cyAmJiBvcHRzLmZvcm1EYXRhICE9IG51bGwgfHwgXCJib2R5XCIgaW4gb3B0cyAmJiBvcHRzLmJvZHkgIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUbyhsb2NhdGlvbiwgbWF0Y2hlcywgYmFzZW5hbWUsIHByZXBlbmRCYXNlbmFtZSwgdG8sIHY3X3JlbGF0aXZlU3BsYXRQYXRoLCBmcm9tUm91dGVJZCwgcmVsYXRpdmUpIHtcbiAgbGV0IGNvbnRleHR1YWxNYXRjaGVzO1xuICBsZXQgYWN0aXZlUm91dGVNYXRjaDtcbiAgaWYgKGZyb21Sb3V0ZUlkKSB7XG4gICAgLy8gR3JhYiBtYXRjaGVzIHVwIHRvIHRoZSBjYWxsaW5nIHJvdXRlIHNvIG91ciByb3V0ZS1yZWxhdGl2ZSBsb2dpYyBpc1xuICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBjb3JyZWN0IHNvdXJjZSByb3V0ZVxuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29udGV4dHVhbE1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IGZyb21Sb3V0ZUlkKSB7XG4gICAgICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8vIFJlc29sdmUgdGhlIHJlbGF0aXZlIHBhdGhcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8odG8gPyB0byA6IFwiLlwiLCBnZXRSZXNvbHZlVG9NYXRjaGVzKGNvbnRleHR1YWxNYXRjaGVzLCB2N19yZWxhdGl2ZVNwbGF0UGF0aCksIHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBsb2NhdGlvbi5wYXRobmFtZSwgcmVsYXRpdmUgPT09IFwicGF0aFwiKTtcbiAgLy8gV2hlbiBgdG9gIGlzIG5vdCBzcGVjaWZpZWQgd2UgaW5oZXJpdCBzZWFyY2gvaGFzaCBmcm9tIHRoZSBjdXJyZW50XG4gIC8vIGxvY2F0aW9uLCB1bmxpa2Ugd2hlbiB0bz1cIi5cIiBhbmQgd2UganVzdCBpbmhlcml0IHRoZSBwYXRoLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZW1peC9pc3N1ZXMvOTI3XG4gIGlmICh0byA9PSBudWxsKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgcGF0aC5oYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgfVxuICAvLyBBZGQgYW4gP2luZGV4IHBhcmFtIGZvciBtYXRjaGVkIGluZGV4IHJvdXRlcyBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICgodG8gPT0gbnVsbCB8fCB0byA9PT0gXCJcIiB8fCB0byA9PT0gXCIuXCIpICYmIGFjdGl2ZVJvdXRlTWF0Y2ggJiYgYWN0aXZlUm91dGVNYXRjaC5yb3V0ZS5pbmRleCAmJiAhaGFzTmFrZWRJbmRleFF1ZXJ5KHBhdGguc2VhcmNoKSkge1xuICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgfVxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lLiAgSWZcbiAgLy8gdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZSB0aGUgcmF3IGJhc2VuYW1lIHdoaWNoIGFsbG93c1xuICAvLyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgcHJlc2VuY2Ugb2YgYSB0cmFpbGluZyBzbGFzaFxuICAvLyBvbiByb290IGFjdGlvbnNcbiAgaWYgKHByZXBlbmRCYXNlbmFtZSAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cbi8vIE5vcm1hbGl6ZSBuYXZpZ2F0aW9uIG9wdGlvbnMgYnkgY29udmVydGluZyBmb3JtTWV0aG9kPUdFVCBmb3JtRGF0YSBvYmplY3RzIHRvXG4vLyBVUkxTZWFyY2hQYXJhbXMgc28gdGhleSBiZWhhdmUgaWRlbnRpY2FsbHkgdG8gbGlua3Mgd2l0aCBxdWVyeSBwYXJhbXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhub3JtYWxpemVGb3JtTWV0aG9kLCBpc0ZldGNoZXIsIHBhdGgsIG9wdHMpIHtcbiAgLy8gUmV0dXJuIGxvY2F0aW9uIHZlcmJhdGltIG9uIG5vbi1zdWJtaXNzaW9uIG5hdmlnYXRpb25zXG4gIGlmICghb3B0cyB8fCAhaXNTdWJtaXNzaW9uTmF2aWdhdGlvbihvcHRzKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoXG4gICAgfTtcbiAgfVxuICBpZiAob3B0cy5mb3JtTWV0aG9kICYmICFpc1ZhbGlkTWV0aG9kKG9wdHMuZm9ybU1ldGhvZCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IG9wdHMuZm9ybU1ldGhvZFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIGxldCBnZXRJbnZhbGlkQm9keUVycm9yID0gKCkgPT4gKHtcbiAgICBwYXRoLFxuICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgdHlwZTogXCJpbnZhbGlkLWJvZHlcIlxuICAgIH0pXG4gIH0pO1xuICAvLyBDcmVhdGUgYSBTdWJtaXNzaW9uIG9uIG5vbi1HRVQgbmF2aWdhdGlvbnNcbiAgbGV0IHJhd0Zvcm1NZXRob2QgPSBvcHRzLmZvcm1NZXRob2QgfHwgXCJnZXRcIjtcbiAgbGV0IGZvcm1NZXRob2QgPSBub3JtYWxpemVGb3JtTWV0aG9kID8gcmF3Rm9ybU1ldGhvZC50b1VwcGVyQ2FzZSgpIDogcmF3Rm9ybU1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICBsZXQgZm9ybUFjdGlvbiA9IHN0cmlwSGFzaEZyb21QYXRoKHBhdGgpO1xuICBpZiAob3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIC8vIHRleHQgb25seSBzdXBwb3J0IFBPU1QvUFVUL1BBVENIL0RFTEVURSBzdWJtaXNzaW9uc1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgICBsZXQgdGV4dCA9IHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBvcHRzLmJvZHkgOiBvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSB8fCBvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgP1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjcGxhaW4tdGV4dC1mb3JtLWRhdGFcbiAgICAgIEFycmF5LmZyb20ob3B0cy5ib2R5LmVudHJpZXMoKSkucmVkdWNlKChhY2MsIF9yZWYzKSA9PiB7XG4gICAgICAgIGxldCBbbmFtZSwgdmFsdWVdID0gX3JlZjM7XG4gICAgICAgIHJldHVybiBcIlwiICsgYWNjICsgbmFtZSArIFwiPVwiICsgdmFsdWUgKyBcIlxcblwiO1xuICAgICAgfSwgXCJcIikgOiBTdHJpbmcob3B0cy5ib2R5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0cy5mb3JtRW5jVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICAgIC8vIGpzb24gb25seSBzdXBwb3J0cyBQT1NUL1BVVC9QQVRDSC9ERUxFVEUgc3VibWlzc2lvbnNcbiAgICAgIGlmICghaXNNdXRhdGlvbk1ldGhvZChmb3JtTWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGpzb24gPSB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiID8gSlNPTi5wYXJzZShvcHRzLmJvZHkpIDogb3B0cy5ib2R5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICAgIGZvcm1BY3Rpb24sXG4gICAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0cy5mb3JtRW5jVHlwZSxcbiAgICAgICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbnZhcmlhbnQodHlwZW9mIEZvcm1EYXRhID09PSBcImZ1bmN0aW9uXCIsIFwiRm9ybURhdGEgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50XCIpO1xuICBsZXQgc2VhcmNoUGFyYW1zO1xuICBsZXQgZm9ybURhdGE7XG4gIGlmIChvcHRzLmZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5mb3JtRGF0YSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmZvcm1EYXRhO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICBmb3JtRGF0YSA9IG9wdHMuYm9keTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBvcHRzLmJvZHk7XG4gICAgZm9ybURhdGEgPSBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShzZWFyY2hQYXJhbXMpO1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSA9PSBudWxsKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0cy5ib2R5KTtcbiAgICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgIH1cbiAgfVxuICBsZXQgc3VibWlzc2lvbiA9IHtcbiAgICBmb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IG9wdHMgJiYgb3B0cy5mb3JtRW5jVHlwZSB8fCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgIGZvcm1EYXRhLFxuICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICB0ZXh0OiB1bmRlZmluZWRcbiAgfTtcbiAgaWYgKGlzTXV0YXRpb25NZXRob2Qoc3VibWlzc2lvbi5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgc3VibWlzc2lvblxuICAgIH07XG4gIH1cbiAgLy8gRmxhdHRlbiBzdWJtaXNzaW9uIG9udG8gVVJMU2VhcmNoUGFyYW1zIGZvciBHRVQgc3VibWlzc2lvbnNcbiAgbGV0IHBhcnNlZFBhdGggPSBwYXJzZVBhdGgocGF0aCk7XG4gIC8vIE9uIEdFVCBuYXZpZ2F0aW9uIHN1Ym1pc3Npb25zIHdlIGNhbiBkcm9wIHRoZSA/aW5kZXggcGFyYW0gZnJvbSB0aGVcbiAgLy8gcmVzdWx0aW5nIGxvY2F0aW9uIHNpbmNlIGFsbCBsb2FkZXJzIHdpbGwgcnVuLiAgQnV0IGZldGNoZXIgR0VUIHN1Ym1pc3Npb25zXG4gIC8vIG9ubHkgcnVuIGEgc2luZ2xlIGxvYWRlciBzbyB3ZSBuZWVkIHRvIHByZXNlcnZlIGFueSBpbmNvbWluZyA/aW5kZXggcGFyYW1zXG4gIGlmIChpc0ZldGNoZXIgJiYgcGFyc2VkUGF0aC5zZWFyY2ggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHBhcnNlZFBhdGguc2VhcmNoKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCBcIlwiKTtcbiAgfVxuICBwYXJzZWRQYXRoLnNlYXJjaCA9IFwiP1wiICsgc2VhcmNoUGFyYW1zO1xuICByZXR1cm4ge1xuICAgIHBhdGg6IGNyZWF0ZVBhdGgocGFyc2VkUGF0aCksXG4gICAgc3VibWlzc2lvblxuICB9O1xufVxuLy8gRmlsdGVyIG91dCBhbGwgcm91dGVzIGJlbG93IGFueSBjYXVnaHQgZXJyb3IgYXMgdGhleSBhcmVuJ3QgZ29pbmcgdG9cbi8vIHJlbmRlciBzbyB3ZSBkb24ndCBuZWVkIHRvIGxvYWQgdGhlbVxuZnVuY3Rpb24gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgYm91bmRhcnlJZCkge1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcztcbiAgaWYgKGJvdW5kYXJ5SWQpIHtcbiAgICBsZXQgaW5kZXggPSBtYXRjaGVzLmZpbmRJbmRleChtID0+IG0ucm91dGUuaWQgPT09IGJvdW5kYXJ5SWQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBib3VuZGFyeU1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIGluZGV4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kYXJ5TWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXNUb0xvYWQoaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIHN1Ym1pc3Npb24sIGxvY2F0aW9uLCBpc0luaXRpYWxMb2FkLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcywgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBkZWxldGVkRmV0Y2hlcnMsIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwgcGVuZGluZ0FjdGlvbkRhdGEsIHBlbmRpbmdFcnJvcikge1xuICBsZXQgYWN0aW9uUmVzdWx0ID0gcGVuZGluZ0Vycm9yID8gT2JqZWN0LnZhbHVlcyhwZW5kaW5nRXJyb3IpWzBdIDogcGVuZGluZ0FjdGlvbkRhdGEgPyBPYmplY3QudmFsdWVzKHBlbmRpbmdBY3Rpb25EYXRhKVswXSA6IHVuZGVmaW5lZDtcbiAgbGV0IGN1cnJlbnRVcmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdGF0ZS5sb2NhdGlvbik7XG4gIGxldCBuZXh0VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwobG9jYXRpb24pO1xuICAvLyBQaWNrIG5hdmlnYXRpb24gbWF0Y2hlcyB0aGF0IGFyZSBuZXQtbmV3IG9yIHF1YWxpZnkgZm9yIHJldmFsaWRhdGlvblxuICBsZXQgYm91bmRhcnlJZCA9IHBlbmRpbmdFcnJvciA/IE9iamVjdC5rZXlzKHBlbmRpbmdFcnJvcilbMF0gOiB1bmRlZmluZWQ7XG4gIGxldCBib3VuZGFyeU1hdGNoZXMgPSBnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeShtYXRjaGVzLCBib3VuZGFyeUlkKTtcbiAgbGV0IG5hdmlnYXRpb25NYXRjaGVzID0gYm91bmRhcnlNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHJvdXRlXG4gICAgfSA9IG1hdGNoO1xuICAgIGlmIChyb3V0ZS5sYXp5KSB7XG4gICAgICAvLyBXZSBoYXZlbid0IGxvYWRlZCB0aGlzIHJvdXRlIHlldCBzbyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgZ290IGEgbG9hZGVyIVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyb3V0ZS5sb2FkZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNJbml0aWFsTG9hZCkge1xuICAgICAgaWYgKHJvdXRlLmxvYWRlci5oeWRyYXRlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGUuaWRdID09PSB1bmRlZmluZWQgJiYgKFxuICAgICAgLy8gRG9uJ3QgcmUtcnVuIGlmIHRoZSBsb2FkZXIgcmFuIGFuZCB0aHJldyBhbiBlcnJvclxuICAgICAgIXN0YXRlLmVycm9ycyB8fCBzdGF0ZS5lcnJvcnNbcm91dGUuaWRdID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvLyBBbHdheXMgY2FsbCB0aGUgbG9hZGVyIG9uIG5ldyByb3V0ZSBpbnN0YW5jZXMgYW5kIHBlbmRpbmcgZGVmZXIgY2FuY2VsbGF0aW9uc1xuICAgIGlmIChpc05ld0xvYWRlcihzdGF0ZS5sb2FkZXJEYXRhLCBzdGF0ZS5tYXRjaGVzW2luZGV4XSwgbWF0Y2gpIHx8IGNhbmNlbGxlZERlZmVycmVkUm91dGVzLnNvbWUoaWQgPT4gaWQgPT09IG1hdGNoLnJvdXRlLmlkKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHdoZW4gd2UgcmV2YWxpZGF0ZS4gIElmIHRoZSByb3V0ZVxuICAgIC8vIHByb3ZpZGVzIGl0J3Mgb3duIGltcGxlbWVudGF0aW9uLCB0aGVuIHdlIGdpdmUgdGhlbSBmdWxsIGNvbnRyb2wgYnV0XG4gICAgLy8gcHJvdmlkZSB0aGlzIHZhbHVlIHNvIHRoZXkgY2FuIGxldmVyYWdlIGl0IGlmIG5lZWRlZCBhZnRlciB0aGV5IGNoZWNrXG4gICAgLy8gdGhlaXIgb3duIHNwZWNpZmljIHVzZSBjYXNlc1xuICAgIGxldCBjdXJyZW50Um91dGVNYXRjaCA9IHN0YXRlLm1hdGNoZXNbaW5kZXhdO1xuICAgIGxldCBuZXh0Um91dGVNYXRjaCA9IG1hdGNoO1xuICAgIHJldHVybiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKG1hdGNoLCBfZXh0ZW5kcyh7XG4gICAgICBjdXJyZW50VXJsLFxuICAgICAgY3VycmVudFBhcmFtczogY3VycmVudFJvdXRlTWF0Y2gucGFyYW1zLFxuICAgICAgbmV4dFVybCxcbiAgICAgIG5leHRQYXJhbXM6IG5leHRSb3V0ZU1hdGNoLnBhcmFtc1xuICAgIH0sIHN1Ym1pc3Npb24sIHtcbiAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOlxuICAgICAgLy8gRm9yY2VkIHJldmFsaWRhdGlvbiBkdWUgdG8gc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0b3IsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZVxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCB8fFxuICAgICAgLy8gQ2xpY2tlZCB0aGUgc2FtZSBsaW5rLCByZXN1Ym1pdHRlZCBhIEdFVCBmb3JtXG4gICAgICBjdXJyZW50VXJsLnBhdGhuYW1lICsgY3VycmVudFVybC5zZWFyY2ggPT09IG5leHRVcmwucGF0aG5hbWUgKyBuZXh0VXJsLnNlYXJjaCB8fFxuICAgICAgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcbiAgICAgIGN1cnJlbnRVcmwuc2VhcmNoICE9PSBuZXh0VXJsLnNlYXJjaCB8fCBpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudFJvdXRlTWF0Y2gsIG5leHRSb3V0ZU1hdGNoKVxuICAgIH0pKTtcbiAgfSk7XG4gIC8vIFBpY2sgZmV0Y2hlci5sb2FkcyB0aGF0IG5lZWQgdG8gYmUgcmV2YWxpZGF0ZWRcbiAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXJzID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoZiwga2V5KSA9PiB7XG4gICAgLy8gRG9uJ3QgcmV2YWxpZGF0ZTpcbiAgICAvLyAgLSBvbiBpbml0aWFsIGxvYWQgKHNob3VsZG4ndCBiZSBhbnkgZmV0Y2hlcnMgdGhlbiBhbnl3YXkpXG4gICAgLy8gIC0gaWYgZmV0Y2hlciB3b24ndCBiZSBwcmVzZW50IGluIHRoZSBzdWJzZXF1ZW50IHJlbmRlclxuICAgIC8vICAgIC0gbm8gbG9uZ2VyIG1hdGNoZXMgdGhlIFVSTCAodjdfZmV0Y2hlclBlcnNpc3Q9ZmFsc2UpXG4gICAgLy8gICAgLSB3YXMgdW5tb3VudGVkIGJ1dCBwZXJzaXN0ZWQgZHVlIHRvIHY3X2ZldGNoZXJQZXJzaXN0PXRydWVcbiAgICBpZiAoaXNJbml0aWFsTG9hZCB8fCAhbWF0Y2hlcy5zb21lKG0gPT4gbS5yb3V0ZS5pZCA9PT0gZi5yb3V0ZUlkKSB8fCBkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZldGNoZXJNYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGYucGF0aCwgYmFzZW5hbWUpO1xuICAgIC8vIElmIHRoZSBmZXRjaGVyIHBhdGggbm8gbG9uZ2VyIG1hdGNoZXMsIHB1c2ggaXQgaW4gd2l0aCBudWxsIG1hdGNoZXMgc29cbiAgICAvLyB3ZSBjYW4gdHJpZ2dlciBhIDQwNCBpbiBjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEuICBOb3RlIHRoaXMgaXNcbiAgICAvLyBjdXJyZW50bHkgb25seSBhIHVzZS1jYXNlIGZvciBSZW1peCBITVIgd2hlcmUgdGhlIHJvdXRlIHRyZWUgY2FuIGNoYW5nZVxuICAgIC8vIGF0IHJ1bnRpbWUgYW5kIHJlbW92ZSBhIHJvdXRlIHByZXZpb3VzbHkgbG9hZGVkIHZpYSBhIGZldGNoZXJcbiAgICBpZiAoIWZldGNoZXJNYXRjaGVzKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogbnVsbCxcbiAgICAgICAgbWF0Y2g6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZXZhbGlkYXRpbmcgZmV0Y2hlcnMgYXJlIGRlY291cGxlZCBmcm9tIHRoZSByb3V0ZSBtYXRjaGVzIHNpbmNlIHRoZXlcbiAgICAvLyBsb2FkIGZyb20gYSBzdGF0aWMgaHJlZi4gIFRoZXkgcmV2YWxpZGF0ZSBiYXNlZCBvbiBleHBsaWNpdCByZXZhbGlkYXRpb25cbiAgICAvLyAoc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0b3IsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZSlcbiAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyTWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChmZXRjaGVyTWF0Y2hlcywgZi5wYXRoKTtcbiAgICBsZXQgc2hvdWxkUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgIGlmIChmZXRjaFJlZGlyZWN0SWRzLmhhcyhrZXkpKSB7XG4gICAgICAvLyBOZXZlciB0cmlnZ2VyIGEgcmV2YWxpZGF0aW9uIG9mIGFuIGFjdGl2ZWx5IHJlZGlyZWN0aW5nIGZldGNoZXJcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAvLyBBbHdheXMgcmV2YWxpZGF0ZSBpZiB0aGUgZmV0Y2hlciB3YXMgY2FuY2VsbGVkXG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGZldGNoZXIgJiYgZmV0Y2hlci5zdGF0ZSAhPT0gXCJpZGxlXCIgJiYgZmV0Y2hlci5kYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIHRoZSBmZXRjaGVyIGhhc24ndCBldmVyIGNvbXBsZXRlZCBsb2FkaW5nIHlldCwgdGhlbiB0aGlzIGlzbid0IGFcbiAgICAgIC8vIHJldmFsaWRhdGlvbiwgaXQgd291bGQganVzdCBiZSBhIGJyYW5kIG5ldyBsb2FkIGlmIGFuIGV4cGxpY2l0XG4gICAgICAvLyByZXZhbGlkYXRpb24gaXMgcmVxdWlyZWRcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBpc1JldmFsaWRhdGlvblJlcXVpcmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgZmFsbCBiYWNrIG9uIGFueSB1c2VyLWRlZmluZWQgc2hvdWxkUmV2YWxpZGF0ZSwgZGVmYXVsdGluZ1xuICAgICAgLy8gdG8gZXhwbGljaXQgcmV2YWxpZGF0aW9ucyBvbmx5XG4gICAgICBzaG91bGRSZXZhbGlkYXRlID0gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihmZXRjaGVyTWF0Y2gsIF9leHRlbmRzKHtcbiAgICAgICAgY3VycmVudFVybCxcbiAgICAgICAgY3VycmVudFBhcmFtczogc3RhdGUubWF0Y2hlc1tzdGF0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdLnBhcmFtcyxcbiAgICAgICAgbmV4dFVybCxcbiAgICAgICAgbmV4dFBhcmFtczogbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnBhcmFtc1xuICAgICAgfSwgc3VibWlzc2lvbiwge1xuICAgICAgICBhY3Rpb25SZXN1bHQsXG4gICAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiBpc1JldmFsaWRhdGlvblJlcXVpcmVkXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogZmV0Y2hlck1hdGNoZXMsXG4gICAgICAgIG1hdGNoOiBmZXRjaGVyTWF0Y2gsXG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFtuYXZpZ2F0aW9uTWF0Y2hlcywgcmV2YWxpZGF0aW5nRmV0Y2hlcnNdO1xufVxuZnVuY3Rpb24gaXNOZXdMb2FkZXIoY3VycmVudExvYWRlckRhdGEsIGN1cnJlbnRNYXRjaCwgbWF0Y2gpIHtcbiAgbGV0IGlzTmV3ID1cbiAgLy8gW2FdIC0+IFthLCBiXVxuICAhY3VycmVudE1hdGNoIHx8XG4gIC8vIFthLCBiXSAtPiBbYSwgY11cbiAgbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaC5yb3V0ZS5pZDtcbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHRoYXQgd2UgZG9uJ3QgaGF2ZSBkYXRhIGZvciBhIHJlLXVzZWQgcm91dGUsIHBvdGVudGlhbGx5XG4gIC8vIGZyb20gYSBwcmlvciBlcnJvciBvciBmcm9tIGEgY2FuY2VsbGVkIHBlbmRpbmcgZGVmZXJyZWRcbiAgbGV0IGlzTWlzc2luZ0RhdGEgPSBjdXJyZW50TG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPT09IHVuZGVmaW5lZDtcbiAgLy8gQWx3YXlzIGxvYWQgaWYgdGhpcyBpcyBhIG5ldC1uZXcgcm91dGUgb3Igd2UgZG9uJ3QgeWV0IGhhdmUgZGF0YVxuICByZXR1cm4gaXNOZXcgfHwgaXNNaXNzaW5nRGF0YTtcbn1cbmZ1bmN0aW9uIGlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50TWF0Y2gsIG1hdGNoKSB7XG4gIGxldCBjdXJyZW50UGF0aCA9IGN1cnJlbnRNYXRjaC5yb3V0ZS5wYXRoO1xuICByZXR1cm4gKFxuICAgIC8vIHBhcmFtIGNoYW5nZSBmb3IgdGhpcyBtYXRjaCwgL3VzZXJzLzEyMyAtPiAvdXNlcnMvNDU2XG4gICAgY3VycmVudE1hdGNoLnBhdGhuYW1lICE9PSBtYXRjaC5wYXRobmFtZSB8fFxuICAgIC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAvLyBlLmcuIC9maWxlcy9pbWFnZXMvYXZhdGFyLmpwZyAtPiBmaWxlcy9maW5hbmNlcy54bHNcbiAgICBjdXJyZW50UGF0aCAhPSBudWxsICYmIGN1cnJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSAmJiBjdXJyZW50TWF0Y2gucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxuICApO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihsb2FkZXJNYXRjaCwgYXJnKSB7XG4gIGlmIChsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IHJvdXRlQ2hvaWNlID0gbG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZShhcmcpO1xuICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG59XG4vKipcbiAqIEV4ZWN1dGUgcm91dGUubGF6eSgpIG1ldGhvZHMgdG8gbGF6aWx5IGxvYWQgcm91dGUgbW9kdWxlcyAobG9hZGVyLCBhY3Rpb24sXG4gKiBzaG91bGRSZXZhbGlkYXRlKSBhbmQgdXBkYXRlIHRoZSByb3V0ZU1hbmlmZXN0IGluIHBsYWNlIHdoaWNoIHNoYXJlcyBvYmplY3RzXG4gKiB3aXRoIGRhdGFSb3V0ZXMgc28gdGhvc2UgZ2V0IHVwZGF0ZWQgYXMgd2VsbC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZExhenlSb3V0ZU1vZHVsZShyb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCkge1xuICBpZiAoIXJvdXRlLmxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGxhenlSb3V0ZSA9IGF3YWl0IHJvdXRlLmxhenkoKTtcbiAgLy8gSWYgdGhlIGxhenkgcm91dGUgZnVuY3Rpb24gd2FzIGV4ZWN1dGVkIGFuZCByZW1vdmVkIGJ5IGFub3RoZXIgcGFyYWxsZWxcbiAgLy8gY2FsbCB0aGVuIHdlIGNhbiByZXR1cm4gLSBmaXJzdCBsYXp5KCkgdG8gZmluaXNoIHdpbnMgYmVjYXVzZSB0aGUgcmV0dXJuXG4gIC8vIHZhbHVlIG9mIGxhenkgaXMgZXhwZWN0ZWQgdG8gYmUgc3RhdGljXG4gIGlmICghcm91dGUubGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgcm91dGVUb1VwZGF0ZSA9IG1hbmlmZXN0W3JvdXRlLmlkXTtcbiAgaW52YXJpYW50KHJvdXRlVG9VcGRhdGUsIFwiTm8gcm91dGUgZm91bmQgaW4gbWFuaWZlc3RcIik7XG4gIC8vIFVwZGF0ZSB0aGUgcm91dGUgaW4gcGxhY2UuICBUaGlzIHNob3VsZCBiZSBzYWZlIGJlY2F1c2UgdGhlcmUncyBubyB3YXlcbiAgLy8gd2UgY291bGQgeWV0IGJlIHNpdHRpbmcgb24gdGhpcyByb3V0ZSBhcyB3ZSBjYW4ndCBnZXQgdGhlcmUgd2l0aG91dFxuICAvLyByZXNvbHZpbmcgbGF6eSgpIGZpcnN0LlxuICAvL1xuICAvLyBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBITVIgXCJ1cGRhdGVcIiB1c2UtY2FzZSB3aGVyZSB3ZSBtYXkgYWN0aXZlbHkgYmVcbiAgLy8gb24gdGhlIHJvdXRlIGJlaW5nIHVwZGF0ZWQuICBUaGUgbWFpbiBjb25jZXJuIGJvaWxzIGRvd24gdG8gXCJkb2VzIHRoaXNcbiAgLy8gbXV0YXRpb24gYWZmZWN0IGFueSBvbmdvaW5nIG5hdmlnYXRpb25zIG9yIGFueSBjdXJyZW50IHN0YXRlLm1hdGNoZXNcbiAgLy8gdmFsdWVzP1wiLiAgSWYgbm90LCBpdCBzaG91bGQgYmUgc2FmZSB0byB1cGRhdGUgaW4gcGxhY2UuXG4gIGxldCByb3V0ZVVwZGF0ZXMgPSB7fTtcbiAgZm9yIChsZXQgbGF6eVJvdXRlUHJvcGVydHkgaW4gbGF6eVJvdXRlKSB7XG4gICAgbGV0IHN0YXRpY1JvdXRlVmFsdWUgPSByb3V0ZVRvVXBkYXRlW2xhenlSb3V0ZVByb3BlcnR5XTtcbiAgICBsZXQgaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkID0gc3RhdGljUm91dGVWYWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgLy8gVGhpcyBwcm9wZXJ0eSBpc24ndCBzdGF0aWMgc2luY2UgaXQgc2hvdWxkIGFsd2F5cyBiZSB1cGRhdGVkIGJhc2VkXG4gICAgLy8gb24gdGhlIHJvdXRlIHVwZGF0ZXNcbiAgICBsYXp5Um91dGVQcm9wZXJ0eSAhPT0gXCJoYXNFcnJvckJvdW5kYXJ5XCI7XG4gICAgd2FybmluZyghaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkLCBcIlJvdXRlIFxcXCJcIiArIHJvdXRlVG9VcGRhdGUuaWQgKyBcIlxcXCIgaGFzIGEgc3RhdGljIHByb3BlcnR5IFxcXCJcIiArIGxhenlSb3V0ZVByb3BlcnR5ICsgXCJcXFwiIFwiICsgXCJkZWZpbmVkIGJ1dCBpdHMgbGF6eSBmdW5jdGlvbiBpcyBhbHNvIHJldHVybmluZyBhIHZhbHVlIGZvciB0aGlzIHByb3BlcnR5LiBcIiArIChcIlRoZSBsYXp5IHJvdXRlIHByb3BlcnR5IFxcXCJcIiArIGxhenlSb3V0ZVByb3BlcnR5ICsgXCJcXFwiIHdpbGwgYmUgaWdub3JlZC5cIikpO1xuICAgIGlmICghaXNQcm9wZXJ0eVN0YXRpY2FsbHlEZWZpbmVkICYmICFpbW11dGFibGVSb3V0ZUtleXMuaGFzKGxhenlSb3V0ZVByb3BlcnR5KSkge1xuICAgICAgcm91dGVVcGRhdGVzW2xhenlSb3V0ZVByb3BlcnR5XSA9IGxhenlSb3V0ZVtsYXp5Um91dGVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIC8vIE11dGF0ZSB0aGUgcm91dGUgd2l0aCB0aGUgcHJvdmlkZWQgdXBkYXRlcy4gIERvIHRoaXMgZmlyc3Qgc28gd2UgcGFzc1xuICAvLyB0aGUgdXBkYXRlZCB2ZXJzaW9uIHRvIG1hcFJvdXRlUHJvcGVydGllc1xuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIHJvdXRlVXBkYXRlcyk7XG4gIC8vIE11dGF0ZSB0aGUgYGhhc0Vycm9yQm91bmRhcnlgIHByb3BlcnR5IG9uIHRoZSByb3V0ZSBiYXNlZCBvbiB0aGUgcm91dGVcbiAgLy8gdXBkYXRlcyBhbmQgcmVtb3ZlIHRoZSBgbGF6eWAgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzb2x2ZSB0aGUgbGF6eVxuICAvLyByb3V0ZSBhZ2Fpbi5cbiAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCBfZXh0ZW5kcyh7fSwgbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlVG9VcGRhdGUpLCB7XG4gICAgbGF6eTogdW5kZWZpbmVkXG4gIH0pKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJPckFjdGlvbih0eXBlLCByZXF1ZXN0LCBtYXRjaCwgbWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgYmFzZW5hbWUsIHY3X3JlbGF0aXZlU3BsYXRQYXRoLCBvcHRzKSB7XG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0ge307XG4gIH1cbiAgbGV0IHJlc3VsdFR5cGU7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBvblJlamVjdDtcbiAgbGV0IHJ1bkhhbmRsZXIgPSBoYW5kbGVyID0+IHtcbiAgICAvLyBTZXR1cCBhIHByb21pc2Ugd2UgY2FuIHJhY2UgYWdhaW5zdCBzbyB0aGF0IGFib3J0IHNpZ25hbHMgc2hvcnQgY2lyY3VpdFxuICAgIGxldCByZWplY3Q7XG4gICAgbGV0IGFib3J0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByKSA9PiByZWplY3QgPSByKTtcbiAgICBvblJlamVjdCA9ICgpID0+IHJlamVjdCgpO1xuICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbaGFuZGxlcih7XG4gICAgICByZXF1ZXN0LFxuICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICBjb250ZXh0OiBvcHRzLnJlcXVlc3RDb250ZXh0XG4gICAgfSksIGFib3J0UHJvbWlzZV0pO1xuICB9O1xuICB0cnkge1xuICAgIGxldCBoYW5kbGVyID0gbWF0Y2gucm91dGVbdHlwZV07XG4gICAgaWYgKG1hdGNoLnJvdXRlLmxhenkpIHtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIC8vIFJ1biBzdGF0aWNhbGx5IGRlZmluZWQgaGFuZGxlciBpbiBwYXJhbGxlbCB3aXRoIGxhenkoKVxuICAgICAgICBsZXQgaGFuZGxlckVycm9yO1xuICAgICAgICBsZXQgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAvLyBJZiB0aGUgaGFuZGxlciB0aHJvd3MsIGRvbid0IGxldCBpdCBpbW1lZGlhdGVseSBidWJibGUgb3V0LFxuICAgICAgICAvLyBzaW5jZSB3ZSBuZWVkIHRvIGxldCB0aGUgbGF6eSgpIGV4ZWN1dGlvbiBmaW5pc2ggc28gd2Uga25vdyBpZiB0aGlzXG4gICAgICAgIC8vIHJvdXRlIGhhcyBhIGJvdW5kYXJ5IHRoYXQgY2FuIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgICAgcnVuSGFuZGxlcihoYW5kbGVyKS5jYXRjaChlID0+IHtcbiAgICAgICAgICBoYW5kbGVyRXJyb3IgPSBlO1xuICAgICAgICB9KSwgbG9hZExhenlSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCldKTtcbiAgICAgICAgaWYgKGhhbmRsZXJFcnJvcikge1xuICAgICAgICAgIHRocm93IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB2YWx1ZXNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMb2FkIGxhenkgcm91dGUgbW9kdWxlLCB0aGVuIHJ1biBhbnkgcmV0dXJuZWQgaGFuZGxlclxuICAgICAgICBhd2FpdCBsb2FkTGF6eVJvdXRlTW9kdWxlKG1hdGNoLnJvdXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMsIG1hbmlmZXN0KTtcbiAgICAgICAgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIC8vIEhhbmRsZXIgc3RpbGwgcnVuIGV2ZW4gaWYgd2UgZ290IGludGVycnVwdGVkIHRvIG1haW50YWluIGNvbnNpc3RlbmN5XG4gICAgICAgICAgLy8gd2l0aCB1bi1hYm9ydGFibGUgYmVoYXZpb3Igb2YgaGFuZGxlciBleGVjdXRpb24gb24gbm9uLWxhenkgb3JcbiAgICAgICAgICAvLyBwcmV2aW91c2x5LWxhenktbG9hZGVkIHJvdXRlc1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJ1bkhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJhY3Rpb25cIikge1xuICAgICAgICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICByb3V0ZUlkOiBtYXRjaC5yb3V0ZS5pZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxhenkoKSByb3V0ZSBoYXMgbm8gbG9hZGVyIHRvIHJ1bi4gIFNob3J0IGNpcmN1aXQgaGVyZSBzbyB3ZSBkb24ndFxuICAgICAgICAgIC8vIGhpdCB0aGUgaW52YXJpYW50IGJlbG93IHRoYXQgZXJyb3JzIG9uIHJldHVybmluZyB1bmRlZmluZWQuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQocmVzdWx0ICE9PSB1bmRlZmluZWQsIFwiWW91IGRlZmluZWQgXCIgKyAodHlwZSA9PT0gXCJhY3Rpb25cIiA/IFwiYW4gYWN0aW9uXCIgOiBcImEgbG9hZGVyXCIpICsgXCIgZm9yIHJvdXRlIFwiICsgKFwiXFxcIlwiICsgbWF0Y2gucm91dGUuaWQgKyBcIlxcXCIgYnV0IGRpZG4ndCByZXR1cm4gYW55dGhpbmcgZnJvbSB5b3VyIGBcIiArIHR5cGUgKyBcImAgXCIpICsgXCJmdW5jdGlvbi4gUGxlYXNlIHJldHVybiBhIHZhbHVlIG9yIGBudWxsYC5cIik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXN1bHRUeXBlID0gUmVzdWx0VHlwZS5lcnJvcjtcbiAgICByZXN1bHQgPSBlO1xuICB9IGZpbmFsbHkge1xuICAgIGlmIChvblJlamVjdCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uUmVqZWN0KTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIGxldCBzdGF0dXMgPSByZXN1bHQuc3RhdHVzO1xuICAgIC8vIFByb2Nlc3MgcmVkaXJlY3RzXG4gICAgaWYgKHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHN0YXR1cykpIHtcbiAgICAgIGxldCBsb2NhdGlvbiA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICAgICAgaW52YXJpYW50KGxvY2F0aW9uLCBcIlJlZGlyZWN0cyByZXR1cm5lZC90aHJvd24gZnJvbSBsb2FkZXJzL2FjdGlvbnMgbXVzdCBoYXZlIGEgTG9jYXRpb24gaGVhZGVyXCIpO1xuICAgICAgLy8gU3VwcG9ydCByZWxhdGl2ZSByb3V0aW5nIGluIGludGVybmFsIHJlZGlyZWN0c1xuICAgICAgaWYgKCFBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICAgICAgbG9jYXRpb24gPSBub3JtYWxpemVUbyhuZXcgVVJMKHJlcXVlc3QudXJsKSwgbWF0Y2hlcy5zbGljZSgwLCBtYXRjaGVzLmluZGV4T2YobWF0Y2gpICsgMSksIGJhc2VuYW1lLCB0cnVlLCBsb2NhdGlvbiwgdjdfcmVsYXRpdmVTcGxhdFBhdGgpO1xuICAgICAgfSBlbHNlIGlmICghb3B0cy5pc1N0YXRpY1JlcXVlc3QpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBwcm90b2NvbCtvcmlnaW4gZm9yIHNhbWUtb3JpZ2luICsgc2FtZS1iYXNlbmFtZSBhYnNvbHV0ZVxuICAgICAgICAvLyByZWRpcmVjdHMuIElmIHRoaXMgaXMgYSBzdGF0aWMgcmVxdWVzdCwgd2UgY2FuIGxldCBpdCBnbyBiYWNrIHRvIHRoZVxuICAgICAgICAvLyBicm93c2VyIGFzLWlzXG4gICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgIGxldCB1cmwgPSBsb2NhdGlvbi5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyBsb2NhdGlvbikgOiBuZXcgVVJMKGxvY2F0aW9uKTtcbiAgICAgICAgbGV0IGlzU2FtZUJhc2VuYW1lID0gc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSAhPSBudWxsO1xuICAgICAgICBpZiAodXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgaXNTYW1lQmFzZW5hbWUpIHtcbiAgICAgICAgICBsb2NhdGlvbiA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcHJvY2VzcyByZWRpcmVjdHMgaW4gdGhlIHJvdXRlciBkdXJpbmcgc3RhdGljIHJlcXVlc3RzIHJlcXVlc3RzLlxuICAgICAgLy8gSW5zdGVhZCwgdGhyb3cgdGhlIFJlc3BvbnNlIGFuZCBsZXQgdGhlIHNlcnZlciBoYW5kbGUgaXQgd2l0aCBhbiBIVFRQXG4gICAgICAvLyByZWRpcmVjdC4gIFdlIGFsc28gdXBkYXRlIHRoZSBMb2NhdGlvbiBoZWFkZXIgaW4gcGxhY2UgaW4gdGhpcyBmbG93IHNvXG4gICAgICAvLyBiYXNlbmFtZSBhbmQgcmVsYXRpdmUgcm91dGluZyBpcyB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgIGlmIChvcHRzLmlzU3RhdGljUmVxdWVzdCkge1xuICAgICAgICByZXN1bHQuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUucmVkaXJlY3QsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHJldmFsaWRhdGU6IHJlc3VsdC5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiKSAhPT0gbnVsbCxcbiAgICAgICAgcmVsb2FkRG9jdW1lbnQ6IHJlc3VsdC5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpICE9PSBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBGb3IgU1NSIHNpbmdsZS1yb3V0ZSByZXF1ZXN0cywgd2Ugd2FudCB0byBoYW5kIFJlc3BvbnNlcyBiYWNrIGRpcmVjdGx5XG4gICAgLy8gd2l0aG91dCB1bndyYXBwaW5nLiAgV2UgZG8gdGhpcyB3aXRoIHRoZSBRdWVyeVJvdXRlUmVzcG9uc2Ugd3JhcHBlclxuICAgIC8vIGludGVyZmFjZSBzbyB3ZSBjYW4ga25vdyB3aGV0aGVyIGl0IHdhcyByZXR1cm5lZCBvciB0aHJvd25cbiAgICBpZiAob3B0cy5pc1JvdXRlUmVxdWVzdCkge1xuICAgICAgbGV0IHF1ZXJ5Um91dGVSZXNwb25zZSA9IHtcbiAgICAgICAgdHlwZTogcmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvciA/IFJlc3VsdFR5cGUuZXJyb3IgOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgIHJlc3BvbnNlOiByZXN1bHRcbiAgICAgIH07XG4gICAgICB0aHJvdyBxdWVyeVJvdXRlUmVzcG9uc2U7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICAvLyBDaGVjayBiZXR3ZWVuIHdvcmQgYm91bmRhcmllcyBpbnN0ZWFkIG9mIHN0YXJ0c1dpdGgoKSBkdWUgdG8gdGhlIGxhc3RcbiAgICAgIC8vIHBhcmFncmFwaCBvZiBodHRwczovL2h0dHB3Zy5vcmcvc3BlY3MvcmZjOTExMC5odG1sI2ZpZWxkLmNvbnRlbnQtdHlwZVxuICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL2pzb25cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgIGlmIChyZXN1bHQuYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQudGV4dCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogcmVzdWx0VHlwZSxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlSW1wbChzdGF0dXMsIHJlc3VsdC5zdGF0dXNUZXh0LCBkYXRhKSxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICBkYXRhLFxuICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzXG4gICAgfTtcbiAgfVxuICBpZiAocmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiByZXN1bHRUeXBlLFxuICAgICAgZXJyb3I6IHJlc3VsdFxuICAgIH07XG4gIH1cbiAgaWYgKGlzRGVmZXJyZWREYXRhKHJlc3VsdCkpIHtcbiAgICB2YXIgX3Jlc3VsdCRpbml0LCBfcmVzdWx0JGluaXQyO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBSZXN1bHRUeXBlLmRlZmVycmVkLFxuICAgICAgZGVmZXJyZWREYXRhOiByZXN1bHQsXG4gICAgICBzdGF0dXNDb2RlOiAoX3Jlc3VsdCRpbml0ID0gcmVzdWx0LmluaXQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0JGluaXQuc3RhdHVzLFxuICAgICAgaGVhZGVyczogKChfcmVzdWx0JGluaXQyID0gcmVzdWx0LmluaXQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0JGluaXQyLmhlYWRlcnMpICYmIG5ldyBIZWFkZXJzKHJlc3VsdC5pbml0LmhlYWRlcnMpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICBkYXRhOiByZXN1bHRcbiAgfTtcbn1cbi8vIFV0aWxpdHkgbWV0aG9kIGZvciBjcmVhdGluZyB0aGUgUmVxdWVzdCBpbnN0YW5jZXMgZm9yIGxvYWRlcnMvYWN0aW9ucyBkdXJpbmdcbi8vIGNsaWVudC1zaWRlIG5hdmlnYXRpb25zIGFuZCBmZXRjaGVzLiAgRHVyaW5nIFNTUiB3ZSB3aWxsIGFsd2F5cyBoYXZlIGFcbi8vIFJlcXVlc3QgaW5zdGFuY2UgZnJvbSB0aGUgc3RhdGljIGhhbmRsZXIgKHF1ZXJ5L3F1ZXJ5Um91dGUpXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChoaXN0b3J5LCBsb2NhdGlvbiwgc2lnbmFsLCBzdWJtaXNzaW9uKSB7XG4gIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdHJpcEhhc2hGcm9tUGF0aChsb2NhdGlvbikpLnRvU3RyaW5nKCk7XG4gIGxldCBpbml0ID0ge1xuICAgIHNpZ25hbFxuICB9O1xuICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICBsZXQge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1FbmNUeXBlXG4gICAgfSA9IHN1Ym1pc3Npb247XG4gICAgLy8gRGlkbid0IHRoaW5rIHdlIG5lZWRlZCB0aGlzIGJ1dCBpdCB0dXJucyBvdXQgdW5saWtlIG90aGVyIG1ldGhvZHMsIHBhdGNoXG4gICAgLy8gd29uJ3QgYmUgcHJvcGVybHkgbm9ybWFsaXplZCB0byB1cHBlcmNhc2UgYW5kIHJlc3VsdHMgaW4gYSA0MDUgZXJyb3IuXG4gICAgLy8gU2VlOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tZXRob2RcbiAgICBpbml0Lm1ldGhvZCA9IGZvcm1NZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICBpbml0LmhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGZvcm1FbmNUeXBlXG4gICAgICB9KTtcbiAgICAgIGluaXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KHN1Ym1pc3Npb24uanNvbik7XG4gICAgfSBlbHNlIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi50ZXh0O1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgJiYgc3VibWlzc2lvbi5mb3JtRGF0YSkge1xuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXG4gICAgICBpbml0LmJvZHkgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhzdWJtaXNzaW9uLmZvcm1EYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGluZmVycmVkIChodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlcXVlc3QpXG4gICAgICBpbml0LmJvZHkgPSBzdWJtaXNzaW9uLmZvcm1EYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLCBpbml0KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKGZvcm1EYXRhKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpIHtcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3JtLWNvbnRyb2wtaW5mcmFzdHJ1Y3R1cmUuaHRtbCNjb252ZXJ0aW5nLWFuLWVudHJ5LWxpc3QtdG8tYS1saXN0LW9mLW5hbWUtdmFsdWUtcGFpcnNcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiB2YWx1ZS5uYW1lKTtcbiAgfVxuICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuZnVuY3Rpb24gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKSB7XG4gIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygc2VhcmNoUGFyYW1zLmVudHJpZXMoKSkge1xuICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZm9ybURhdGE7XG59XG5mdW5jdGlvbiBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJlc3VsdHMsIHBlbmRpbmdFcnJvciwgYWN0aXZlRGVmZXJyZWRzKSB7XG4gIC8vIEZpbGwgaW4gbG9hZGVyRGF0YS9lcnJvcnMgZnJvbSBvdXIgbG9hZGVyc1xuICBsZXQgbG9hZGVyRGF0YSA9IHt9O1xuICBsZXQgZXJyb3JzID0gbnVsbDtcbiAgbGV0IHN0YXR1c0NvZGU7XG4gIGxldCBmb3VuZEVycm9yID0gZmFsc2U7XG4gIGxldCBsb2FkZXJIZWFkZXJzID0ge307XG4gIC8vIFByb2Nlc3MgbG9hZGVyIHJlc3VsdHMgaW50byBzdGF0ZS5sb2FkZXJEYXRhL3N0YXRlLmVycm9yc1xuICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCwgaW5kZXgpID0+IHtcbiAgICBsZXQgaWQgPSBtYXRjaGVzVG9Mb2FkW2luZGV4XS5yb3V0ZS5pZDtcbiAgICBpbnZhcmlhbnQoIWlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSwgXCJDYW5ub3QgaGFuZGxlIHJlZGlyZWN0IHJlc3VsdHMgaW4gcHJvY2Vzc0xvYWRlckRhdGFcIik7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gTG9vayB1cHdhcmRzIGZyb20gdGhlIG1hdGNoZWQgcm91dGUgZm9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSwgZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaFxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGlkKTtcbiAgICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nIGFjdGlvbiBlcnJvciwgd2UgcmVwb3J0IGl0IGF0IHRoZSBoaWdoZXN0LXJvdXRlXG4gICAgICAvLyB0aGF0IHRocm93cyBhIGxvYWRlciBlcnJvciwgYW5kIHRoZW4gY2xlYXIgaXQgb3V0IHRvIGluZGljYXRlIHRoYXRcbiAgICAgIC8vIGl0IHdhcyBjb25zdW1lZFxuICAgICAgaWYgKHBlbmRpbmdFcnJvcikge1xuICAgICAgICBlcnJvciA9IE9iamVjdC52YWx1ZXMocGVuZGluZ0Vycm9yKVswXTtcbiAgICAgICAgcGVuZGluZ0Vycm9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IHt9O1xuICAgICAgLy8gUHJlZmVyIGhpZ2hlciBlcnJvciB2YWx1ZXMgaWYgbG93ZXIgZXJyb3JzIGJ1YmJsZSB0byB0aGUgc2FtZSBib3VuZGFyeVxuICAgICAgaWYgKGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYXIgb3VyIGFueSBwcmlvciBsb2FkZXJEYXRhIGZvciB0aGUgdGhyb3dpbmcgcm91dGVcbiAgICAgIGxvYWRlckRhdGFbaWRdID0gdW5kZWZpbmVkO1xuICAgICAgLy8gT25jZSB3ZSBmaW5kIG91ciBmaXJzdCAoaGlnaGVzdCkgZXJyb3IsIHdlIHNldCB0aGUgc3RhdHVzIGNvZGUgYW5kXG4gICAgICAvLyBwcmV2ZW50IGRlZXBlciBzdGF0dXMgY29kZXMgZnJvbSBvdmVycmlkaW5nXG4gICAgICBpZiAoIWZvdW5kRXJyb3IpIHtcbiAgICAgICAgZm91bmRFcnJvciA9IHRydWU7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIGFjdGl2ZURlZmVycmVkcy5zZXQoaWQsIHJlc3VsdC5kZWZlcnJlZERhdGEpO1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kZWZlcnJlZERhdGEuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRlckRhdGFbaWRdID0gcmVzdWx0LmRhdGE7XG4gICAgICB9XG4gICAgICAvLyBFcnJvciBzdGF0dXMgY29kZXMgYWx3YXlzIG92ZXJyaWRlIHN1Y2Nlc3Mgc3RhdHVzIGNvZGVzLCBidXQgaWYgYWxsXG4gICAgICAvLyBsb2FkZXJzIGFyZSBzdWNjZXNzZnVsIHdlIHRha2UgdGhlIGRlZXBlc3Qgc3RhdHVzIGNvZGUuXG4gICAgICBpZiAocmVzdWx0LnN0YXR1c0NvZGUgIT0gbnVsbCAmJiByZXN1bHQuc3RhdHVzQ29kZSAhPT0gMjAwICYmICFmb3VuZEVycm9yKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSByZXN1bHQuc3RhdHVzQ29kZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuaGVhZGVycykge1xuICAgICAgICBsb2FkZXJIZWFkZXJzW2lkXSA9IHJlc3VsdC5oZWFkZXJzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIC8vIElmIHdlIGRpZG4ndCBjb25zdW1lIHRoZSBwZW5kaW5nIGFjdGlvbiBlcnJvciAoaS5lLiwgYWxsIGxvYWRlcnNcbiAgLy8gcmVzb2x2ZWQpLCB0aGVuIGNvbnN1bWUgaXQgaGVyZS4gIEFsc28gY2xlYXIgb3V0IGFueSBsb2FkZXJEYXRhIGZvciB0aGVcbiAgLy8gdGhyb3dpbmcgcm91dGVcbiAgaWYgKHBlbmRpbmdFcnJvcikge1xuICAgIGVycm9ycyA9IHBlbmRpbmdFcnJvcjtcbiAgICBsb2FkZXJEYXRhW09iamVjdC5rZXlzKHBlbmRpbmdFcnJvcilbMF1dID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB7XG4gICAgbG9hZGVyRGF0YSxcbiAgICBlcnJvcnMsXG4gICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSB8fCAyMDAsXG4gICAgbG9hZGVySGVhZGVyc1xuICB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc0xvYWRlckRhdGEoc3RhdGUsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJlc3VsdHMsIHBlbmRpbmdFcnJvciwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsIGZldGNoZXJSZXN1bHRzLCBhY3RpdmVEZWZlcnJlZHMpIHtcbiAgbGV0IHtcbiAgICBsb2FkZXJEYXRhLFxuICAgIGVycm9yc1xuICB9ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBwZW5kaW5nRXJyb3IsIGFjdGl2ZURlZmVycmVkcyk7XG4gIC8vIFByb2Nlc3MgcmVzdWx0cyBmcm9tIG91ciByZXZhbGlkYXRpbmcgZmV0Y2hlcnNcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBtYXRjaCxcbiAgICAgIGNvbnRyb2xsZXJcbiAgICB9ID0gcmV2YWxpZGF0aW5nRmV0Y2hlcnNbaW5kZXhdO1xuICAgIGludmFyaWFudChmZXRjaGVyUmVzdWx0cyAhPT0gdW5kZWZpbmVkICYmIGZldGNoZXJSZXN1bHRzW2luZGV4XSAhPT0gdW5kZWZpbmVkLCBcIkRpZCBub3QgZmluZCBjb3JyZXNwb25kaW5nIGZldGNoZXIgcmVzdWx0XCIpO1xuICAgIGxldCByZXN1bHQgPSBmZXRjaGVyUmVzdWx0c1tpbmRleF07XG4gICAgLy8gUHJvY2VzcyBmZXRjaGVyIG5vbi1yZWRpcmVjdCBlcnJvcnNcbiAgICBpZiAoY29udHJvbGxlciAmJiBjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciBhYm9ydGVkIGZldGNoZXJzXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KHN0YXRlLm1hdGNoZXMsIG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBpZiAoIShlcnJvcnMgJiYgZXJyb3JzW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdKSkge1xuICAgICAgICBlcnJvcnMgPSBfZXh0ZW5kcyh7fSwgZXJyb3JzLCB7XG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2UgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgLy8gU2hvdWxkIG5ldmVyIGdldCBoZXJlLCByZWRpcmVjdHMgc2hvdWxkIGdldCBwcm9jZXNzZWQgYWJvdmUsIGJ1dCB3ZVxuICAgICAgLy8ga2VlcCB0aGlzIHRvIHR5cGUgbmFycm93IHRvIGEgc3VjY2VzcyByZXN1bHQgaW4gdGhlIGVsc2VcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciByZXZhbGlkYXRpb24gcmVkaXJlY3RcIik7XG4gICAgfSBlbHNlIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgZGVmZXJyZWQgZGF0YSBzaG91bGQgYmUgYXdhaXRlZCBmb3IgZmV0Y2hlcnNcbiAgICAgIC8vIGluIHJlc29sdmVEZWZlcnJlZFJlc3VsdHNcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciBkZWZlcnJlZCBkYXRhXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihyZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbG9hZGVyRGF0YSxcbiAgICBlcnJvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTG9hZGVyRGF0YShsb2FkZXJEYXRhLCBuZXdMb2FkZXJEYXRhLCBtYXRjaGVzLCBlcnJvcnMpIHtcbiAgbGV0IG1lcmdlZExvYWRlckRhdGEgPSBfZXh0ZW5kcyh7fSwgbmV3TG9hZGVyRGF0YSk7XG4gIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICBsZXQgaWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBpZiAobmV3TG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIGlmIChuZXdMb2FkZXJEYXRhW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1lcmdlZExvYWRlckRhdGFbaWRdID0gbmV3TG9hZGVyRGF0YVtpZF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2FkZXJEYXRhW2lkXSAhPT0gdW5kZWZpbmVkICYmIG1hdGNoLnJvdXRlLmxvYWRlcikge1xuICAgICAgLy8gUHJlc2VydmUgZXhpc3Rpbmcga2V5cyBub3QgaW5jbHVkZWQgaW4gbmV3TG9hZGVyRGF0YSBhbmQgd2hlcmUgYSBsb2FkZXJcbiAgICAgIC8vIHdhc24ndCByZW1vdmVkIGJ5IEhNUlxuICAgICAgbWVyZ2VkTG9hZGVyRGF0YVtpZF0gPSBsb2FkZXJEYXRhW2lkXTtcbiAgICB9XG4gICAgaWYgKGVycm9ycyAmJiBlcnJvcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAvLyBEb24ndCBrZWVwIGFueSBsb2FkZXIgZGF0YSBiZWxvdyB0aGUgYm91bmRhcnlcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkTG9hZGVyRGF0YTtcbn1cbi8vIEZpbmQgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnksIGxvb2tpbmcgdXB3YXJkcyBmcm9tIHRoZSBsZWFmIHJvdXRlIChvciB0aGVcbi8vIHJvdXRlIHNwZWNpZmllZCBieSByb3V0ZUlkKSBmb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgZXJyb3IgYm91bmRhcnksXG4vLyBkZWZhdWx0aW5nIHRvIHRoZSByb290IG1hdGNoXG5mdW5jdGlvbiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIHJvdXRlSWQpIHtcbiAgbGV0IGVsaWdpYmxlTWF0Y2hlcyA9IHJvdXRlSWQgPyBtYXRjaGVzLnNsaWNlKDAsIG1hdGNoZXMuZmluZEluZGV4KG0gPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgKyAxKSA6IFsuLi5tYXRjaGVzXTtcbiAgcmV0dXJuIGVsaWdpYmxlTWF0Y2hlcy5yZXZlcnNlKCkuZmluZChtID0+IG0ucm91dGUuaGFzRXJyb3JCb3VuZGFyeSA9PT0gdHJ1ZSkgfHwgbWF0Y2hlc1swXTtcbn1cbmZ1bmN0aW9uIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzKSB7XG4gIC8vIFByZWZlciBhIHJvb3QgbGF5b3V0IHJvdXRlIGlmIHByZXNlbnQsIG90aGVyd2lzZSBzaGltIGluIGEgcm91dGUgb2JqZWN0XG4gIGxldCByb3V0ZSA9IHJvdXRlcy5sZW5ndGggPT09IDEgPyByb3V0ZXNbMF0gOiByb3V0ZXMuZmluZChyID0+IHIuaW5kZXggfHwgIXIucGF0aCB8fCByLnBhdGggPT09IFwiL1wiKSB8fCB7XG4gICAgaWQ6IFwiX19zaGltLWVycm9yLXJvdXRlX19cIlxuICB9O1xuICByZXR1cm4ge1xuICAgIG1hdGNoZXM6IFt7XG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICBwYXRobmFtZUJhc2U6IFwiXCIsXG4gICAgICByb3V0ZVxuICAgIH1dLFxuICAgIHJvdXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKHN0YXR1cywgX3RlbXA1KSB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWUsXG4gICAgcm91dGVJZCxcbiAgICBtZXRob2QsXG4gICAgdHlwZVxuICB9ID0gX3RlbXA1ID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wNTtcbiAgbGV0IHN0YXR1c1RleHQgPSBcIlVua25vd24gU2VydmVyIEVycm9yXCI7XG4gIGxldCBlcnJvck1lc3NhZ2UgPSBcIlVua25vd24gQHJlbWl4LXJ1bi9yb3V0ZXIgZXJyb3JcIjtcbiAgaWYgKHN0YXR1cyA9PT0gNDAwKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiQmFkIFJlcXVlc3RcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiWW91IG1hZGUgYSBcIiArIG1ldGhvZCArIFwiIHJlcXVlc3QgdG8gXFxcIlwiICsgcGF0aG5hbWUgKyBcIlxcXCIgYnV0IFwiICsgKFwiZGlkIG5vdCBwcm92aWRlIGEgYGxvYWRlcmAgZm9yIHJvdXRlIFxcXCJcIiArIHJvdXRlSWQgKyBcIlxcXCIsIFwiKSArIFwic28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5cIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZGVmZXItYWN0aW9uXCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiZGVmZXIoKSBpcyBub3Qgc3VwcG9ydGVkIGluIGFjdGlvbnNcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaW52YWxpZC1ib2R5XCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiVW5hYmxlIHRvIGVuY29kZSBzdWJtaXNzaW9uIGJvZHlcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDMpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJGb3JiaWRkZW5cIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBcIlJvdXRlIFxcXCJcIiArIHJvdXRlSWQgKyBcIlxcXCIgZG9lcyBub3QgbWF0Y2ggVVJMIFxcXCJcIiArIHBhdGhuYW1lICsgXCJcXFwiXCI7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJOb3QgRm91bmRcIjtcbiAgICBlcnJvck1lc3NhZ2UgPSBcIk5vIHJvdXRlIG1hdGNoZXMgVVJMIFxcXCJcIiArIHBhdGhuYW1lICsgXCJcXFwiXCI7XG4gIH0gZWxzZSBpZiAoc3RhdHVzID09PSA0MDUpIHtcbiAgICBzdGF0dXNUZXh0ID0gXCJNZXRob2QgTm90IEFsbG93ZWRcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiWW91IG1hZGUgYSBcIiArIG1ldGhvZC50b1VwcGVyQ2FzZSgpICsgXCIgcmVxdWVzdCB0byBcXFwiXCIgKyBwYXRobmFtZSArIFwiXFxcIiBidXQgXCIgKyAoXCJkaWQgbm90IHByb3ZpZGUgYW4gYGFjdGlvbmAgZm9yIHJvdXRlIFxcXCJcIiArIHJvdXRlSWQgKyBcIlxcXCIsIFwiKSArIFwic28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5cIjtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gXCJJbnZhbGlkIHJlcXVlc3QgbWV0aG9kIFxcXCJcIiArIG1ldGhvZC50b1VwcGVyQ2FzZSgpICsgXCJcXFwiXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgRXJyb3JSZXNwb25zZUltcGwoc3RhdHVzIHx8IDUwMCwgc3RhdHVzVGV4dCwgbmV3IEVycm9yKGVycm9yTWVzc2FnZSksIHRydWUpO1xufVxuLy8gRmluZCBhbnkgcmV0dXJuZWQgcmVkaXJlY3QgZXJyb3JzLCBzdGFydGluZyBmcm9tIHRoZSBsb3dlc3QgbWF0Y2hcbmZ1bmN0aW9uIGZpbmRSZWRpcmVjdChyZXN1bHRzKSB7XG4gIGZvciAobGV0IGkgPSByZXN1bHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBpZHg6IGlcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0gdHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgocGF0aCkgOiBwYXRoO1xuICByZXR1cm4gY3JlYXRlUGF0aChfZXh0ZW5kcyh7fSwgcGFyc2VkUGF0aCwge1xuICAgIGhhc2g6IFwiXCJcbiAgfSkpO1xufVxuZnVuY3Rpb24gaXNIYXNoQ2hhbmdlT25seShhLCBiKSB7XG4gIGlmIChhLnBhdGhuYW1lICE9PSBiLnBhdGhuYW1lIHx8IGEuc2VhcmNoICE9PSBiLnNlYXJjaCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYS5oYXNoID09PSBcIlwiKSB7XG4gICAgLy8gL3BhZ2UgLT4gL3BhZ2UjaGFzaFxuICAgIHJldHVybiBiLmhhc2ggIT09IFwiXCI7XG4gIH0gZWxzZSBpZiAoYS5oYXNoID09PSBiLmhhc2gpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI2hhc2hcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChiLmhhc2ggIT09IFwiXCIpIHtcbiAgICAvLyAvcGFnZSNoYXNoIC0+IC9wYWdlI290aGVyXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSWYgdGhlIGhhc2ggaXMgcmVtb3ZlZCB0aGUgYnJvd3NlciB3aWxsIHJlLXBlcmZvcm0gYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXJcbiAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZGVmZXJyZWQ7XG59XG5mdW5jdGlvbiBpc0Vycm9yUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3I7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gKHJlc3VsdCAmJiByZXN1bHQudHlwZSkgPT09IFJlc3VsdFR5cGUucmVkaXJlY3Q7XG59XG5mdW5jdGlvbiBpc0RlZmVycmVkRGF0YSh2YWx1ZSkge1xuICBsZXQgZGVmZXJyZWQgPSB2YWx1ZTtcbiAgcmV0dXJuIGRlZmVycmVkICYmIHR5cGVvZiBkZWZlcnJlZCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGVmZXJyZWQuZGF0YSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGVmZXJyZWQuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGRlZmVycmVkLmNhbmNlbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZlcnJlZC5yZXNvbHZlRGF0YSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZS5oZWFkZXJzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3VsdCkge1xuICBpZiAoIWlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcbiAgbGV0IGxvY2F0aW9uID0gcmVzdWx0LmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIHJldHVybiBzdGF0dXMgPj0gMzAwICYmIHN0YXR1cyA8PSAzOTkgJiYgbG9jYXRpb24gIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzUXVlcnlSb3V0ZVJlc3BvbnNlKG9iaikge1xuICByZXR1cm4gb2JqICYmIGlzUmVzcG9uc2Uob2JqLnJlc3BvbnNlKSAmJiAob2JqLnR5cGUgPT09IFJlc3VsdFR5cGUuZGF0YSB8fCBvYmoudHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvcik7XG59XG5mdW5jdGlvbiBpc1ZhbGlkTWV0aG9kKG1ldGhvZCkge1xuICByZXR1cm4gdmFsaWRSZXF1ZXN0TWV0aG9kcy5oYXMobWV0aG9kLnRvTG93ZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbk1ldGhvZChtZXRob2QpIHtcbiAgcmV0dXJuIHZhbGlkTXV0YXRpb25NZXRob2RzLmhhcyhtZXRob2QudG9Mb3dlckNhc2UoKSk7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzKGN1cnJlbnRNYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBzaWduYWxzLCBpc0ZldGNoZXIsIGN1cnJlbnRMb2FkZXJEYXRhKSB7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXN1bHRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2luZGV4XTtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzVG9Mb2FkW2luZGV4XTtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgbWF0Y2gsIHRoZW4gd2UgY2FuIGhhdmUgYSBkZWZlcnJlZCByZXN1bHQgdG8gZG9cbiAgICAvLyBhbnl0aGluZyB3aXRoLiAgVGhpcyBpcyBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXJzIHdoZXJlIHRoZSByb3V0ZSB3YXNcbiAgICAvLyByZW1vdmVkIGR1cmluZyBITVJcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRNYXRjaCA9IGN1cnJlbnRNYXRjaGVzLmZpbmQobSA9PiBtLnJvdXRlLmlkID09PSBtYXRjaC5yb3V0ZS5pZCk7XG4gICAgbGV0IGlzUmV2YWxpZGF0aW5nTG9hZGVyID0gY3VycmVudE1hdGNoICE9IG51bGwgJiYgIWlzTmV3Um91dGVJbnN0YW5jZShjdXJyZW50TWF0Y2gsIG1hdGNoKSAmJiAoY3VycmVudExvYWRlckRhdGEgJiYgY3VycmVudExvYWRlckRhdGFbbWF0Y2gucm91dGUuaWRdKSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkgJiYgKGlzRmV0Y2hlciB8fCBpc1JldmFsaWRhdGluZ0xvYWRlcikpIHtcbiAgICAgIC8vIE5vdGU6IHdlIGRvIG5vdCBoYXZlIHRvIHRvdWNoIGFjdGl2ZURlZmVycmVkcyBoZXJlIHNpbmNlIHdlIHJhY2UgdGhlbVxuICAgICAgLy8gYWdhaW5zdCB0aGUgc2lnbmFsIGluIHJlc29sdmVEZWZlcnJlZERhdGEgYW5kIHRoZXknbGwgZ2V0IGFib3J0ZWRcbiAgICAgIC8vIHRoZXJlIGlmIG5lZWRlZFxuICAgICAgbGV0IHNpZ25hbCA9IHNpZ25hbHNbaW5kZXhdO1xuICAgICAgaW52YXJpYW50KHNpZ25hbCwgXCJFeHBlY3RlZCBhbiBBYm9ydFNpZ25hbCBmb3IgcmV2YWxpZGF0aW5nIGZldGNoZXIgZGVmZXJyZWQgcmVzdWx0XCIpO1xuICAgICAgYXdhaXQgcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIHNpZ25hbCwgaXNGZXRjaGVyKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHJlc3VsdCB8fCByZXN1bHRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgc2lnbmFsLCB1bndyYXApIHtcbiAgaWYgKHVud3JhcCA9PT0gdm9pZCAwKSB7XG4gICAgdW53cmFwID0gZmFsc2U7XG4gIH1cbiAgbGV0IGFib3J0ZWQgPSBhd2FpdCByZXN1bHQuZGVmZXJyZWREYXRhLnJlc29sdmVEYXRhKHNpZ25hbCk7XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh1bndyYXApIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgICAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLnVud3JhcHBlZERhdGFcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSGFuZGxlIGFueSBUcmFja2VkUHJvbWlzZS5fZXJyb3IgdmFsdWVzIGVuY291bnRlcmVkIHdoaWxlIHVud3JhcHBpbmdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICBkYXRhOiByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2gpIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKS5nZXRBbGwoXCJpbmRleFwiKS5zb21lKHYgPT4gdiA9PT0gXCJcIik7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbikge1xuICBsZXQgc2VhcmNoID0gdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uKS5zZWFyY2ggOiBsb2NhdGlvbi5zZWFyY2g7XG4gIGlmIChtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuaW5kZXggJiYgaGFzTmFrZWRJbmRleFF1ZXJ5KHNlYXJjaCB8fCBcIlwiKSkge1xuICAgIC8vIFJldHVybiB0aGUgbGVhZiBpbmRleCByb3V0ZSB3aGVuIGluZGV4IGlzIHByZXNlbnRcbiAgICByZXR1cm4gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8vIE90aGVyd2lzZSBncmFiIHRoZSBkZWVwZXN0IFwicGF0aCBjb250cmlidXRpbmdcIiBtYXRjaCAoaWdub3JpbmcgaW5kZXggYW5kXG4gIC8vIHBhdGhsZXNzIGxheW91dCByb3V0ZXMpXG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xuICByZXR1cm4gcGF0aE1hdGNoZXNbcGF0aE1hdGNoZXMubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24obmF2aWdhdGlvbikge1xuICBsZXQge1xuICAgIGZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZSxcbiAgICB0ZXh0LFxuICAgIGZvcm1EYXRhLFxuICAgIGpzb25cbiAgfSA9IG5hdmlnYXRpb247XG4gIGlmICghZm9ybU1ldGhvZCB8fCAhZm9ybUFjdGlvbiB8fCAhZm9ybUVuY1R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGZvcm1EYXRhICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSBlbHNlIGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICBqc29uLFxuICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgbmF2aWdhdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH0gZWxzZSB7XG4gICAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICByZXR1cm4gbmF2aWdhdGlvbjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VibWl0dGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pIHtcbiAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGxvY2F0aW9uLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dFxuICB9O1xuICByZXR1cm4gbmF2aWdhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGRhdGEpIHtcbiAgaWYgKHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgIGZvcm1FbmNUeXBlOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdW5kZWZpbmVkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlcikge1xuICBsZXQgZmV0Y2hlciA9IHtcbiAgICBzdGF0ZTogXCJzdWJtaXR0aW5nXCIsXG4gICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgIGRhdGE6IGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuZnVuY3Rpb24gZ2V0RG9uZUZldGNoZXIoZGF0YSkge1xuICBsZXQgZmV0Y2hlciA9IHtcbiAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgZm9ybU1ldGhvZDogdW5kZWZpbmVkLFxuICAgIGZvcm1BY3Rpb246IHVuZGVmaW5lZCxcbiAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAganNvbjogdW5kZWZpbmVkLFxuICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICBkYXRhXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuZnVuY3Rpb24gcmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyhfd2luZG93LCB0cmFuc2l0aW9ucykge1xuICB0cnkge1xuICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZKTtcbiAgICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgICAgbGV0IGpzb24gPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICAgICAgZm9yIChsZXQgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGpzb24gfHwge30pKSB7XG4gICAgICAgIGlmICh2ICYmIEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICB0cmFuc2l0aW9ucy5zZXQoaywgbmV3IFNldCh2IHx8IFtdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBuby1vcCwgdXNlIGRlZmF1bHQgZW1wdHkgb2JqZWN0XG4gIH1cbn1cbmZ1bmN0aW9uIHBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMoX3dpbmRvdywgdHJhbnNpdGlvbnMpIHtcbiAgaWYgKHRyYW5zaXRpb25zLnNpemUgPiAwKSB7XG4gICAgbGV0IGpzb24gPSB7fTtcbiAgICBmb3IgKGxldCBbaywgdl0gb2YgdHJhbnNpdGlvbnMpIHtcbiAgICAgIGpzb25ba10gPSBbLi4udl07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBfd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oVFJBTlNJVElPTlNfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGpzb24pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgd2FybmluZyhmYWxzZSwgXCJGYWlsZWQgdG8gc2F2ZSBhcHBsaWVkIHZpZXcgdHJhbnNpdGlvbnMgaW4gc2Vzc2lvblN0b3JhZ2UgKFwiICsgZXJyb3IgKyBcIikuXCIpO1xuICAgIH1cbiAgfVxufVxuLy8jZW5kcmVnaW9uXG5cbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBY3Rpb24sIElETEVfQkxPQ0tFUiwgSURMRV9GRVRDSEVSLCBJRExFX05BVklHQVRJT04sIFVOU0FGRV9ERUZFUlJFRF9TWU1CT0wsIERlZmVycmVkRGF0YSBhcyBVTlNBRkVfRGVmZXJyZWREYXRhLCBFcnJvclJlc3BvbnNlSW1wbCBhcyBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwsIGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIGFzIFVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCwgY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyBhcyBVTlNBRkVfY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcywgZ2V0UmVzb2x2ZVRvTWF0Y2hlcyBhcyBVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcywgaW52YXJpYW50IGFzIFVOU0FGRV9pbnZhcmlhbnQsIHdhcm5pbmcgYXMgVU5TQUZFX3dhcm5pbmcsIGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgY3JlYXRlUGF0aCwgY3JlYXRlUm91dGVyLCBjcmVhdGVTdGF0aWNIYW5kbGVyLCBkZWZlciwgZ2VuZXJhdGVQYXRoLCBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yLCBnZXRUb1BhdGhuYW1lLCBpc0RlZmVycmVkRGF0YSwgaXNSb3V0ZUVycm9yUmVzcG9uc2UsIGpvaW5QYXRocywganNvbiwgbWF0Y2hQYXRoLCBtYXRjaFJvdXRlcywgbm9ybWFsaXplUGF0aG5hbWUsIHBhcnNlUGF0aCwgcmVkaXJlY3QsIHJlZGlyZWN0RG9jdW1lbnQsIHJlc29sdmVQYXRoLCByZXNvbHZlVG8sIHN0cmlwQmFzZW5hbWUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJBY3Rpb24iLCJQb3BTdGF0ZUV2ZW50VHlwZSIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJvcHRpb25zIiwiaW5pdGlhbEVudHJpZXMiLCJpbml0aWFsSW5kZXgiLCJ2NUNvbXBhdCIsImVudHJpZXMiLCJtYXAiLCJlbnRyeSIsImluZGV4IiwiY3JlYXRlTWVtb3J5TG9jYXRpb24iLCJzdGF0ZSIsInVuZGVmaW5lZCIsImNsYW1wSW5kZXgiLCJhY3Rpb24iLCJQb3AiLCJsaXN0ZW5lciIsIm4iLCJNYXRoIiwibWluIiwibWF4IiwiZ2V0Q3VycmVudExvY2F0aW9uIiwidG8iLCJsb2NhdGlvbiIsImNyZWF0ZUxvY2F0aW9uIiwicGF0aG5hbWUiLCJ3YXJuaW5nIiwiY2hhckF0IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZUhyZWYiLCJjcmVhdGVQYXRoIiwiaGlzdG9yeSIsImNyZWF0ZVVSTCIsIlVSTCIsImVuY29kZUxvY2F0aW9uIiwicGF0aCIsInBhcnNlUGF0aCIsInNlYXJjaCIsImhhc2giLCJwdXNoIiwiUHVzaCIsIm5leHRMb2NhdGlvbiIsInNwbGljZSIsImRlbHRhIiwicmVwbGFjZSIsIlJlcGxhY2UiLCJnbyIsIm5leHRJbmRleCIsImxpc3RlbiIsImZuIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJjcmVhdGVCcm93c2VyTG9jYXRpb24iLCJ3aW5kb3ciLCJnbG9iYWxIaXN0b3J5IiwidXNyIiwiY3JlYXRlQnJvd3NlckhyZWYiLCJnZXRVcmxCYXNlZEhpc3RvcnkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsImNyZWF0ZUhhc2hMb2NhdGlvbiIsInN1YnN0ciIsInN0YXJ0c1dpdGgiLCJjcmVhdGVIYXNoSHJlZiIsImJhc2UiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmIiwiZ2V0QXR0cmlidXRlIiwidXJsIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwidmFsaWRhdGVIYXNoTG9jYXRpb24iLCJpbnZhcmlhbnQiLCJ2YWx1ZSIsIm1lc3NhZ2UiLCJFcnJvciIsImNvbmQiLCJjb25zb2xlIiwid2FybiIsImUiLCJjcmVhdGVLZXkiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEhpc3RvcnlTdGF0ZSIsImlkeCIsImN1cnJlbnQiLCJfcmVmIiwicGFyc2VkUGF0aCIsInNlYXJjaEluZGV4IiwiZ2V0TG9jYXRpb24iLCJ2YWxpZGF0ZUxvY2F0aW9uIiwiZGVmYXVsdFZpZXciLCJnZXRJbmRleCIsInJlcGxhY2VTdGF0ZSIsImhhbmRsZVBvcCIsImhpc3RvcnlTdGF0ZSIsInB1c2hTdGF0ZSIsImVycm9yIiwiRE9NRXhjZXB0aW9uIiwibmFtZSIsIm9yaWdpbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiUmVzdWx0VHlwZSIsImltbXV0YWJsZVJvdXRlS2V5cyIsIlNldCIsImlzSW5kZXhSb3V0ZSIsInJvdXRlIiwiY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyIsInJvdXRlcyIsIm1hcFJvdXRlUHJvcGVydGllcyIsInBhcmVudFBhdGgiLCJtYW5pZmVzdCIsInRyZWVQYXRoIiwiaWQiLCJqb2luIiwiY2hpbGRyZW4iLCJpbmRleFJvdXRlIiwicGF0aE9yTGF5b3V0Um91dGUiLCJtYXRjaFJvdXRlcyIsImxvY2F0aW9uQXJnIiwiYmFzZW5hbWUiLCJzdHJpcEJhc2VuYW1lIiwiYnJhbmNoZXMiLCJmbGF0dGVuUm91dGVzIiwicmFua1JvdXRlQnJhbmNoZXMiLCJtYXRjaGVzIiwibWF0Y2hSb3V0ZUJyYW5jaCIsInNhZmVseURlY29kZVVSSSIsImNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIiwibWF0Y2giLCJsb2FkZXJEYXRhIiwicGFyYW1zIiwiZGF0YSIsImhhbmRsZSIsInBhcmVudHNNZXRhIiwiZmxhdHRlblJvdXRlIiwicmVsYXRpdmVQYXRoIiwibWV0YSIsImNhc2VTZW5zaXRpdmUiLCJjaGlsZHJlbkluZGV4Iiwiam9pblBhdGhzIiwicm91dGVzTWV0YSIsImNvbmNhdCIsInNjb3JlIiwiY29tcHV0ZVNjb3JlIiwiZm9yRWFjaCIsIl9yb3V0ZSRwYXRoIiwiaW5jbHVkZXMiLCJleHBsb2RlZCIsImV4cGxvZGVPcHRpb25hbFNlZ21lbnRzIiwic2VnbWVudHMiLCJzcGxpdCIsImZpcnN0IiwicmVzdCIsImlzT3B0aW9uYWwiLCJlbmRzV2l0aCIsInJlcXVpcmVkIiwicmVzdEV4cGxvZGVkIiwicmVzdWx0Iiwic3VicGF0aCIsInNvcnQiLCJhIiwiYiIsImNvbXBhcmVJbmRleGVzIiwicGFyYW1SZSIsImR5bmFtaWNTZWdtZW50VmFsdWUiLCJpbmRleFJvdXRlVmFsdWUiLCJlbXB0eVNlZ21lbnRWYWx1ZSIsInN0YXRpY1NlZ21lbnRWYWx1ZSIsInNwbGF0UGVuYWx0eSIsImlzU3BsYXQiLCJzIiwiaW5pdGlhbFNjb3JlIiwic29tZSIsImZpbHRlciIsInJlZHVjZSIsInNlZ21lbnQiLCJ0ZXN0Iiwic2libGluZ3MiLCJldmVyeSIsImJyYW5jaCIsIm1hdGNoZWRQYXJhbXMiLCJtYXRjaGVkUGF0aG5hbWUiLCJlbmQiLCJyZW1haW5pbmdQYXRobmFtZSIsIm1hdGNoUGF0aCIsInBhdGhuYW1lQmFzZSIsIm5vcm1hbGl6ZVBhdGhuYW1lIiwiZ2VuZXJhdGVQYXRoIiwib3JpZ2luYWxQYXRoIiwicHJlZml4IiwicCIsIlN0cmluZyIsImFycmF5IiwiaXNMYXN0U2VnbWVudCIsInN0YXIiLCJrZXlNYXRjaCIsIm9wdGlvbmFsIiwicGFyYW0iLCJwYXR0ZXJuIiwibWF0Y2hlciIsImNvbXBpbGVkUGFyYW1zIiwiY29tcGlsZVBhdGgiLCJjYXB0dXJlR3JvdXBzIiwibWVtbyIsInBhcmFtTmFtZSIsInNwbGF0VmFsdWUiLCJzYWZlbHlEZWNvZGVVUklDb21wb25lbnQiLCJyZWdleHBTb3VyY2UiLCJfIiwiUmVnRXhwIiwiZGVjb2RlVVJJIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwidG9Mb3dlckNhc2UiLCJzdGFydEluZGV4IiwibmV4dENoYXIiLCJyZXNvbHZlUGF0aCIsImZyb21QYXRobmFtZSIsInRvUGF0aG5hbWUiLCJyZXNvbHZlUGF0aG5hbWUiLCJub3JtYWxpemVTZWFyY2giLCJub3JtYWxpemVIYXNoIiwicmVsYXRpdmVTZWdtZW50cyIsInBvcCIsImdldEludmFsaWRQYXRoRXJyb3IiLCJjaGFyIiwiZmllbGQiLCJkZXN0IiwiZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMiLCJnZXRSZXNvbHZlVG9NYXRjaGVzIiwidjdfcmVsYXRpdmVTcGxhdFBhdGgiLCJwYXRoTWF0Y2hlcyIsInJlc29sdmVUbyIsInRvQXJnIiwicm91dGVQYXRobmFtZXMiLCJsb2NhdGlvblBhdGhuYW1lIiwiaXNQYXRoUmVsYXRpdmUiLCJpc0VtcHR5UGF0aCIsImZyb20iLCJyb3V0ZVBhdGhuYW1lSW5kZXgiLCJ0b1NlZ21lbnRzIiwic2hpZnQiLCJoYXNFeHBsaWNpdFRyYWlsaW5nU2xhc2giLCJoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCIsImdldFRvUGF0aG5hbWUiLCJwYXRocyIsImpzb24iLCJpbml0IiwicmVzcG9uc2VJbml0Iiwic3RhdHVzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJoYXMiLCJzZXQiLCJSZXNwb25zZSIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiRGVmZXJyZWREYXRhIiwidHJhY2tQcm9taXNlIiwiUHJvbWlzZSIsImRlZmVycmVkS2V5cyIsInBlbmRpbmdLZXlzU2V0IiwiYWRkIiwicHJvbWlzZSIsInJhY2UiLCJhYm9ydFByb21pc2UiLCJ0aGVuIiwib25TZXR0bGUiLCJjYXRjaCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiY29udHJvbGxlciIsInNpZ25hbCIsImFib3J0ZWQiLCJ1bmxpc3RlbkFib3J0U2lnbmFsIiwicmVqZWN0IiwiZGVsZXRlIiwiZG9uZSIsInVuZGVmaW5lZEVycm9yIiwiZW1pdCIsInNldHRsZWRLZXkiLCJzdWJzY3JpYmVycyIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjYW5jZWwiLCJhYm9ydCIsInYiLCJrIiwicmVzb2x2ZURhdGEiLCJvbkFib3J0IiwicmVzb2x2ZSIsInNpemUiLCJ1bndyYXBwZWREYXRhIiwiYWNjIiwiX3JlZjMiLCJ1bndyYXBUcmFja2VkUHJvbWlzZSIsInBlbmRpbmdLZXlzIiwiQXJyYXkiLCJjb25zdHJ1Y3RvciIsImlzQXJyYXkiLCJyIiwiQWJvcnRDb250cm9sbGVyIiwiX3JlZjIiLCJpc1RyYWNrZWRQcm9taXNlIiwiX3RyYWNrZWQiLCJfZXJyb3IiLCJfZGF0YSIsImRlZmVyIiwicmVkaXJlY3QiLCJyZWRpcmVjdERvY3VtZW50IiwicmVzcG9uc2UiLCJFcnJvclJlc3BvbnNlSW1wbCIsInN0YXR1c1RleHQiLCJpbnRlcm5hbCIsImlzUm91dGVFcnJvclJlc3BvbnNlIiwidmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIiLCJ2YWxpZE11dGF0aW9uTWV0aG9kcyIsInZhbGlkUmVxdWVzdE1ldGhvZHNBcnIiLCJ2YWxpZFJlcXVlc3RNZXRob2RzIiwicmVkaXJlY3RTdGF0dXNDb2RlcyIsInJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyIsIklETEVfTkFWSUdBVElPTiIsImZvcm1NZXRob2QiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtRGF0YSIsInRleHQiLCJJRExFX0ZFVENIRVIiLCJJRExFX0JMT0NLRVIiLCJwcm9jZWVkIiwicmVzZXQiLCJBQlNPTFVURV9VUkxfUkVHRVgiLCJkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzIiwiaGFzRXJyb3JCb3VuZGFyeSIsIkJvb2xlYW4iLCJUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSIsImNyZWF0ZVJvdXRlciIsInJvdXRlcldpbmRvdyIsImlzQnJvd3NlciIsImNyZWF0ZUVsZW1lbnQiLCJpc1NlcnZlciIsImRldGVjdEVycm9yQm91bmRhcnkiLCJkYXRhUm91dGVzIiwiaW5GbGlnaHREYXRhUm91dGVzIiwiZnV0dXJlIiwidjdfZmV0Y2hlclBlcnNpc3QiLCJ2N19ub3JtYWxpemVGb3JtTWV0aG9kIiwidjdfcGFydGlhbEh5ZHJhdGlvbiIsInY3X3ByZXBlbmRCYXNlbmFtZSIsInVubGlzdGVuSGlzdG9yeSIsInNhdmVkU2Nyb2xsUG9zaXRpb25zIiwiZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkiLCJnZXRTY3JvbGxQb3NpdGlvbiIsImluaXRpYWxTY3JvbGxSZXN0b3JlZCIsImh5ZHJhdGlvbkRhdGEiLCJpbml0aWFsTWF0Y2hlcyIsImluaXRpYWxFcnJvcnMiLCJnZXRJbnRlcm5hbFJvdXRlckVycm9yIiwiZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyIsImluaXRpYWxpemVkIiwiaGFzTGF6eVJvdXRlcyIsIm0iLCJsYXp5IiwiaGFzTG9hZGVycyIsImxvYWRlciIsImVycm9ycyIsImh5ZHJhdGUiLCJyb3V0ZXIiLCJoaXN0b3J5QWN0aW9uIiwibmF2aWdhdGlvbiIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsInByZXZlbnRTY3JvbGxSZXNldCIsInJldmFsaWRhdGlvbiIsImFjdGlvbkRhdGEiLCJmZXRjaGVycyIsIk1hcCIsImJsb2NrZXJzIiwicGVuZGluZ0FjdGlvbiIsInBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQiLCJwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIiLCJwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkIiwiYXBwbGllZFZpZXdUcmFuc2l0aW9ucyIsInJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lciIsImlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsImlzUmV2YWxpZGF0aW9uUmVxdWlyZWQiLCJjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyIsImNhbmNlbGxlZEZldGNoZXJMb2FkcyIsImZldGNoQ29udHJvbGxlcnMiLCJpbmNyZW1lbnRpbmdMb2FkSWQiLCJwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCIsImZldGNoUmVsb2FkSWRzIiwiZmV0Y2hSZWRpcmVjdElkcyIsImZldGNoTG9hZE1hdGNoZXMiLCJhY3RpdmVGZXRjaGVycyIsImRlbGV0ZWRGZXRjaGVycyIsImFjdGl2ZURlZmVycmVkcyIsImJsb2NrZXJGdW5jdGlvbnMiLCJpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSIsImluaXRpYWxpemUiLCJibG9ja2VyS2V5Iiwic2hvdWxkQmxvY2tOYXZpZ2F0aW9uIiwiY3VycmVudExvY2F0aW9uIiwidXBkYXRlQmxvY2tlciIsInVwZGF0ZVN0YXRlIiwic3RhcnROYXZpZ2F0aW9uIiwicmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyIsIl9zYXZlQXBwbGllZFRyYW5zaXRpb25zIiwicGVyc2lzdEFwcGxpZWRUcmFuc2l0aW9ucyIsImluaXRpYWxIeWRyYXRpb24iLCJkaXNwb3NlIiwiY2xlYXIiLCJkZWxldGVGZXRjaGVyIiwiZGVsZXRlQmxvY2tlciIsIm5ld1N0YXRlIiwib3B0cyIsImNvbXBsZXRlZEZldGNoZXJzIiwiZGVsZXRlZEZldGNoZXJzS2V5cyIsImZldGNoZXIiLCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvbk9wdHMiLCJ2aWV3VHJhbnNpdGlvbk9wdHMiLCJ1bnN0YWJsZV9mbHVzaFN5bmMiLCJmbHVzaFN5bmMiLCJjb21wbGV0ZU5hdmlnYXRpb24iLCJfdGVtcCIsIl9sb2NhdGlvbiRzdGF0ZSIsIl9sb2NhdGlvbiRzdGF0ZTIiLCJpc0FjdGlvblJlbG9hZCIsImlzTXV0YXRpb25NZXRob2QiLCJfaXNSZWRpcmVjdCIsImtleXMiLCJtZXJnZUxvYWRlckRhdGEiLCJwcmlvclBhdGhzIiwidG9QYXRocyIsImdldFNhdmVkU2Nyb2xsUG9zaXRpb24iLCJuYXZpZ2F0ZSIsIm5vcm1hbGl6ZWRQYXRoIiwibm9ybWFsaXplVG8iLCJmcm9tUm91dGVJZCIsInJlbGF0aXZlIiwic3VibWlzc2lvbiIsIm5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyIsInVzZXJSZXBsYWNlIiwicGVuZGluZ0Vycm9yIiwiZW5hYmxlVmlld1RyYW5zaXRpb24iLCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvbiIsInJldmFsaWRhdGUiLCJpbnRlcnJ1cHRBY3RpdmVMb2FkcyIsInN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsIm92ZXJyaWRlTmF2aWdhdGlvbiIsInNhdmVTY3JvbGxQb3NpdGlvbiIsInJvdXRlc1RvVXNlIiwibG9hZGluZ05hdmlnYXRpb24iLCJub3RGb3VuZE1hdGNoZXMiLCJjYW5jZWxBY3RpdmVEZWZlcnJlZHMiLCJpc0hhc2hDaGFuZ2VPbmx5IiwicmVxdWVzdCIsImNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0IiwicGVuZGluZ0FjdGlvbkRhdGEiLCJmaW5kTmVhcmVzdEJvdW5kYXJ5IiwiYWN0aW9uT3V0cHV0IiwiaGFuZGxlQWN0aW9uIiwic2hvcnRDaXJjdWl0ZWQiLCJwZW5kaW5nQWN0aW9uRXJyb3IiLCJnZXRMb2FkaW5nTmF2aWdhdGlvbiIsIlJlcXVlc3QiLCJoYW5kbGVMb2FkZXJzIiwiZmV0Y2hlclN1Ym1pc3Npb24iLCJnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbiIsImFjdGlvbk1hdGNoIiwiZ2V0VGFyZ2V0TWF0Y2giLCJ0eXBlIiwibWV0aG9kIiwicm91dGVJZCIsImNhbGxMb2FkZXJPckFjdGlvbiIsImlzUmVkaXJlY3RSZXN1bHQiLCJzdGFydFJlZGlyZWN0TmF2aWdhdGlvbiIsImlzRXJyb3JSZXN1bHQiLCJib3VuZGFyeU1hdGNoIiwiaXNEZWZlcnJlZFJlc3VsdCIsImFjdGl2ZVN1Ym1pc3Npb24iLCJnZXRTdWJtaXNzaW9uRnJvbU5hdmlnYXRpb24iLCJtYXRjaGVzVG9Mb2FkIiwicmV2YWxpZGF0aW5nRmV0Y2hlcnMiLCJnZXRNYXRjaGVzVG9Mb2FkIiwidXBkYXRlZEZldGNoZXJzIiwibWFya0ZldGNoUmVkaXJlY3RzRG9uZSIsInJmIiwicmV2YWxpZGF0aW5nRmV0Y2hlciIsImdldExvYWRpbmdGZXRjaGVyIiwiYWJvcnRGZXRjaGVyIiwiYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zIiwiZiIsInJlc3VsdHMiLCJsb2FkZXJSZXN1bHRzIiwiZmV0Y2hlclJlc3VsdHMiLCJjYWxsTG9hZGVyc0FuZE1heWJlUmVzb2x2ZURhdGEiLCJmaW5kUmVkaXJlY3QiLCJmZXRjaGVyS2V5IiwicHJvY2Vzc0xvYWRlckRhdGEiLCJkZWZlcnJlZERhdGEiLCJkaWRBYm9ydEZldGNoTG9hZHMiLCJhYm9ydFN0YWxlRmV0Y2hMb2FkcyIsInNob3VsZFVwZGF0ZUZldGNoZXJzIiwiZmV0Y2giLCJzZXRGZXRjaGVyRXJyb3IiLCJoYW5kbGVGZXRjaGVyQWN0aW9uIiwiaGFuZGxlRmV0Y2hlckxvYWRlciIsInJlcXVlc3RNYXRjaGVzIiwiZXhpc3RpbmdGZXRjaGVyIiwidXBkYXRlRmV0Y2hlclN0YXRlIiwiZ2V0U3VibWl0dGluZ0ZldGNoZXIiLCJhYm9ydENvbnRyb2xsZXIiLCJmZXRjaFJlcXVlc3QiLCJvcmlnaW5hdGluZ0xvYWRJZCIsImFjdGlvblJlc3VsdCIsImdldERvbmVGZXRjaGVyIiwicmV2YWxpZGF0aW9uUmVxdWVzdCIsImxvYWRJZCIsImxvYWRGZXRjaGVyIiwic3RhbGVLZXkiLCJkb25lRmV0Y2hlciIsInJlc29sdmVEZWZlcnJlZERhdGEiLCJfdGVtcDIiLCJyZWRpcmVjdExvY2F0aW9uIiwiaXNEb2N1bWVudFJlbG9hZCIsInJlbG9hZERvY3VtZW50IiwicmVkaXJlY3RIaXN0b3J5QWN0aW9uIiwiY3VycmVudE1hdGNoZXMiLCJmZXRjaGVyc1RvTG9hZCIsImFsbCIsInJlc29sdmVEZWZlcnJlZFJlc3VsdHMiLCJnZXRGZXRjaGVyIiwiZGVsZXRlRmV0Y2hlckFuZFVwZGF0ZVN0YXRlIiwiY291bnQiLCJtYXJrRmV0Y2hlcnNEb25lIiwiZG9uZUtleXMiLCJsYW5kZWRJZCIsInllZXRlZEtleXMiLCJnZXRCbG9ja2VyIiwiYmxvY2tlciIsIm5ld0Jsb2NrZXIiLCJibG9ja2VyRnVuY3Rpb24iLCJwcmVkaWNhdGUiLCJjYW5jZWxsZWRSb3V0ZUlkcyIsImRmZCIsImVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uIiwicG9zaXRpb25zIiwiZ2V0UG9zaXRpb24iLCJnZXRLZXkiLCJ5IiwiZ2V0U2Nyb2xsS2V5IiwiX2ludGVybmFsU2V0Um91dGVzIiwibmV3Um91dGVzIiwiX2ludGVybmFsRmV0Y2hDb250cm9sbGVycyIsIl9pbnRlcm5hbEFjdGl2ZURlZmVycmVkcyIsIlVOU0FGRV9ERUZFUlJFRF9TWU1CT0wiLCJTeW1ib2wiLCJjcmVhdGVTdGF0aWNIYW5kbGVyIiwicXVlcnkiLCJfdGVtcDMiLCJyZXF1ZXN0Q29udGV4dCIsImlzVmFsaWRNZXRob2QiLCJtZXRob2ROb3RBbGxvd2VkTWF0Y2hlcyIsInN0YXR1c0NvZGUiLCJsb2FkZXJIZWFkZXJzIiwiYWN0aW9uSGVhZGVycyIsInF1ZXJ5SW1wbCIsImlzUmVzcG9uc2UiLCJxdWVyeVJvdXRlIiwiX3RlbXA0IiwiZmluZCIsInZhbHVlcyIsIl9yZXN1bHQkYWN0aXZlRGVmZXJyZSIsInJvdXRlTWF0Y2giLCJzdWJtaXQiLCJsb2FkUm91dGVEYXRhIiwiaXNRdWVyeVJvdXRlUmVzcG9uc2UiLCJpc1JlZGlyZWN0UmVzcG9uc2UiLCJpc1JvdXRlUmVxdWVzdCIsImlzU3RhdGljUmVxdWVzdCIsIkxvY2F0aW9uIiwiY29udGV4dCIsImxvYWRlclJlcXVlc3QiLCJnZXRMb2FkZXJNYXRjaGVzVW50aWxCb3VuZGFyeSIsInByb2Nlc3NSb3V0ZUxvYWRlckRhdGEiLCJleGVjdXRlZExvYWRlcnMiLCJmcm9tRW50cmllcyIsImdldFN0YXRpY0NvbnRleHRGcm9tRXJyb3IiLCJuZXdDb250ZXh0IiwiX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQiLCJpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uIiwiYm9keSIsInByZXBlbmRCYXNlbmFtZSIsImNvbnRleHR1YWxNYXRjaGVzIiwiYWN0aXZlUm91dGVNYXRjaCIsImhhc05ha2VkSW5kZXhRdWVyeSIsIm5vcm1hbGl6ZUZvcm1NZXRob2QiLCJpc0ZldGNoZXIiLCJnZXRJbnZhbGlkQm9keUVycm9yIiwicmF3Rm9ybU1ldGhvZCIsInRvVXBwZXJDYXNlIiwic3RyaXBIYXNoRnJvbVBhdGgiLCJGb3JtRGF0YSIsIlVSTFNlYXJjaFBhcmFtcyIsInBhcnNlIiwic2VhcmNoUGFyYW1zIiwiY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMiLCJjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YSIsImFwcGVuZCIsImJvdW5kYXJ5SWQiLCJib3VuZGFyeU1hdGNoZXMiLCJmaW5kSW5kZXgiLCJpc0luaXRpYWxMb2FkIiwiY3VycmVudFVybCIsIm5leHRVcmwiLCJuYXZpZ2F0aW9uTWF0Y2hlcyIsImlzTmV3TG9hZGVyIiwiY3VycmVudFJvdXRlTWF0Y2giLCJuZXh0Um91dGVNYXRjaCIsInNob3VsZFJldmFsaWRhdGVMb2FkZXIiLCJjdXJyZW50UGFyYW1zIiwibmV4dFBhcmFtcyIsImRlZmF1bHRTaG91bGRSZXZhbGlkYXRlIiwiaXNOZXdSb3V0ZUluc3RhbmNlIiwiZmV0Y2hlck1hdGNoZXMiLCJmZXRjaGVyTWF0Y2giLCJzaG91bGRSZXZhbGlkYXRlIiwiY3VycmVudExvYWRlckRhdGEiLCJjdXJyZW50TWF0Y2giLCJpc05ldyIsImlzTWlzc2luZ0RhdGEiLCJjdXJyZW50UGF0aCIsImxvYWRlck1hdGNoIiwiYXJnIiwicm91dGVDaG9pY2UiLCJsb2FkTGF6eVJvdXRlTW9kdWxlIiwibGF6eVJvdXRlIiwicm91dGVUb1VwZGF0ZSIsInJvdXRlVXBkYXRlcyIsImxhenlSb3V0ZVByb3BlcnR5Iiwic3RhdGljUm91dGVWYWx1ZSIsImlzUHJvcGVydHlTdGF0aWNhbGx5RGVmaW5lZCIsInJlc3VsdFR5cGUiLCJvblJlamVjdCIsInJ1bkhhbmRsZXIiLCJoYW5kbGVyIiwiaGFuZGxlckVycm9yIiwicHJvdG9jb2wiLCJpc1NhbWVCYXNlbmFtZSIsInF1ZXJ5Um91dGVSZXNwb25zZSIsImNvbnRlbnRUeXBlIiwiaXNEZWZlcnJlZERhdGEiLCJfcmVzdWx0JGluaXQiLCJfcmVzdWx0JGluaXQyIiwiZGVmZXJyZWQiLCJmb3VuZEVycm9yIiwibmV3TG9hZGVyRGF0YSIsIm1lcmdlZExvYWRlckRhdGEiLCJlbGlnaWJsZU1hdGNoZXMiLCJyZXZlcnNlIiwiX3RlbXA1IiwiZXJyb3JNZXNzYWdlIiwib2JqIiwic2lnbmFscyIsImlzUmV2YWxpZGF0aW5nTG9hZGVyIiwidW53cmFwIiwiZ2V0QWxsIiwiX3dpbmRvdyIsInRyYW5zaXRpb25zIiwic2Vzc2lvblBvc2l0aW9ucyIsInNlc3Npb25TdG9yYWdlIiwiZ2V0SXRlbSIsInNldEl0ZW0iLCJVTlNBRkVfRGVmZXJyZWREYXRhIiwiVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsIiwiVU5TQUZFX2NvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIiwiVU5TQUZFX2NvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMiLCJVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcyIsIlVOU0FGRV9pbnZhcmlhbnQiLCJVTlNBRkVfd2FybmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@remix-run/router/dist/router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-router/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-router/dist/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError; },\n/* harmony export */   Await: function() { return /* binding */ Await; },\n/* harmony export */   MemoryRouter: function() { return /* binding */ MemoryRouter; },\n/* harmony export */   Navigate: function() { return /* binding */ Navigate; },\n/* harmony export */   NavigationType: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action; },\n/* harmony export */   Outlet: function() { return /* binding */ Outlet; },\n/* harmony export */   Route: function() { return /* binding */ Route; },\n/* harmony export */   Router: function() { return /* binding */ Router; },\n/* harmony export */   RouterProvider: function() { return /* binding */ RouterProvider; },\n/* harmony export */   Routes: function() { return /* binding */ Routes; },\n/* harmony export */   UNSAFE_DataRouterContext: function() { return /* binding */ DataRouterContext; },\n/* harmony export */   UNSAFE_DataRouterStateContext: function() { return /* binding */ DataRouterStateContext; },\n/* harmony export */   UNSAFE_LocationContext: function() { return /* binding */ LocationContext; },\n/* harmony export */   UNSAFE_NavigationContext: function() { return /* binding */ NavigationContext; },\n/* harmony export */   UNSAFE_RouteContext: function() { return /* binding */ RouteContext; },\n/* harmony export */   UNSAFE_mapRouteProperties: function() { return /* binding */ mapRouteProperties; },\n/* harmony export */   UNSAFE_useRouteId: function() { return /* binding */ useRouteId; },\n/* harmony export */   UNSAFE_useRoutesImpl: function() { return /* binding */ useRoutesImpl; },\n/* harmony export */   createMemoryRouter: function() { return /* binding */ createMemoryRouter; },\n/* harmony export */   createPath: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createPath; },\n/* harmony export */   createRoutesFromChildren: function() { return /* binding */ createRoutesFromChildren; },\n/* harmony export */   createRoutesFromElements: function() { return /* binding */ createRoutesFromChildren; },\n/* harmony export */   defer: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.defer; },\n/* harmony export */   generatePath: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.generatePath; },\n/* harmony export */   isRouteErrorResponse: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse; },\n/* harmony export */   json: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.json; },\n/* harmony export */   matchPath: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath; },\n/* harmony export */   matchRoutes: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes; },\n/* harmony export */   parsePath: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath; },\n/* harmony export */   redirect: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirect; },\n/* harmony export */   redirectDocument: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirectDocument; },\n/* harmony export */   renderMatches: function() { return /* binding */ renderMatches; },\n/* harmony export */   resolvePath: function() { return /* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath; },\n/* harmony export */   useActionData: function() { return /* binding */ useActionData; },\n/* harmony export */   useAsyncError: function() { return /* binding */ useAsyncError; },\n/* harmony export */   useAsyncValue: function() { return /* binding */ useAsyncValue; },\n/* harmony export */   useBlocker: function() { return /* binding */ useBlocker; },\n/* harmony export */   useHref: function() { return /* binding */ useHref; },\n/* harmony export */   useInRouterContext: function() { return /* binding */ useInRouterContext; },\n/* harmony export */   useLoaderData: function() { return /* binding */ useLoaderData; },\n/* harmony export */   useLocation: function() { return /* binding */ useLocation; },\n/* harmony export */   useMatch: function() { return /* binding */ useMatch; },\n/* harmony export */   useMatches: function() { return /* binding */ useMatches; },\n/* harmony export */   useNavigate: function() { return /* binding */ useNavigate; },\n/* harmony export */   useNavigation: function() { return /* binding */ useNavigation; },\n/* harmony export */   useNavigationType: function() { return /* binding */ useNavigationType; },\n/* harmony export */   useOutlet: function() { return /* binding */ useOutlet; },\n/* harmony export */   useOutletContext: function() { return /* binding */ useOutletContext; },\n/* harmony export */   useParams: function() { return /* binding */ useParams; },\n/* harmony export */   useResolvedPath: function() { return /* binding */ useResolvedPath; },\n/* harmony export */   useRevalidator: function() { return /* binding */ useRevalidator; },\n/* harmony export */   useRouteError: function() { return /* binding */ useRouteError; },\n/* harmony export */   useRouteLoaderData: function() { return /* binding */ useRouteLoaderData; },\n/* harmony export */   useRoutes: function() { return /* binding */ useRoutes; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ \"(app-pages-browser)/./node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router v6.21.3\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ var _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$(), _s9 = $RefreshSig$(), _s10 = $RefreshSig$(), _s11 = $RefreshSig$(), _s12 = $RefreshSig$(), _s13 = $RefreshSig$(), _s14 = $RefreshSig$(), _s15 = $RefreshSig$(), _s16 = $RefreshSig$(), _s17 = $RefreshSig$(), _s18 = $RefreshSig$(), _s19 = $RefreshSig$(), _s20 = $RefreshSig$(), _s21 = $RefreshSig$(), _s22 = $RefreshSig$(), _s23 = $RefreshSig$(), _s24 = $RefreshSig$(), _s25 = $RefreshSig$(), _s26 = $RefreshSig$(), _s27 = $RefreshSig$(), _s28 = $RefreshSig$(), _s29 = $RefreshSig$(), _s30 = $RefreshSig$(), _s31 = $RefreshSig$(), _s32 = $RefreshSig$(), _s33 = $RefreshSig$(), _s34 = $RefreshSig$(), _s35 = $RefreshSig$(), _s36 = $RefreshSig$(), _s37 = $RefreshSig$(), _s38 = $RefreshSig$(), _s39 = $RefreshSig$();\n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst DataRouterContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    DataRouterContext.displayName = \"DataRouter\";\n}\nconst DataRouterStateContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    DataRouterStateContext.displayName = \"DataRouterState\";\n}\nconst AwaitContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    AwaitContext.displayName = \"Await\";\n}\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level `<Router>` API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */ const NavigationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    NavigationContext.displayName = \"Navigation\";\n}\nconst LocationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    LocationContext.displayName = \"Location\";\n}\nconst RouteContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n});\nif (true) {\n    RouteContext.displayName = \"Route\";\n}\nconst RouteErrorContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    RouteErrorContext.displayName = \"RouteError\";\n}\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */ function useHref(to, _temp) {\n    _s();\n    let { relative } = _temp === void 0 ? {} : _temp;\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { basename, navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { hash, pathname, search } = useResolvedPath(to, {\n        relative\n    });\n    let joinedPathname = pathname;\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the href.  If this is a root navigation, then just use the raw\n    // basename which allows the basename to have full control over the presence\n    // of a trailing slash on root links\n    if (basename !== \"/\") {\n        joinedPathname = pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n            basename,\n            pathname\n        ]);\n    }\n    return navigator.createHref({\n        pathname: joinedPathname,\n        search,\n        hash\n    });\n}\n_s(useHref, \"rGGf6evAqoN3mWGkxXhzdvQMWyw=\", false, function() {\n    return [\n        useInRouterContext,\n        useResolvedPath\n    ];\n});\n/**\n * Returns true if this component is a descendant of a `<Router>`.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */ function useInRouterContext() {\n    _s1();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;\n}\n_s1(useInRouterContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */ function useLocation() {\n    _s2();\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;\n}\n_s2(useLocation, \"pnBsrBzOSKrTAsifUkfhXR0cM+Y=\", false, function() {\n    return [\n        useInRouterContext\n    ];\n});\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */ function useNavigationType() {\n    _s3();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).navigationType;\n}\n_s3(useNavigationType, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * `<NavLink>`.\n *\n * @see https://reactrouter.com/hooks/use-match\n */ function useMatch(pattern) {\n    _s4();\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { pathname } = useLocation();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath)(pattern, pathname), [\n        pathname,\n        pattern\n    ]);\n}\n_s4(useMatch, \"nQeQy8ml7gNYO2EbpP3HWNGpSDs=\", false, function() {\n    return [\n        useInRouterContext,\n        useLocation\n    ];\n});\n/**\n * The interface for the navigate() function returned from useNavigate().\n */ const navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n    _s5();\n    let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;\n    if (!isStatic) {\n        // We should be able to get rid of this once react 18.3 is released\n        // See: https://github.com/facebook/react/pull/26395\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);\n    }\n}\n_s5(useIsomorphicLayoutEffect, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/**\n * Returns an imperative method for changing the location. Used by `<Link>`s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */ function useNavigate() {\n    _s6();\n    let { isDataRoute } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\n_s6(useNavigate, \"3i7MQnPpiPAGSiIiwm8rZLKRF8w=\", false, function() {\n    return [\n        useNavigateStable,\n        useNavigateUnstable\n    ];\n});\nfunction useNavigateUnstable() {\n    _s7();\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    let { basename, future, navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\n    let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\n        // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our history listener yet\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            navigator.go(to);\n            return;\n        }\n        let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n        // If we're operating within a basename, prepend it to the pathname prior\n        // to handing off to history (but only if we're not in a data router,\n        // otherwise it'll prepend the basename inside of the router).\n        // If this is a root navigation, then we navigate to the raw basename\n        // which allows the basename to have full control over the presence of a\n        // trailing slash on root links\n        if (dataRouterContext == null && basename !== \"/\") {\n            path.pathname = path.pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                basename,\n                path.pathname\n            ]);\n        }\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [\n        basename,\n        navigator,\n        routePathnamesJson,\n        locationPathname,\n        dataRouterContext\n    ]);\n    return navigate;\n}\n_s7(useNavigateUnstable, \"tUQDCcinF6M4+U0yp9u8DvP9joE=\", false, function() {\n    return [\n        useInRouterContext,\n        useLocation,\n        useIsomorphicLayoutEffect\n    ];\n});\nconst OutletContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */ function useOutletContext() {\n    _s8();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(OutletContext);\n}\n_s8(useOutletContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by `<Outlet>` to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */ function useOutlet(context) {\n    _s9();\n    let outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;\n    if (outlet) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, {\n            value: context\n        }, outlet);\n    }\n    return outlet;\n}\n_s9(useOutlet, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */ function useParams() {\n    _s10();\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n}\n_s10(useParams, \"KZfdG8ZL0oSOy0/P9JYAG6JDDJw=\");\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */ function useResolvedPath(to, _temp2) {\n    _s11();\n    let { relative } = _temp2 === void 0 ? {} : _temp2;\n    let { future } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath));\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [\n        to,\n        routePathnamesJson,\n        locationPathname,\n        relative\n    ]);\n}\n_s11(useResolvedPath, \"wVXBIr+VW78mZc8lDu4RuR6aKjE=\", false, function() {\n    return [\n        useLocation\n    ];\n});\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an `<Outlet>` to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */ function useRoutes(routes, locationArg) {\n    _s12();\n    return useRoutesImpl(routes, locationArg);\n}\n_s12(useRoutes, \"bxXQ1PjoUitFHQG/730mCYNdT00=\", false, function() {\n    return [\n        useRoutesImpl\n    ];\n});\n// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n    _s13();\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches: parentMatches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    if (true) {\n        // You won't get a warning about 2 different <Routes> under a <Route>\n        // without a trailing *, but this is a best-effort warning anyway since we\n        // cannot even give the warning unless they land at the parent route.\n        //\n        // Example:\n        //\n        // <Routes>\n        //   {/* This route path MUST end with /* because otherwise\n        //       it will never match /blog/post/123 */}\n        //   <Route path=\"blog\" element={<Blog />} />\n        //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n        // </Routes>\n        //\n        // function Blog() {\n        //   return (\n        //     <Routes>\n        //       <Route path=\"post/:id\" element={<Post />} />\n        //     </Routes>\n        //   );\n        // }\n        let parentPath = parentRoute && parentRoute.path || \"\";\n        warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + ('\"' + parentPathname + '\" (under <Route path=\"' + parentPath + '\">) but the ') + 'parent route path has no trailing \"*\". This means if you navigate ' + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + ('Please change the parent <Route path=\"' + parentPath + '\"> to <Route ') + ('path=\"' + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + '\">.'));\n    }\n    let locationFromContext = useLocation();\n    let location;\n    if (locationArg) {\n        var _parsedLocationArg$pa;\n        let parsedLocationArg = typeof locationArg === \"string\" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationArg) : locationArg;\n        !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + ('matched by all parent routes. The current pathname base is \"' + parentPathnameBase + '\" ') + ('but pathname \"' + parsedLocationArg.pathname + '\" was given in the `location` prop.')) : 0 : void 0;\n        location = parsedLocationArg;\n    } else {\n        location = locationFromContext;\n    }\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n    let matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes)(routes, {\n        pathname: remainingPathname\n    });\n    if (true) {\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(parentRoute || matches != null, 'No routes matched location \"' + location.pathname + location.search + location.hash + '\" ') : 0;\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined || matches[matches.length - 1].route.lazy !== undefined, 'Matched leaf route at location \"' + location.pathname + location.search + location.hash + '\" ' + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + 'null value by default resulting in an \"empty\" page.') : 0;\n    }\n    let renderedMatches = _renderMatches(matches && matches.map((match)=>Object.assign({}, match, {\n            params: Object.assign({}, parentParams, match.params),\n            pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n            ]),\n            pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n            ])\n        })), parentMatches, dataRouterState, future);\n    // When a user passes in a `locationArg`, the associated routes need to\n    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n    // to use the scoped location instead of the global location.\n    if (locationArg && renderedMatches) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n            value: {\n                location: _extends({\n                    pathname: \"/\",\n                    search: \"\",\n                    hash: \"\",\n                    state: null,\n                    key: \"default\"\n                }, location),\n                navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop\n            }\n        }, renderedMatches);\n    }\n    return renderedMatches;\n}\n_s13(useRoutesImpl, \"50L/Aw/rSNnE0T4921HQ7wCgOK0=\", false, function() {\n    return [\n        useInRouterContext,\n        useLocation\n    ];\n});\nfunction DefaultErrorComponent() {\n    _s14();\n    let error = useRouteError();\n    let message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n    let stack = error instanceof Error ? error.stack : null;\n    let lightgrey = \"rgba(200,200,200, 0.5)\";\n    let preStyles = {\n        padding: \"0.5rem\",\n        backgroundColor: lightgrey\n    };\n    let codeStyles = {\n        padding: \"2px 4px\",\n        backgroundColor: lightgrey\n    };\n    let devInfo = null;\n    if (true) {\n        console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n        devInfo = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n            style: codeStyles\n        }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n            style: codeStyles\n        }, \"errorElement\"), \" prop on your route.\"));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h3\", {\n        style: {\n            fontStyle: \"italic\"\n        }\n    }, message), stack ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pre\", {\n        style: preStyles\n    }, stack) : null, devInfo);\n}\n_s14(DefaultErrorComponent, \"oAgjgbJzsRXlB89+MoVumxMQqKM=\", false, function() {\n    return [\n        useRouteError\n    ];\n});\n_c = DefaultErrorComponent;\nconst defaultErrorElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);\nclass RenderErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    static getDerivedStateFromError(error) {\n        return {\n            error: error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        // When we get into an error state, the user will likely click \"back\" to the\n        // previous page that didn't have an error. Because this wraps the entire\n        // application, that will have no effect--the error page continues to display.\n        // This gives us a mechanism to recover from the error when the location changes.\n        //\n        // Whether we're in an error state or not, we update the location in state\n        // so that when we are in an error state, it gets reset when a new location\n        // comes in and the user recovers from the error.\n        if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n            return {\n                error: props.error,\n                location: props.location,\n                revalidation: props.revalidation\n            };\n        }\n        // If we're not changing locations, preserve the location but still surface\n        // any new errors that may come through. We retain the existing error, we do\n        // this because the error provided from the app state may be cleared without\n        // the location changing.\n        return {\n            error: props.error !== undefined ? props.error : state.error,\n            location: state.location,\n            revalidation: props.revalidation || state.revalidation\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        return this.state.error !== undefined ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n            value: this.props.routeContext\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteErrorContext.Provider, {\n            value: this.state.error,\n            children: this.props.component\n        })) : this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            location: props.location,\n            revalidation: props.revalidation,\n            error: props.error\n        };\n    }\n}\nfunction RenderedRoute(_ref) {\n    _s15();\n    let { routeContext, match, children } = _ref;\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    // Track how deep we got in our render pass to emulate SSR componentDidCatch\n    // in a DataStaticRouter\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n        value: routeContext\n    }, children);\n}\n_s15(RenderedRoute, \"CDKlwIqxcpySUP3IDCQMJZjTo1Q=\");\n_c1 = RenderedRoute;\nfunction _renderMatches(matches, parentMatches, dataRouterState, future) {\n    var _dataRouterState2;\n    if (parentMatches === void 0) {\n        parentMatches = [];\n    }\n    if (dataRouterState === void 0) {\n        dataRouterState = null;\n    }\n    if (future === void 0) {\n        future = null;\n    }\n    if (matches == null) {\n        var _dataRouterState;\n        if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n            // Don't bail if we have data router errors so we can render them in the\n            // boundary.  Use the pre-matched (or shimmed) matches\n            matches = dataRouterState.matches;\n        } else {\n            return null;\n        }\n    }\n    let renderedMatches = matches;\n    // If we have data errors, trim matches to the highest error boundary\n    let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n    if (errors != null) {\n        let errorIndex = renderedMatches.findIndex((m)=>m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n        !(errorIndex >= 0) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : 0 : void 0;\n        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n    // If we're in a partial hydration mode, detect if we need to render down to\n    // a given HydrateFallback while we load the rest of the hydration data\n    let renderFallback = false;\n    let fallbackIndex = -1;\n    if (dataRouterState && future && future.v7_partialHydration) {\n        for(let i = 0; i < renderedMatches.length; i++){\n            let match = renderedMatches[i];\n            // Track the deepest fallback up until the first route without data\n            if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n                fallbackIndex = i;\n            }\n            if (match.route.id) {\n                let { loaderData, errors } = dataRouterState;\n                let needsToRunLoader = match.route.loader && loaderData[match.route.id] === undefined && (!errors || errors[match.route.id] === undefined);\n                if (match.route.lazy || needsToRunLoader) {\n                    // We found the first route that's not ready to render (waiting on\n                    // lazy, or has a loader that hasn't run yet).  Flag that we need to\n                    // render a fallback and render up until the appropriate fallback\n                    renderFallback = true;\n                    if (fallbackIndex >= 0) {\n                        renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n                    } else {\n                        renderedMatches = [\n                            renderedMatches[0]\n                        ];\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return renderedMatches.reduceRight((outlet, match, index)=>{\n        // Only data routers handle errors/fallbacks\n        let error;\n        let shouldRenderHydrateFallback = false;\n        let errorElement = null;\n        let hydrateFallbackElement = null;\n        if (dataRouterState) {\n            error = errors && match.route.id ? errors[match.route.id] : undefined;\n            errorElement = match.route.errorElement || defaultErrorElement;\n            if (renderFallback) {\n                if (fallbackIndex < 0 && index === 0) {\n                    warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = null;\n                } else if (fallbackIndex === index) {\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n                }\n            }\n        }\n        let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n        let getChildren = ()=>{\n            let children;\n            if (error) {\n                children = errorElement;\n            } else if (shouldRenderHydrateFallback) {\n                children = hydrateFallbackElement;\n            } else if (match.route.Component) {\n                // Note: This is a de-optimized path since React won't re-use the\n                // ReactElement since it's identity changes with each new\n                // React.createElement call.  We keep this so folks can use\n                // `<Route Component={...}>` in `<Routes>` but generally `Component`\n                // usage is only advised in `RouterProvider` when we can convert it to\n                // `element` ahead of time.\n                children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);\n            } else if (match.route.element) {\n                children = match.route.element;\n            } else {\n                children = outlet;\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderedRoute, {\n                match: match,\n                routeContext: {\n                    outlet,\n                    matches,\n                    isDataRoute: dataRouterState != null\n                },\n                children: children\n            });\n        };\n        // Only wrap in an error boundary within data router usages when we have an\n        // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n        // an ancestor ErrorBoundary/errorElement\n        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderErrorBoundary, {\n            location: dataRouterState.location,\n            revalidation: dataRouterState.revalidation,\n            component: errorElement,\n            error: error,\n            children: getChildren(),\n            routeContext: {\n                outlet: null,\n                matches,\n                isDataRoute: true\n            }\n        }) : getChildren();\n    }, null);\n}\nvar DataRouterHook = /*#__PURE__*/ function(DataRouterHook) {\n    DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n    return DataRouterHook;\n}(DataRouterHook || {});\nvar DataRouterStateHook = /*#__PURE__*/ function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n    DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n    DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n    DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n    DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n    DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n    DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n    DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n    return DataRouterStateHook;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    _s16();\n    let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    !ctx ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\n_s16(useDataRouterContext, \"/dMy7t63NXD4eYACoT93CePwGrg=\");\nfunction useDataRouterState(hookName) {\n    _s17();\n    let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\n    !state ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\n_s17(useDataRouterState, \"kdLImxeHm3898p7tqgy8Fclg5s8=\");\nfunction useRouteContext(hookName) {\n    _s18();\n    let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return route;\n}\n_s18(useRouteContext, \"+p67gHdeicVxIDd5SykDKMiYfaw=\");\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n    _s19();\n    let route = useRouteContext(hookName);\n    let thisRoute = route.matches[route.matches.length - 1];\n    !thisRoute.route.id ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, hookName + ' can only be used on routes that contain a unique \"id\"') : 0 : void 0;\n    return thisRoute.route.id;\n}\n_s19(useCurrentRouteId, \"wASpERyQLx+zgcw/PyUNGa0MV3E=\", false, function() {\n    return [\n        useRouteContext\n    ];\n});\n/**\n * Returns the ID for the nearest contextual route\n */ function useRouteId() {\n    _s20();\n    return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n_s20(useRouteId, \"pD4QEmuO4Ll++v9bSotMnGBlCbU=\", false, function() {\n    return [\n        useCurrentRouteId\n    ];\n});\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */ function useNavigation() {\n    _s21();\n    let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n    return state.navigation;\n}\n_s21(useNavigation, \"ksx0pUFe0Qs5FOQ3bx/kwJ/n1pg=\", false, function() {\n    return [\n        useDataRouterState\n    ];\n});\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */ function useRevalidator() {\n    _s22();\n    let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n    let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            revalidate: dataRouterContext.router.revalidate,\n            state: state.revalidation\n        }), [\n        dataRouterContext.router.revalidate,\n        state.revalidation\n    ]);\n}\n_s22(useRevalidator, \"EZWIzOxYWjhEC35mfDgj9WeuX0E=\", false, function() {\n    return [\n        useDataRouterContext,\n        useDataRouterState\n    ];\n});\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */ function useMatches() {\n    _s23();\n    let { matches, loaderData } = useDataRouterState(DataRouterStateHook.UseMatches);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>matches.map((m)=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_convertRouteMatchToUiMatch)(m, loaderData)), [\n        matches,\n        loaderData\n    ]);\n}\n_s23(useMatches, \"NOMFGVHPHfWiEFTcfvlVcUixXmw=\", false, function() {\n    return [\n        useDataRouterState\n    ];\n});\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */ function useLoaderData() {\n    _s24();\n    let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    if (state.errors && state.errors[routeId] != null) {\n        console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n        return undefined;\n    }\n    return state.loaderData[routeId];\n}\n_s24(useLoaderData, \"9OzlB4eTxA/d/duIIR6ygqOjcHs=\", false, function() {\n    return [\n        useDataRouterState,\n        useCurrentRouteId\n    ];\n});\n/**\n * Returns the loaderData for the given routeId\n */ function useRouteLoaderData(routeId) {\n    _s25();\n    let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n    return state.loaderData[routeId];\n}\n_s25(useRouteLoaderData, \"ksx0pUFe0Qs5FOQ3bx/kwJ/n1pg=\", false, function() {\n    return [\n        useDataRouterState\n    ];\n});\n/**\n * Returns the action data for the nearest ancestor Route action\n */ function useActionData() {\n    _s26();\n    let state = useDataRouterState(DataRouterStateHook.UseActionData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    return state.actionData ? state.actionData[routeId] : undefined;\n}\n_s26(useActionData, \"9OzlB4eTxA/d/duIIR6ygqOjcHs=\", false, function() {\n    return [\n        useDataRouterState,\n        useCurrentRouteId\n    ];\n});\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */ function useRouteError() {\n    _s27();\n    var _state$errors;\n    let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);\n    let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n    // If this was a render error, we put it in a RouteError context inside\n    // of RenderErrorBoundary\n    if (error !== undefined) {\n        return error;\n    }\n    // Otherwise look for errors from our data router state\n    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n_s27(useRouteError, \"MKznRPOFPCBNjzCcIHhUV3MxLu8=\", false, function() {\n    return [\n        useDataRouterState,\n        useCurrentRouteId\n    ];\n});\n/**\n * Returns the happy-path data from the nearest ancestor `<Await />` value\n */ function useAsyncValue() {\n    _s28();\n    let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n    return value == null ? void 0 : value._data;\n}\n_s28(useAsyncValue, \"ksutO2/Ix3UeCrGnhyM+QEP505Y=\");\n/**\n * Returns the error from the nearest ancestor `<Await />` value\n */ function useAsyncError() {\n    _s29();\n    let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n    return value == null ? void 0 : value._error;\n}\n_s29(useAsyncError, \"ksutO2/Ix3UeCrGnhyM+QEP505Y=\");\nlet blockerId = 0;\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */ function useBlocker(shouldBlock) {\n    _s30();\n    let { router, basename } = useDataRouterContext(DataRouterHook.UseBlocker);\n    let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n    let [blockerKey, setBlockerKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"\");\n    let blockerFunction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((arg)=>{\n        if (typeof shouldBlock !== \"function\") {\n            return !!shouldBlock;\n        }\n        if (basename === \"/\") {\n            return shouldBlock(arg);\n        }\n        // If they provided us a function and we've got an active basename, strip\n        // it from the locations we expose to the user to match the behavior of\n        // useLocation\n        let { currentLocation, nextLocation, historyAction } = arg;\n        return shouldBlock({\n            currentLocation: _extends({}, currentLocation, {\n                pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(currentLocation.pathname, basename) || currentLocation.pathname\n            }),\n            nextLocation: _extends({}, nextLocation, {\n                pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(nextLocation.pathname, basename) || nextLocation.pathname\n            }),\n            historyAction\n        });\n    }, [\n        basename,\n        shouldBlock\n    ]);\n    // This effect is in charge of blocker key assignment and deletion (which is\n    // tightly coupled to the key)\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let key = String(++blockerId);\n        setBlockerKey(key);\n        return ()=>router.deleteBlocker(key);\n    }, [\n        router\n    ]);\n    // This effect handles assigning the blockerFunction.  This is to handle\n    // unstable blocker function identities, and happens only after the prior\n    // effect so we don't get an orphaned blockerFunction in the router with a\n    // key of \"\".  Until then we just have the IDLE_BLOCKER.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blockerKey !== \"\") {\n            router.getBlocker(blockerKey, blockerFunction);\n        }\n    }, [\n        router,\n        blockerKey,\n        blockerFunction\n    ]);\n    // Prefer the blocker from `state` not `router.state` since DataRouterContext\n    // is memoized so this ensures we update on blocker state updates\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.IDLE_BLOCKER;\n}\n_s30(useBlocker, \"AOVsd8P3GKIpZMz2QSJilxLW7HY=\", false, function() {\n    return [\n        useDataRouterContext,\n        useDataRouterState\n    ];\n});\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */ function useNavigateStable() {\n    _s31();\n    let { router } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n    let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n    let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\n        // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our router subscriber yet\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            router.navigate(to);\n        } else {\n            router.navigate(to, _extends({\n                fromRouteId: id\n            }, options));\n        }\n    }, [\n        router,\n        id\n    ]);\n    return navigate;\n}\n_s31(useNavigateStable, \"XnEoyWrHBFr+eR9tWx9eMWjlblI=\", false, function() {\n    return [\n        useDataRouterContext,\n        useCurrentRouteId,\n        useIsomorphicLayoutEffect\n    ];\n});\nconst alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n        alreadyWarned[key] = true;\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, message) : 0;\n    }\n}\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/ const START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\n/**\n * Given a Remix Router instance, render the appropriate UI\n */ function RouterProvider(_ref) {\n    _s32();\n    let { fallbackElement, router, future } = _ref;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        if (v7_startTransition && startTransitionImpl) {\n            startTransitionImpl(()=>setStateImpl(newState));\n        } else {\n            setStateImpl(newState);\n        }\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(fallbackElement == null || !router.future.v7_partialHydration, \"`<RouterProvider fallbackElement>` is deprecated when using \" + \"`v7_partialHydration`, use a `HydrateFallback` component instead\") : 0;\n    // Only log this once on initial mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state, opts)=>router.navigate(to, {\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                }),\n            replace: (to, state, opts)=>router.navigate(to, {\n                    replace: true,\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            router,\n            navigator,\n            static: false,\n            basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]);\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n        basename: basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: navigator,\n        future: {\n            v7_relativeSplatPath: router.future.v7_relativeSplatPath\n        }\n    }, state.initialized || router.future.v7_partialHydration ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n        routes: router.routes,\n        future: router.future,\n        state: state\n    }) : fallbackElement))), null);\n}\n_s32(RouterProvider, \"kUUDDYbee7ULQBMEitmsnqmH1Mo=\");\n_c2 = RouterProvider;\nfunction DataRoutes(_ref2) {\n    _s33();\n    let { routes, future, state } = _ref2;\n    return useRoutesImpl(routes, undefined, state, future);\n}\n_s33(DataRoutes, \"bxXQ1PjoUitFHQG/730mCYNdT00=\", false, function() {\n    return [\n        useRoutesImpl\n    ];\n});\n_c3 = DataRoutes;\n/**\n * A `<Router>` that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */ function MemoryRouter(_ref3) {\n    _s34();\n    let { basename, children, initialEntries, initialIndex, future } = _ref3;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n            initialEntries,\n            initialIndex,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history,\n        future: future\n    });\n}\n_s34(MemoryRouter, \"4hUJUqHydkgNqll0yBdcphm8IwU=\");\n_c4 = MemoryRouter;\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */ function Navigate(_ref4) {\n    _s35();\n    let { to, replace, state, relative } = _ref4;\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { future, static: isStatic } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(!isStatic, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : 0;\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let navigate = useNavigate();\n    // Resolve the path outside of the effect so that when effects run twice in\n    // StrictMode they navigate to the same place\n    let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getResolveToMatches)(matches, future.v7_relativeSplatPath), locationPathname, relative === \"path\");\n    let jsonPath = JSON.stringify(path);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>navigate(JSON.parse(jsonPath), {\n            replace,\n            state,\n            relative\n        }), [\n        navigate,\n        jsonPath,\n        relative,\n        replace,\n        state\n    ]);\n    return null;\n}\n_s35(Navigate, \"n37Mzi87sVJPNmCniRUSXZEDIfY=\", false, function() {\n    return [\n        useInRouterContext,\n        useLocation,\n        useNavigate\n    ];\n});\n_c5 = Navigate;\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */ function Outlet(props) {\n    _s36();\n    return useOutlet(props.context);\n}\n_s36(Outlet, \"UOsMKhZRqBWgnX+NkNBlxu0sfe8=\", false, function() {\n    return [\n        useOutlet\n    ];\n});\n_c6 = Outlet;\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */ function Route(_props) {\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : 0;\n}\n_c7 = Route;\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n * router that is more specific to your environment such as a `<BrowserRouter>`\n * in web browsers or a `<StaticRouter>` for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */ function Router(_ref5) {\n    _s37();\n    let { basename: basenameProp = \"/\", children = null, location: locationProp, navigationType = _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop, navigator, static: staticProp = false, future } = _ref5;\n    !!useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : 0 : void 0;\n    // Preserve trailing slashes on basename, so we can let the user control\n    // the enforcement of trailing slashes throughout the app\n    let basename = basenameProp.replace(/^\\/*/, \"/\");\n    let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            basename,\n            navigator,\n            static: staticProp,\n            future: _extends({\n                v7_relativeSplatPath: false\n            }, future)\n        }), [\n        basename,\n        future,\n        navigator,\n        staticProp\n    ]);\n    if (typeof locationProp === \"string\") {\n        locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationProp);\n    }\n    let { pathname = \"/\", search = \"\", hash = \"\", state = null, key = \"default\" } = locationProp;\n    let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        let trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(pathname, basename);\n        if (trailingPathname == null) {\n            return null;\n        }\n        return {\n            location: {\n                pathname: trailingPathname,\n                search,\n                hash,\n                state,\n                key\n            },\n            navigationType\n        };\n    }, [\n        basename,\n        pathname,\n        search,\n        hash,\n        state,\n        key,\n        navigationType\n    ]);\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(locationContext != null, '<Router basename=\"' + basename + '\"> is not able to match the URL ' + ('\"' + pathname + search + hash + '\" because it does not start with the ') + \"basename, so the <Router> won't render anything.\") : 0;\n    if (locationContext == null) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, {\n        value: navigationContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n        children: children,\n        value: locationContext\n    }));\n}\n_s37(Router, \"cWELrQ0qrnJGlFKBUy43aV+1NAk=\", false, function() {\n    return [\n        useInRouterContext\n    ];\n});\n_c8 = Router;\n/**\n * A container for a nested tree of `<Route>` elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */ function Routes(_ref6) {\n    _s38();\n    let { children, location } = _ref6;\n    return useRoutes(createRoutesFromChildren(children), location);\n}\n_s38(Routes, \"mNBMh7IZrKf5fDyw9x3t8azefmI=\", false, function() {\n    return [\n        useRoutes\n    ];\n});\n_c9 = Routes;\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */ function Await(_ref7) {\n    let { children, errorElement, resolve } = _ref7;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitErrorBoundary, {\n        resolve: resolve,\n        errorElement: errorElement\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolveAwait, null, children));\n}\n_c10 = Await;\nvar AwaitRenderStatus = /*#__PURE__*/ function(AwaitRenderStatus) {\n    AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n    AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n    AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n    return AwaitRenderStatus;\n}(AwaitRenderStatus || {});\nconst neverSettledPromise = new Promise(()=>{});\nclass AwaitErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        let { children, errorElement, resolve } = this.props;\n        let promise = null;\n        let status = AwaitRenderStatus.pending;\n        if (!(resolve instanceof Promise)) {\n            // Didn't get a promise - provide as a resolved promise\n            status = AwaitRenderStatus.success;\n            promise = Promise.resolve();\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_data\", {\n                get: ()=>resolve\n            });\n        } else if (this.state.error) {\n            // Caught a render error, provide it as a rejected promise\n            status = AwaitRenderStatus.error;\n            let renderError = this.state.error;\n            promise = Promise.reject().catch(()=>{}); // Avoid unhandled rejection warnings\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>renderError\n            });\n        } else if (resolve._tracked) {\n            // Already tracked promise - check contents\n            promise = resolve;\n            status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n        } else {\n            // Raw (untracked) promise - track it\n            status = AwaitRenderStatus.pending;\n            Object.defineProperty(resolve, \"_tracked\", {\n                get: ()=>true\n            });\n            promise = resolve.then((data)=>Object.defineProperty(resolve, \"_data\", {\n                    get: ()=>data\n                }), (error)=>Object.defineProperty(resolve, \"_error\", {\n                    get: ()=>error\n                }));\n        }\n        if (status === AwaitRenderStatus.error && promise._error instanceof _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError) {\n            // Freeze the UI by throwing a never resolved promise\n            throw neverSettledPromise;\n        }\n        if (status === AwaitRenderStatus.error && !errorElement) {\n            // No errorElement, throw to the nearest route-level error boundary\n            throw promise._error;\n        }\n        if (status === AwaitRenderStatus.error) {\n            // Render via our errorElement\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: errorElement\n            });\n        }\n        if (status === AwaitRenderStatus.success) {\n            // Render children with resolved value\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: children\n            });\n        }\n        // Throw to the suspense boundary\n        throw promise;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            error: null\n        };\n    }\n}\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n */ function ResolveAwait(_ref8) {\n    _s39();\n    let { children } = _ref8;\n    let data = useAsyncValue();\n    let toRender = typeof children === \"function\" ? children(data) : children;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, toRender);\n}\n_s39(ResolveAwait, \"EqArxLHTnAt9aJ6B4STzn3Bic5A=\", false, function() {\n    return [\n        useAsyncValue\n    ];\n});\n_c11 = ResolveAwait;\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */ function createRoutesFromChildren(children, parentPath) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    let routes = [];\n    react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element, index)=>{\n        if (!/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {\n            // Ignore non-elements. This allows people to more easily inline\n            // conditionals in their route config.\n            return;\n        }\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n            // Transparently support React.Fragment and its children.\n            routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n            return;\n        }\n        !(element.type === Route) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : 0 : void 0;\n        !(!element.props.index || !element.props.children) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"An index route cannot have child routes.\") : 0 : void 0;\n        let route = {\n            id: element.props.id || treePath.join(\"-\"),\n            caseSensitive: element.props.caseSensitive,\n            element: element.props.element,\n            Component: element.props.Component,\n            index: element.props.index,\n            path: element.props.path,\n            loader: element.props.loader,\n            action: element.props.action,\n            errorElement: element.props.errorElement,\n            ErrorBoundary: element.props.ErrorBoundary,\n            hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n            shouldRevalidate: element.props.shouldRevalidate,\n            handle: element.props.handle,\n            lazy: element.props.lazy\n        };\n        if (element.props.children) {\n            route.children = createRoutesFromChildren(element.props.children, treePath);\n        }\n        routes.push(route);\n    });\n    return routes;\n}\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */ function renderMatches(matches) {\n    return _renderMatches(matches);\n}\nfunction mapRouteProperties(route) {\n    let updates = {\n        // Note: this check also occurs in createRoutesFromChildren so update\n        // there if you change this -- please and thank you!\n        hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) {\n        if (true) {\n            if (route.element) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            element: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),\n            Component: undefined\n        });\n    }\n    if (route.HydrateFallback) {\n        if (true) {\n            if (route.hydrateFallbackElement) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - \" + \"`HydrateFallback` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            hydrateFallbackElement: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.HydrateFallback),\n            HydrateFallback: undefined\n        });\n    }\n    if (route.ErrorBoundary) {\n        if (true) {\n            if (route.errorElement) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            errorElement: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),\n            ErrorBoundary: undefined\n        });\n    }\n    return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n    return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n            initialEntries: opts == null ? void 0 : opts.initialEntries,\n            initialIndex: opts == null ? void 0 : opts.initialIndex\n        }),\n        hydrationData: opts == null ? void 0 : opts.hydrationData,\n        routes,\n        mapRouteProperties\n    }).initialize();\n}\n //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;\n$RefreshReg$(_c, \"DefaultErrorComponent\");\n$RefreshReg$(_c1, \"RenderedRoute\");\n$RefreshReg$(_c2, \"RouterProvider\");\n$RefreshReg$(_c3, \"DataRoutes\");\n$RefreshReg$(_c4, \"MemoryRouter\");\n$RefreshReg$(_c5, \"Navigate\");\n$RefreshReg$(_c6, \"Outlet\");\n$RefreshReg$(_c7, \"Route\");\n$RefreshReg$(_c8, \"Router\");\n$RefreshReg$(_c9, \"Routes\");\n$RefreshReg$(_c10, \"Await\");\n$RefreshReg$(_c11, \"ResolveAwait\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0M7QUFDOEI7QUFDa1I7QUFDckY7QUFFNU4sU0FBU3lCO0lBQ1BBLFdBQVdDLE9BQU9DLE1BQU0sR0FBR0QsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUNoRSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUN6QixJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQ3RCLElBQUlQLE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQ3JETCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUMzQjtZQUNGO1FBQ0Y7UUFDQSxPQUFPTDtJQUNUO0lBQ0EsT0FBT0osU0FBU2EsS0FBSyxDQUFDLElBQUksRUFBRVA7QUFDOUI7QUFFQSw4RUFBOEU7QUFDOUUsMkJBQTJCO0FBQzNCLE1BQU1RLG9CQUFvQixXQUFXLEdBQUV2QyxnREFBbUIsQ0FBQztBQUMzRCxJQUFJeUMsSUFBcUMsRUFBRTtJQUN6Q0Ysa0JBQWtCRyxXQUFXLEdBQUc7QUFDbEM7QUFDQSxNQUFNQyx5QkFBeUIsV0FBVyxHQUFFM0MsZ0RBQW1CLENBQUM7QUFDaEUsSUFBSXlDLElBQXFDLEVBQUU7SUFDekNFLHVCQUF1QkQsV0FBVyxHQUFHO0FBQ3ZDO0FBQ0EsTUFBTUUsZUFBZSxXQUFXLEdBQUU1QyxnREFBbUIsQ0FBQztBQUN0RCxJQUFJeUMsSUFBcUMsRUFBRTtJQUN6Q0csYUFBYUYsV0FBVyxHQUFHO0FBQzdCO0FBRUE7Ozs7Ozs7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O1lBQ3JCOUosY0FBYyxXQUFXLEdBQUVqTCxnREFBbUIsQ0FBQzJILE1BQU11RCxhQUFhO1lBQ2xFQSxlQUFlNUM7UUFDakI7SUFDRjtJQUNBLE9BQU95TTtBQUNUO0FBQ0EsU0FBU0MsbUJBQW1CL04sTUFBTSxFQUFFK0osSUFBSTtJQUN0QyxPQUFPaFEsK0RBQVlBLENBQUM7UUFDbEJ5QyxVQUFVdU4sUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS3ZOLFFBQVE7UUFDL0MwQixRQUFRMUQsU0FBUyxDQUFDLEdBQUd1UCxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLN0wsTUFBTSxFQUFFO1lBQ3hEOFAsb0JBQW9CO1FBQ3RCO1FBQ0FyRCxTQUFTOVEsc0VBQW1CQSxDQUFDO1lBQzNCMFEsZ0JBQWdCUixRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLUSxjQUFjO1lBQzNEQyxjQUFjVCxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLUyxZQUFZO1FBQ3pEO1FBQ0F5RCxlQUFlbEUsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS2tFLGFBQWE7UUFDekRqTztRQUNBNk47SUFDRixHQUFHSyxVQUFVO0FBQ2Y7QUFFeTFCLENBQ3oxQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2luZGV4LmpzPzJhMWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZWFjdCBSb3V0ZXIgdjYuMjEuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBVTlNBRkVfaW52YXJpYW50LCBqb2luUGF0aHMsIG1hdGNoUGF0aCwgVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMsIFVOU0FGRV93YXJuaW5nLCByZXNvbHZlVG8sIHBhcnNlUGF0aCwgbWF0Y2hSb3V0ZXMsIEFjdGlvbiwgVU5TQUZFX2NvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoLCBzdHJpcEJhc2VuYW1lLCBJRExFX0JMT0NLRVIsIGlzUm91dGVFcnJvclJlc3BvbnNlLCBjcmVhdGVNZW1vcnlIaXN0b3J5LCBBYm9ydGVkRGVmZXJyZWRFcnJvciwgY3JlYXRlUm91dGVyIH0gZnJvbSAnQHJlbWl4LXJ1bi9yb3V0ZXInO1xuZXhwb3J0IHsgQWJvcnRlZERlZmVycmVkRXJyb3IsIEFjdGlvbiBhcyBOYXZpZ2F0aW9uVHlwZSwgY3JlYXRlUGF0aCwgZGVmZXIsIGdlbmVyYXRlUGF0aCwgaXNSb3V0ZUVycm9yUmVzcG9uc2UsIGpzb24sIG1hdGNoUGF0aCwgbWF0Y2hSb3V0ZXMsIHBhcnNlUGF0aCwgcmVkaXJlY3QsIHJlZGlyZWN0RG9jdW1lbnQsIHJlc29sdmVQYXRoIH0gZnJvbSAnQHJlbWl4LXJ1bi9yb3V0ZXInO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLy8gQ3JlYXRlIHJlYWN0LXNwZWNpZmljIHR5cGVzIGZyb20gdGhlIGFnbm9zdGljIHR5cGVzIGluIEByZW1peC1ydW4vcm91dGVyIHRvXG4vLyBleHBvcnQgZnJvbSByZWFjdC1yb3V0ZXJcbmNvbnN0IERhdGFSb3V0ZXJDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIERhdGFSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEYXRhUm91dGVyXCI7XG59XG5jb25zdCBEYXRhUm91dGVyU3RhdGVDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkRhdGFSb3V0ZXJTdGF0ZVwiO1xufVxuY29uc3QgQXdhaXRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEF3YWl0Q29udGV4dC5kaXNwbGF5TmFtZSA9IFwiQXdhaXRcIjtcbn1cblxuLyoqXG4gKiBBIE5hdmlnYXRvciBpcyBhIFwibG9jYXRpb24gY2hhbmdlclwiOyBpdCdzIGhvdyB5b3UgZ2V0IHRvIGRpZmZlcmVudCBsb2NhdGlvbnMuXG4gKlxuICogRXZlcnkgaGlzdG9yeSBpbnN0YW5jZSBjb25mb3JtcyB0byB0aGUgTmF2aWdhdG9yIGludGVyZmFjZSwgYnV0IHRoZVxuICogZGlzdGluY3Rpb24gaXMgdXNlZnVsIHByaW1hcmlseSB3aGVuIGl0IGNvbWVzIHRvIHRoZSBsb3ctbGV2ZWwgYDxSb3V0ZXI+YCBBUElcbiAqIHdoZXJlIGJvdGggdGhlIGxvY2F0aW9uIGFuZCBhIG5hdmlnYXRvciBtdXN0IGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgaW4gb3JkZXJcbiAqIHRvIGF2b2lkIFwidGVhcmluZ1wiIHRoYXQgbWF5IG9jY3VyIGluIGEgc3VzcGVuc2UtZW5hYmxlZCBhcHAgaWYgdGhlIGFjdGlvblxuICogYW5kL29yIGxvY2F0aW9uIHdlcmUgdG8gYmUgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBoaXN0b3J5IGluc3RhbmNlLlxuICovXG5cbmNvbnN0IE5hdmlnYXRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIE5hdmlnYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJOYXZpZ2F0aW9uXCI7XG59XG5jb25zdCBMb2NhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTG9jYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJMb2NhdGlvblwiO1xufVxuY29uc3QgUm91dGVDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBvdXRsZXQ6IG51bGwsXG4gIG1hdGNoZXM6IFtdLFxuICBpc0RhdGFSb3V0ZTogZmFsc2Vcbn0pO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBSb3V0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlXCI7XG59XG5jb25zdCBSb3V0ZUVycm9yQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBSb3V0ZUVycm9yQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVFcnJvclwiO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZ1bGwgaHJlZiBmb3IgdGhlIGdpdmVuIFwidG9cIiB2YWx1ZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGJ1aWxkaW5nXG4gKiBjdXN0b20gbGlua3MgdGhhdCBhcmUgYWxzbyBhY2Nlc3NpYmxlIGFuZCBwcmVzZXJ2ZSByaWdodC1jbGljayBiZWhhdmlvci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1ocmVmXG4gKi9cbmZ1bmN0aW9uIHVzZUhyZWYodG8sIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgcmVsYXRpdmVcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZUhyZWYoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIG5hdmlnYXRvclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7XG4gICAgaGFzaCxcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2hcbiAgfSA9IHVzZVJlc29sdmVkUGF0aCh0bywge1xuICAgIHJlbGF0aXZlXG4gIH0pO1xuICBsZXQgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZTtcblxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gIC8vIHRvIGNyZWF0aW5nIHRoZSBocmVmLiAgSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiBqdXN0IHVzZSB0aGUgcmF3XG4gIC8vIGJhc2VuYW1lIHdoaWNoIGFsbG93cyB0aGUgYmFzZW5hbWUgdG8gaGF2ZSBmdWxsIGNvbnRyb2wgb3ZlciB0aGUgcHJlc2VuY2VcbiAgLy8gb2YgYSB0cmFpbGluZyBzbGFzaCBvbiByb290IGxpbmtzXG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gbmF2aWdhdG9yLmNyZWF0ZUhyZWYoe1xuICAgIHBhdGhuYW1lOiBqb2luZWRQYXRobmFtZSxcbiAgICBzZWFyY2gsXG4gICAgaGFzaFxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb21wb25lbnQgaXMgYSBkZXNjZW5kYW50IG9mIGEgYDxSb3V0ZXI+YC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1pbi1yb3V0ZXItY29udGV4dFxuICovXG5mdW5jdGlvbiB1c2VJblJvdXRlckNvbnRleHQoKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxvY2F0aW9uIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBVUkwgaW4gd2ViXG4gKiBicm93c2Vycy5cbiAqXG4gKiBOb3RlOiBJZiB5b3UncmUgdXNpbmcgdGhpcyBpdCBtYXkgbWVhbiB5b3UncmUgZG9pbmcgc29tZSBvZiB5b3VyIG93blxuICogXCJyb3V0aW5nXCIgaW4geW91ciBhcHAsIGFuZCB3ZSdkIGxpa2UgdG8ga25vdyB3aGF0IHlvdXIgdXNlIGNhc2UgaXMuIFdlIG1heVxuICogYmUgYWJsZSB0byBwcm92aWRlIHNvbWV0aGluZyBoaWdoZXItbGV2ZWwgdG8gYmV0dGVyIHN1aXQgeW91ciBuZWVkcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1sb2NhdGlvblxuICovXG5mdW5jdGlvbiB1c2VMb2NhdGlvbigpIHtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCJ1c2VMb2NhdGlvbigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubG9jYXRpb247XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGFjdGlvbiB3aGljaCBkZXNjcmliZXMgaG93IHRoZSByb3V0ZXIgY2FtZSB0b1xuICogdGhlIGN1cnJlbnQgbG9jYXRpb24sIGVpdGhlciBieSBhIHBvcCwgcHVzaCwgb3IgcmVwbGFjZSBvbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1uYXZpZ2F0aW9uLXR5cGVcbiAqL1xuZnVuY3Rpb24gdXNlTmF2aWdhdGlvblR5cGUoKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubmF2aWdhdGlvblR5cGU7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIFBhdGhNYXRjaCBvYmplY3QgaWYgdGhlIGdpdmVuIHBhdHRlcm4gbWF0Y2hlcyB0aGUgY3VycmVudCBVUkwuXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY29tcG9uZW50cyB0aGF0IG5lZWQgdG8ga25vdyBcImFjdGl2ZVwiIHN0YXRlLCBlLmcuXG4gKiBgPE5hdkxpbms+YC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1tYXRjaFxuICovXG5mdW5jdGlvbiB1c2VNYXRjaChwYXR0ZXJuKSB7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlTWF0Y2goKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIHBhdGhuYW1lXG4gIH0gPSB1c2VMb2NhdGlvbigpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBtYXRjaFBhdGgocGF0dGVybiwgcGF0aG5hbWUpLCBbcGF0aG5hbWUsIHBhdHRlcm5dKTtcbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgbmF2aWdhdGUoKSBmdW5jdGlvbiByZXR1cm5lZCBmcm9tIHVzZU5hdmlnYXRlKCkuXG4gKi9cblxuY29uc3QgbmF2aWdhdGVFZmZlY3RXYXJuaW5nID0gXCJZb3Ugc2hvdWxkIGNhbGwgbmF2aWdhdGUoKSBpbiBhIFJlYWN0LnVzZUVmZmVjdCgpLCBub3Qgd2hlbiBcIiArIFwieW91ciBjb21wb25lbnQgaXMgZmlyc3QgcmVuZGVyZWQuXCI7XG5cbi8vIE11dGUgd2FybmluZ3MgZm9yIGNhbGxzIHRvIHVzZU5hdmlnYXRlIGluIFNTUiBlbnZpcm9ubWVudHNcbmZ1bmN0aW9uIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoY2IpIHtcbiAgbGV0IGlzU3RhdGljID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljO1xuICBpZiAoIWlzU3RhdGljKSB7XG4gICAgLy8gV2Ugc2hvdWxkIGJlIGFibGUgdG8gZ2V0IHJpZCBvZiB0aGlzIG9uY2UgcmVhY3QgMTguMyBpcyByZWxlYXNlZFxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoY2IpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBpbXBlcmF0aXZlIG1ldGhvZCBmb3IgY2hhbmdpbmcgdGhlIGxvY2F0aW9uLiBVc2VkIGJ5IGA8TGluaz5gcywgYnV0XG4gKiBtYXkgYWxzbyBiZSB1c2VkIGJ5IG90aGVyIGVsZW1lbnRzIHRvIGNoYW5nZSB0aGUgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbmF2aWdhdGVcbiAqL1xuZnVuY3Rpb24gdXNlTmF2aWdhdGUoKSB7XG4gIGxldCB7XG4gICAgaXNEYXRhUm91dGVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgLy8gQ29uZGl0aW9uYWwgdXNhZ2UgaXMgT0sgaGVyZSBiZWNhdXNlIHRoZSB1c2FnZSBvZiBhIGRhdGEgcm91dGVyIGlzIHN0YXRpY1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgcmV0dXJuIGlzRGF0YVJvdXRlID8gdXNlTmF2aWdhdGVTdGFibGUoKSA6IHVzZU5hdmlnYXRlVW5zdGFibGUoKTtcbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlVW5zdGFibGUoKSB7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlTmF2aWdhdGUoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBmdXR1cmUsXG4gICAgbmF2aWdhdG9yXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHtcbiAgICBtYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWVcbiAgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpKTtcbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0bywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoYWN0aXZlUmVmLmN1cnJlbnQsIG5hdmlnYXRlRWZmZWN0V2FybmluZykgOiB2b2lkIDA7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGhlcmUgc2luY2UgaWYgdGhpcyBoYXBwZW5zIG9uIGZpcnN0IHJlbmRlciB0aGUgbmF2aWdhdGVcbiAgICAvLyBpcyB1c2VsZXNzIGJlY2F1c2Ugd2UgaGF2ZW4ndCB3aXJlZCB1cCBvdXIgaGlzdG9yeSBsaXN0ZW5lciB5ZXRcbiAgICBpZiAoIWFjdGl2ZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgbmF2aWdhdG9yLmdvKHRvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHBhdGggPSByZXNvbHZlVG8odG8sIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSwgbG9jYXRpb25QYXRobmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSA9PT0gXCJwYXRoXCIpO1xuXG4gICAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAgIC8vIHRvIGhhbmRpbmcgb2ZmIHRvIGhpc3RvcnkgKGJ1dCBvbmx5IGlmIHdlJ3JlIG5vdCBpbiBhIGRhdGEgcm91dGVyLFxuICAgIC8vIG90aGVyd2lzZSBpdCdsbCBwcmVwZW5kIHRoZSBiYXNlbmFtZSBpbnNpZGUgb2YgdGhlIHJvdXRlcikuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHJvb3QgbmF2aWdhdGlvbiwgdGhlbiB3ZSBuYXZpZ2F0ZSB0byB0aGUgcmF3IGJhc2VuYW1lXG4gICAgLy8gd2hpY2ggYWxsb3dzIHRoZSBiYXNlbmFtZSB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyIHRoZSBwcmVzZW5jZSBvZiBhXG4gICAgLy8gdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBsaW5rc1xuICAgIGlmIChkYXRhUm91dGVyQ29udGV4dCA9PSBudWxsICYmIGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gICAgfVxuICAgICghIW9wdGlvbnMucmVwbGFjZSA/IG5hdmlnYXRvci5yZXBsYWNlIDogbmF2aWdhdG9yLnB1c2gpKHBhdGgsIG9wdGlvbnMuc3RhdGUsIG9wdGlvbnMpO1xuICB9LCBbYmFzZW5hbWUsIG5hdmlnYXRvciwgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lLCBkYXRhUm91dGVyQ29udGV4dF0pO1xuICByZXR1cm4gbmF2aWdhdGU7XG59XG5jb25zdCBPdXRsZXRDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCAoaWYgcHJvdmlkZWQpIGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS5cbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW91dGxldC1jb250ZXh0XG4gKi9cbmZ1bmN0aW9uIHVzZU91dGxldENvbnRleHQoKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KE91dGxldENvbnRleHQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LiBVc2VkIGludGVybmFsbHkgYnkgYDxPdXRsZXQ+YCB0byByZW5kZXIgY2hpbGQgcm91dGVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW91dGxldFxuICovXG5mdW5jdGlvbiB1c2VPdXRsZXQoY29udGV4dCkge1xuICBsZXQgb3V0bGV0ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpLm91dGxldDtcbiAgaWYgKG91dGxldCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChPdXRsZXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogY29udGV4dFxuICAgIH0sIG91dGxldCk7XG4gIH1cbiAgcmV0dXJuIG91dGxldDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgcGFyYW1zIGZyb20gdGhlIGN1cnJlbnRcbiAqIFVSTCB0aGF0IHdlcmUgbWF0Y2hlZCBieSB0aGUgcm91dGUgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1wYXJhbXNcbiAqL1xuZnVuY3Rpb24gdXNlUGFyYW1zKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXJhbXMgOiB7fTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgcGF0aG5hbWUgb2YgdGhlIGdpdmVuIGB0b2AgdmFsdWUgYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1yZXNvbHZlZC1wYXRoXG4gKi9cbmZ1bmN0aW9uIHVzZVJlc29sdmVkUGF0aCh0bywgX3RlbXAyKSB7XG4gIGxldCB7XG4gICAgcmVsYXRpdmVcbiAgfSA9IF90ZW1wMiA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDI7XG4gIGxldCB7XG4gICAgZnV0dXJlXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHtcbiAgICBtYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWVcbiAgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gcmVzb2x2ZVRvKHRvLCBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksIGxvY2F0aW9uUGF0aG5hbWUsIHJlbGF0aXZlID09PSBcInBhdGhcIiksIFt0bywgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZV0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgb2YgdGhlIHJvdXRlIHRoYXQgbWF0Y2hlZCB0aGUgY3VycmVudCBsb2NhdGlvbiwgcHJlcGFyZWRcbiAqIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dCB0byByZW5kZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgcm91dGUgdHJlZS4gUm91dGVcbiAqIGVsZW1lbnRzIGluIHRoZSB0cmVlIG11c3QgcmVuZGVyIGFuIGA8T3V0bGV0PmAgdG8gcmVuZGVyIHRoZWlyIGNoaWxkIHJvdXRlJ3NcbiAqIGVsZW1lbnQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utcm91dGVzXG4gKi9cbmZ1bmN0aW9uIHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uQXJnKSB7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcpO1xufVxuXG4vLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiB3aXRoIGFjY2VwdCBvcHRpb25hbCBwYXJhbSBmb3IgUm91dGVyUHJvdmlkZXIgdXNhZ2VcbmZ1bmN0aW9uIHVzZVJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZywgZGF0YVJvdXRlclN0YXRlLCBmdXR1cmUpIHtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCJ1c2VSb3V0ZXMoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIG5hdmlnYXRvclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7XG4gICAgbWF0Y2hlczogcGFyZW50TWF0Y2hlc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IHBhcmVudE1hdGNoZXNbcGFyZW50TWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgbGV0IHBhcmVudFBhcmFtcyA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xuICBsZXQgcGFyZW50UGF0aG5hbWUgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50UGF0aG5hbWVCYXNlID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWVCYXNlIDogXCIvXCI7XG4gIGxldCBwYXJlbnRSb3V0ZSA9IHJvdXRlTWF0Y2ggJiYgcm91dGVNYXRjaC5yb3V0ZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIC8vIFlvdSB3b24ndCBnZXQgYSB3YXJuaW5nIGFib3V0IDIgZGlmZmVyZW50IDxSb3V0ZXM+IHVuZGVyIGEgPFJvdXRlPlxuICAgIC8vIHdpdGhvdXQgYSB0cmFpbGluZyAqLCBidXQgdGhpcyBpcyBhIGJlc3QtZWZmb3J0IHdhcm5pbmcgYW55d2F5IHNpbmNlIHdlXG4gICAgLy8gY2Fubm90IGV2ZW4gZ2l2ZSB0aGUgd2FybmluZyB1bmxlc3MgdGhleSBsYW5kIGF0IHRoZSBwYXJlbnQgcm91dGUuXG4gICAgLy9cbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vXG4gICAgLy8gPFJvdXRlcz5cbiAgICAvLyAgIHsvKiBUaGlzIHJvdXRlIHBhdGggTVVTVCBlbmQgd2l0aCAvKiBiZWNhdXNlIG90aGVyd2lzZVxuICAgIC8vICAgICAgIGl0IHdpbGwgbmV2ZXIgbWF0Y2ggL2Jsb2cvcG9zdC8xMjMgKi99XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2dcIiBlbGVtZW50PXs8QmxvZyAvPn0gLz5cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZy9mZWVkXCIgZWxlbWVudD17PEJsb2dGZWVkIC8+fSAvPlxuICAgIC8vIDwvUm91dGVzPlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gQmxvZygpIHtcbiAgICAvLyAgIHJldHVybiAoXG4gICAgLy8gICAgIDxSb3V0ZXM+XG4gICAgLy8gICAgICAgPFJvdXRlIHBhdGg9XCJwb3N0LzppZFwiIGVsZW1lbnQ9ezxQb3N0IC8+fSAvPlxuICAgIC8vICAgICA8L1JvdXRlcz5cbiAgICAvLyAgICk7XG4gICAgLy8gfVxuICAgIGxldCBwYXJlbnRQYXRoID0gcGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCB8fCBcIlwiO1xuICAgIHdhcm5pbmdPbmNlKHBhcmVudFBhdGhuYW1lLCAhcGFyZW50Um91dGUgfHwgcGFyZW50UGF0aC5lbmRzV2l0aChcIipcIiksIFwiWW91IHJlbmRlcmVkIGRlc2NlbmRhbnQgPFJvdXRlcz4gKG9yIGNhbGxlZCBgdXNlUm91dGVzKClgKSBhdCBcIiArIChcIlxcXCJcIiArIHBhcmVudFBhdGhuYW1lICsgXCJcXFwiICh1bmRlciA8Um91dGUgcGF0aD1cXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiPikgYnV0IHRoZSBcIikgKyBcInBhcmVudCByb3V0ZSBwYXRoIGhhcyBubyB0cmFpbGluZyBcXFwiKlxcXCIuIFRoaXMgbWVhbnMgaWYgeW91IG5hdmlnYXRlIFwiICsgXCJkZWVwZXIsIHRoZSBwYXJlbnQgd29uJ3QgbWF0Y2ggYW55bW9yZSBhbmQgdGhlcmVmb3JlIHRoZSBjaGlsZCBcIiArIFwicm91dGVzIHdpbGwgbmV2ZXIgcmVuZGVyLlxcblxcblwiICsgKFwiUGxlYXNlIGNoYW5nZSB0aGUgcGFyZW50IDxSb3V0ZSBwYXRoPVxcXCJcIiArIHBhcmVudFBhdGggKyBcIlxcXCI+IHRvIDxSb3V0ZSBcIikgKyAoXCJwYXRoPVxcXCJcIiArIChwYXJlbnRQYXRoID09PSBcIi9cIiA/IFwiKlwiIDogcGFyZW50UGF0aCArIFwiLypcIikgKyBcIlxcXCI+LlwiKSk7XG4gIH1cbiAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbG9jYXRpb247XG4gIGlmIChsb2NhdGlvbkFyZykge1xuICAgIHZhciBfcGFyc2VkTG9jYXRpb25BcmckcGE7XG4gICAgbGV0IHBhcnNlZExvY2F0aW9uQXJnID0gdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuICAgICEocGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiB8fCAoKF9wYXJzZWRMb2NhdGlvbkFyZyRwYSA9IHBhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcnNlZExvY2F0aW9uQXJnJHBhLnN0YXJ0c1dpdGgocGFyZW50UGF0aG5hbWVCYXNlKSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIGA8Um91dGVzIGxvY2F0aW9uPmAgb3IgYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKWAsIFwiICsgXCJ0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgXCIgKyAoXCJtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFxcXCJcIiArIHBhcmVudFBhdGhuYW1lQmFzZSArIFwiXFxcIiBcIikgKyAoXCJidXQgcGF0aG5hbWUgXFxcIlwiICsgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWUgKyBcIlxcXCIgd2FzIGdpdmVuIGluIHRoZSBgbG9jYXRpb25gIHByb3AuXCIpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGxvY2F0aW9uID0gcGFyc2VkTG9jYXRpb25Bcmc7XG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbkZyb21Db250ZXh0O1xuICB9XG4gIGxldCBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiO1xuICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiID8gcGF0aG5hbWUgOiBwYXRobmFtZS5zbGljZShwYXJlbnRQYXRobmFtZUJhc2UubGVuZ3RoKSB8fCBcIi9cIjtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHtcbiAgICBwYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWVcbiAgfSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhwYXJlbnRSb3V0ZSB8fCBtYXRjaGVzICE9IG51bGwsIFwiTm8gcm91dGVzIG1hdGNoZWQgbG9jYXRpb24gXFxcIlwiICsgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoICsgXCJcXFwiIFwiKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhtYXRjaGVzID09IG51bGwgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmVsZW1lbnQgIT09IHVuZGVmaW5lZCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmxhenkgIT09IHVuZGVmaW5lZCwgXCJNYXRjaGVkIGxlYWYgcm91dGUgYXQgbG9jYXRpb24gXFxcIlwiICsgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoICsgXCJcXFwiIFwiICsgXCJkb2VzIG5vdCBoYXZlIGFuIGVsZW1lbnQgb3IgQ29tcG9uZW50LiBUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIFwiICsgXCJudWxsIHZhbHVlIGJ5IGRlZmF1bHQgcmVzdWx0aW5nIGluIGFuIFxcXCJlbXB0eVxcXCIgcGFnZS5cIikgOiB2b2lkIDA7XG4gIH1cbiAgbGV0IHJlbmRlcmVkTWF0Y2hlcyA9IF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMgJiYgbWF0Y2hlcy5tYXAobWF0Y2ggPT4gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gsIHtcbiAgICBwYXJhbXM6IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudFBhcmFtcywgbWF0Y2gucGFyYW1zKSxcbiAgICBwYXRobmFtZTogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWUpLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVdKSxcbiAgICBwYXRobmFtZUJhc2U6IG1hdGNoLnBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgPyBwYXJlbnRQYXRobmFtZUJhc2UgOiBqb2luUGF0aHMoW3BhcmVudFBhdGhuYW1lQmFzZSxcbiAgICAvLyBSZS1lbmNvZGUgcGF0aG5hbWVzIHRoYXQgd2VyZSBkZWNvZGVkIGluc2lkZSBtYXRjaFJvdXRlc1xuICAgIG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZUJhc2UpLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVCYXNlXSlcbiAgfSkpLCBwYXJlbnRNYXRjaGVzLCBkYXRhUm91dGVyU3RhdGUsIGZ1dHVyZSk7XG5cbiAgLy8gV2hlbiBhIHVzZXIgcGFzc2VzIGluIGEgYGxvY2F0aW9uQXJnYCwgdGhlIGFzc29jaWF0ZWQgcm91dGVzIG5lZWQgdG9cbiAgLy8gYmUgd3JhcHBlZCBpbiBhIG5ldyBgTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyYCBpbiBvcmRlciBmb3IgYHVzZUxvY2F0aW9uYFxuICAvLyB0byB1c2UgdGhlIHNjb3BlZCBsb2NhdGlvbiBpbnN0ZWFkIG9mIHRoZSBnbG9iYWwgbG9jYXRpb24uXG4gIGlmIChsb2NhdGlvbkFyZyAmJiByZW5kZXJlZE1hdGNoZXMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBsb2NhdGlvbjogX2V4dGVuZHMoe1xuICAgICAgICAgIHBhdGhuYW1lOiBcIi9cIixcbiAgICAgICAgICBzZWFyY2g6IFwiXCIsXG4gICAgICAgICAgaGFzaDogXCJcIixcbiAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgICBrZXk6IFwiZGVmYXVsdFwiXG4gICAgICAgIH0sIGxvY2F0aW9uKSxcbiAgICAgICAgbmF2aWdhdGlvblR5cGU6IEFjdGlvbi5Qb3BcbiAgICAgIH1cbiAgICB9LCByZW5kZXJlZE1hdGNoZXMpO1xuICB9XG4gIHJldHVybiByZW5kZXJlZE1hdGNoZXM7XG59XG5mdW5jdGlvbiBEZWZhdWx0RXJyb3JDb21wb25lbnQoKSB7XG4gIGxldCBlcnJvciA9IHVzZVJvdXRlRXJyb3IoKTtcbiAgbGV0IG1lc3NhZ2UgPSBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBlcnJvci5zdGF0dXMgKyBcIiBcIiArIGVycm9yLnN0YXR1c1RleHQgOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgbGV0IHN0YWNrID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogbnVsbDtcbiAgbGV0IGxpZ2h0Z3JleSA9IFwicmdiYSgyMDAsMjAwLDIwMCwgMC41KVwiO1xuICBsZXQgcHJlU3R5bGVzID0ge1xuICAgIHBhZGRpbmc6IFwiMC41cmVtXCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXlcbiAgfTtcbiAgbGV0IGNvZGVTdHlsZXMgPSB7XG4gICAgcGFkZGluZzogXCIycHggNHB4XCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXlcbiAgfTtcbiAgbGV0IGRldkluZm8gPSBudWxsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGhhbmRsZWQgYnkgUmVhY3QgUm91dGVyIGRlZmF1bHQgRXJyb3JCb3VuZGFyeTpcIiwgZXJyb3IpO1xuICAgIGRldkluZm8gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiXFx1RDgzRFxcdURDQkYgSGV5IGRldmVsb3BlciBcXHVEODNEXFx1REM0QlwiKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgZXJyb3JzIGJ5IHByb3ZpZGluZyB5b3VyIG93biBcIiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtcbiAgICAgIHN0eWxlOiBjb2RlU3R5bGVzXG4gICAgfSwgXCJFcnJvckJvdW5kYXJ5XCIpLCBcIiBvclwiLCBcIiBcIiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtcbiAgICAgIHN0eWxlOiBjb2RlU3R5bGVzXG4gICAgfSwgXCJlcnJvckVsZW1lbnRcIiksIFwiIHByb3Agb24geW91ciByb3V0ZS5cIikpO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoMlwiLCBudWxsLCBcIlVuZXhwZWN0ZWQgQXBwbGljYXRpb24gRXJyb3IhXCIpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImgzXCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfVxuICB9LCBtZXNzYWdlKSwgc3RhY2sgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCB7XG4gICAgc3R5bGU6IHByZVN0eWxlc1xuICB9LCBzdGFjaykgOiBudWxsLCBkZXZJbmZvKTtcbn1cbmNvbnN0IGRlZmF1bHRFcnJvckVsZW1lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0RXJyb3JDb21wb25lbnQsIG51bGwpO1xuY2xhc3MgUmVuZGVyRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbixcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvclxuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgLy8gV2hlbiB3ZSBnZXQgaW50byBhbiBlcnJvciBzdGF0ZSwgdGhlIHVzZXIgd2lsbCBsaWtlbHkgY2xpY2sgXCJiYWNrXCIgdG8gdGhlXG4gICAgLy8gcHJldmlvdXMgcGFnZSB0aGF0IGRpZG4ndCBoYXZlIGFuIGVycm9yLiBCZWNhdXNlIHRoaXMgd3JhcHMgdGhlIGVudGlyZVxuICAgIC8vIGFwcGxpY2F0aW9uLCB0aGF0IHdpbGwgaGF2ZSBubyBlZmZlY3QtLXRoZSBlcnJvciBwYWdlIGNvbnRpbnVlcyB0byBkaXNwbGF5LlxuICAgIC8vIFRoaXMgZ2l2ZXMgdXMgYSBtZWNoYW5pc20gdG8gcmVjb3ZlciBmcm9tIHRoZSBlcnJvciB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgIC8vXG4gICAgLy8gV2hldGhlciB3ZSdyZSBpbiBhbiBlcnJvciBzdGF0ZSBvciBub3QsIHdlIHVwZGF0ZSB0aGUgbG9jYXRpb24gaW4gc3RhdGVcbiAgICAvLyBzbyB0aGF0IHdoZW4gd2UgYXJlIGluIGFuIGVycm9yIHN0YXRlLCBpdCBnZXRzIHJlc2V0IHdoZW4gYSBuZXcgbG9jYXRpb25cbiAgICAvLyBjb21lcyBpbiBhbmQgdGhlIHVzZXIgcmVjb3ZlcnMgZnJvbSB0aGUgZXJyb3IuXG4gICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb24gIT09IFwiaWRsZVwiICYmIHByb3BzLnJldmFsaWRhdGlvbiA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBwcm9wcy5lcnJvcixcbiAgICAgICAgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uLFxuICAgICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvblxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBub3QgY2hhbmdpbmcgbG9jYXRpb25zLCBwcmVzZXJ2ZSB0aGUgbG9jYXRpb24gYnV0IHN0aWxsIHN1cmZhY2VcbiAgICAvLyBhbnkgbmV3IGVycm9ycyB0aGF0IG1heSBjb21lIHRocm91Z2guIFdlIHJldGFpbiB0aGUgZXhpc3RpbmcgZXJyb3IsIHdlIGRvXG4gICAgLy8gdGhpcyBiZWNhdXNlIHRoZSBlcnJvciBwcm92aWRlZCBmcm9tIHRoZSBhcHAgc3RhdGUgbWF5IGJlIGNsZWFyZWQgd2l0aG91dFxuICAgIC8vIHRoZSBsb2NhdGlvbiBjaGFuZ2luZy5cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHByb3BzLmVycm9yICE9PSB1bmRlZmluZWQgPyBwcm9wcy5lcnJvciA6IHN0YXRlLmVycm9yLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlJlYWN0IFJvdXRlciBjYXVnaHQgdGhlIGZvbGxvd2luZyBlcnJvciBkdXJpbmcgcmVuZGVyXCIsIGVycm9yLCBlcnJvckluZm8pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciAhPT0gdW5kZWZpbmVkID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogdGhpcy5wcm9wcy5yb3V0ZUNvbnRleHRcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZUVycm9yQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jb21wb25lbnRcbiAgICB9KSkgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59XG5mdW5jdGlvbiBSZW5kZXJlZFJvdXRlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICByb3V0ZUNvbnRleHQsXG4gICAgbWF0Y2gsXG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuXG4gIC8vIFRyYWNrIGhvdyBkZWVwIHdlIGdvdCBpbiBvdXIgcmVuZGVyIHBhc3MgdG8gZW11bGF0ZSBTU1IgY29tcG9uZW50RGlkQ2F0Y2hcbiAgLy8gaW4gYSBEYXRhU3RhdGljUm91dGVyXG4gIGlmIChkYXRhUm91dGVyQ29udGV4dCAmJiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWMgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dCAmJiAobWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkpKSB7XG4gICAgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcm91dGVDb250ZXh0XG4gIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMsIHBhcmVudE1hdGNoZXMsIGRhdGFSb3V0ZXJTdGF0ZSwgZnV0dXJlKSB7XG4gIHZhciBfZGF0YVJvdXRlclN0YXRlMjtcbiAgaWYgKHBhcmVudE1hdGNoZXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmVudE1hdGNoZXMgPSBbXTtcbiAgfVxuICBpZiAoZGF0YVJvdXRlclN0YXRlID09PSB2b2lkIDApIHtcbiAgICBkYXRhUm91dGVyU3RhdGUgPSBudWxsO1xuICB9XG4gIGlmIChmdXR1cmUgPT09IHZvaWQgMCkge1xuICAgIGZ1dHVyZSA9IG51bGw7XG4gIH1cbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgIHZhciBfZGF0YVJvdXRlclN0YXRlO1xuICAgIGlmICgoX2RhdGFSb3V0ZXJTdGF0ZSA9IGRhdGFSb3V0ZXJTdGF0ZSkgIT0gbnVsbCAmJiBfZGF0YVJvdXRlclN0YXRlLmVycm9ycykge1xuICAgICAgLy8gRG9uJ3QgYmFpbCBpZiB3ZSBoYXZlIGRhdGEgcm91dGVyIGVycm9ycyBzbyB3ZSBjYW4gcmVuZGVyIHRoZW0gaW4gdGhlXG4gICAgICAvLyBib3VuZGFyeS4gIFVzZSB0aGUgcHJlLW1hdGNoZWQgKG9yIHNoaW1tZWQpIG1hdGNoZXNcbiAgICAgIG1hdGNoZXMgPSBkYXRhUm91dGVyU3RhdGUubWF0Y2hlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBtYXRjaGVzO1xuXG4gIC8vIElmIHdlIGhhdmUgZGF0YSBlcnJvcnMsIHRyaW0gbWF0Y2hlcyB0byB0aGUgaGlnaGVzdCBlcnJvciBib3VuZGFyeVxuICBsZXQgZXJyb3JzID0gKF9kYXRhUm91dGVyU3RhdGUyID0gZGF0YVJvdXRlclN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSb3V0ZXJTdGF0ZTIuZXJyb3JzO1xuICBpZiAoZXJyb3JzICE9IG51bGwpIHtcbiAgICBsZXQgZXJyb3JJbmRleCA9IHJlbmRlcmVkTWF0Y2hlcy5maW5kSW5kZXgobSA9PiBtLnJvdXRlLmlkICYmIChlcnJvcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yc1ttLnJvdXRlLmlkXSkpO1xuICAgICEoZXJyb3JJbmRleCA+PSAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiQ291bGQgbm90IGZpbmQgYSBtYXRjaGluZyByb3V0ZSBmb3IgZXJyb3JzIG9uIHJvdXRlIElEczogXCIgKyBPYmplY3Qua2V5cyhlcnJvcnMpLmpvaW4oXCIsXCIpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBNYXRoLm1pbihyZW5kZXJlZE1hdGNoZXMubGVuZ3RoLCBlcnJvckluZGV4ICsgMSkpO1xuICB9XG5cbiAgLy8gSWYgd2UncmUgaW4gYSBwYXJ0aWFsIGh5ZHJhdGlvbiBtb2RlLCBkZXRlY3QgaWYgd2UgbmVlZCB0byByZW5kZXIgZG93biB0b1xuICAvLyBhIGdpdmVuIEh5ZHJhdGVGYWxsYmFjayB3aGlsZSB3ZSBsb2FkIHRoZSByZXN0IG9mIHRoZSBoeWRyYXRpb24gZGF0YVxuICBsZXQgcmVuZGVyRmFsbGJhY2sgPSBmYWxzZTtcbiAgbGV0IGZhbGxiYWNrSW5kZXggPSAtMTtcbiAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSAmJiBmdXR1cmUgJiYgZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcmVkTWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG1hdGNoID0gcmVuZGVyZWRNYXRjaGVzW2ldO1xuICAgICAgLy8gVHJhY2sgdGhlIGRlZXBlc3QgZmFsbGJhY2sgdXAgdW50aWwgdGhlIGZpcnN0IHJvdXRlIHdpdGhvdXQgZGF0YVxuICAgICAgaWYgKG1hdGNoLnJvdXRlLkh5ZHJhdGVGYWxsYmFjayB8fCBtYXRjaC5yb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50KSB7XG4gICAgICAgIGZhbGxiYWNrSW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLnJvdXRlLmlkKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgICBlcnJvcnNcbiAgICAgICAgfSA9IGRhdGFSb3V0ZXJTdGF0ZTtcbiAgICAgICAgbGV0IG5lZWRzVG9SdW5Mb2FkZXIgPSBtYXRjaC5yb3V0ZS5sb2FkZXIgJiYgbG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPT09IHVuZGVmaW5lZCAmJiAoIWVycm9ycyB8fCBlcnJvcnNbbWF0Y2gucm91dGUuaWRdID09PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAobWF0Y2gucm91dGUubGF6eSB8fCBuZWVkc1RvUnVuTG9hZGVyKSB7XG4gICAgICAgICAgLy8gV2UgZm91bmQgdGhlIGZpcnN0IHJvdXRlIHRoYXQncyBub3QgcmVhZHkgdG8gcmVuZGVyICh3YWl0aW5nIG9uXG4gICAgICAgICAgLy8gbGF6eSwgb3IgaGFzIGEgbG9hZGVyIHRoYXQgaGFzbid0IHJ1biB5ZXQpLiAgRmxhZyB0aGF0IHdlIG5lZWQgdG9cbiAgICAgICAgICAvLyByZW5kZXIgYSBmYWxsYmFjayBhbmQgcmVuZGVyIHVwIHVudGlsIHRoZSBhcHByb3ByaWF0ZSBmYWxsYmFja1xuICAgICAgICAgIHJlbmRlckZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZmFsbGJhY2tJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZW5kZXJlZE1hdGNoZXMgPSByZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgZmFsbGJhY2tJbmRleCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlZE1hdGNoZXMgPSBbcmVuZGVyZWRNYXRjaGVzWzBdXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcy5yZWR1Y2VSaWdodCgob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICAvLyBPbmx5IGRhdGEgcm91dGVycyBoYW5kbGUgZXJyb3JzL2ZhbGxiYWNrc1xuICAgIGxldCBlcnJvcjtcbiAgICBsZXQgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gZmFsc2U7XG4gICAgbGV0IGVycm9yRWxlbWVudCA9IG51bGw7XG4gICAgbGV0IGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBudWxsO1xuICAgIGlmIChkYXRhUm91dGVyU3RhdGUpIHtcbiAgICAgIGVycm9yID0gZXJyb3JzICYmIG1hdGNoLnJvdXRlLmlkID8gZXJyb3JzW21hdGNoLnJvdXRlLmlkXSA6IHVuZGVmaW5lZDtcbiAgICAgIGVycm9yRWxlbWVudCA9IG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBkZWZhdWx0RXJyb3JFbGVtZW50O1xuICAgICAgaWYgKHJlbmRlckZhbGxiYWNrKSB7XG4gICAgICAgIGlmIChmYWxsYmFja0luZGV4IDwgMCAmJiBpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHdhcm5pbmdPbmNlKFwicm91dGUtZmFsbGJhY2tcIiwgZmFsc2UsIFwiTm8gYEh5ZHJhdGVGYWxsYmFja2AgZWxlbWVudCBwcm92aWRlZCB0byByZW5kZXIgZHVyaW5nIGluaXRpYWwgaHlkcmF0aW9uXCIpO1xuICAgICAgICAgIHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoZmFsbGJhY2tJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICBzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgPSBtYXRjaC5yb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50IHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1hdGNoZXMgPSBwYXJlbnRNYXRjaGVzLmNvbmNhdChyZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgaW5kZXggKyAxKSk7XG4gICAgbGV0IGdldENoaWxkcmVuID0gKCkgPT4ge1xuICAgICAgbGV0IGNoaWxkcmVuO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZXJyb3JFbGVtZW50O1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2spIHtcbiAgICAgICAgY2hpbGRyZW4gPSBoeWRyYXRlRmFsbGJhY2tFbGVtZW50O1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC5yb3V0ZS5Db21wb25lbnQpIHtcbiAgICAgICAgLy8gTm90ZTogVGhpcyBpcyBhIGRlLW9wdGltaXplZCBwYXRoIHNpbmNlIFJlYWN0IHdvbid0IHJlLXVzZSB0aGVcbiAgICAgICAgLy8gUmVhY3RFbGVtZW50IHNpbmNlIGl0J3MgaWRlbnRpdHkgY2hhbmdlcyB3aXRoIGVhY2ggbmV3XG4gICAgICAgIC8vIFJlYWN0LmNyZWF0ZUVsZW1lbnQgY2FsbC4gIFdlIGtlZXAgdGhpcyBzbyBmb2xrcyBjYW4gdXNlXG4gICAgICAgIC8vIGA8Um91dGUgQ29tcG9uZW50PXsuLi59PmAgaW4gYDxSb3V0ZXM+YCBidXQgZ2VuZXJhbGx5IGBDb21wb25lbnRgXG4gICAgICAgIC8vIHVzYWdlIGlzIG9ubHkgYWR2aXNlZCBpbiBgUm91dGVyUHJvdmlkZXJgIHdoZW4gd2UgY2FuIGNvbnZlcnQgaXQgdG9cbiAgICAgICAgLy8gYGVsZW1lbnRgIGFoZWFkIG9mIHRpbWUuXG4gICAgICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQobWF0Y2gucm91dGUuQ29tcG9uZW50LCBudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuZWxlbWVudCkge1xuICAgICAgICBjaGlsZHJlbiA9IG1hdGNoLnJvdXRlLmVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IG91dGxldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW5kZXJlZFJvdXRlLCB7XG4gICAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgICAgcm91dGVDb250ZXh0OiB7XG4gICAgICAgICAgb3V0bGV0LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgaXNEYXRhUm91dGU6IGRhdGFSb3V0ZXJTdGF0ZSAhPSBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBPbmx5IHdyYXAgaW4gYW4gZXJyb3IgYm91bmRhcnkgd2l0aGluIGRhdGEgcm91dGVyIHVzYWdlcyB3aGVuIHdlIGhhdmUgYW5cbiAgICAvLyBFcnJvckJvdW5kYXJ5L2Vycm9yRWxlbWVudCBvbiB0aGlzIHJvdXRlLiAgT3RoZXJ3aXNlIGxldCBpdCBidWJibGUgdXAgdG9cbiAgICAvLyBhbiBhbmNlc3RvciBFcnJvckJvdW5kYXJ5L2Vycm9yRWxlbWVudFxuICAgIHJldHVybiBkYXRhUm91dGVyU3RhdGUgJiYgKG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkgfHwgbWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IGluZGV4ID09PSAwKSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlbmRlckVycm9yQm91bmRhcnksIHtcbiAgICAgIGxvY2F0aW9uOiBkYXRhUm91dGVyU3RhdGUubG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRpb246IGRhdGFSb3V0ZXJTdGF0ZS5yZXZhbGlkYXRpb24sXG4gICAgICBjb21wb25lbnQ6IGVycm9yRWxlbWVudCxcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIGNoaWxkcmVuOiBnZXRDaGlsZHJlbigpLFxuICAgICAgcm91dGVDb250ZXh0OiB7XG4gICAgICAgIG91dGxldDogbnVsbCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgaXNEYXRhUm91dGU6IHRydWVcbiAgICAgIH1cbiAgICB9KSA6IGdldENoaWxkcmVuKCk7XG4gIH0sIG51bGwpO1xufVxudmFyIERhdGFSb3V0ZXJIb29rID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChEYXRhUm91dGVySG9vaykge1xuICBEYXRhUm91dGVySG9va1tcIlVzZUJsb2NrZXJcIl0gPSBcInVzZUJsb2NrZXJcIjtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VSZXZhbGlkYXRvclwiXSA9IFwidXNlUmV2YWxpZGF0b3JcIjtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VOYXZpZ2F0ZVN0YWJsZVwiXSA9IFwidXNlTmF2aWdhdGVcIjtcbiAgcmV0dXJuIERhdGFSb3V0ZXJIb29rO1xufShEYXRhUm91dGVySG9vayB8fCB7fSk7XG52YXIgRGF0YVJvdXRlclN0YXRlSG9vayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRGF0YVJvdXRlclN0YXRlSG9vaykge1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlQmxvY2tlclwiXSA9IFwidXNlQmxvY2tlclwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTG9hZGVyRGF0YVwiXSA9IFwidXNlTG9hZGVyRGF0YVwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlQWN0aW9uRGF0YVwiXSA9IFwidXNlQWN0aW9uRGF0YVwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlUm91dGVFcnJvclwiXSA9IFwidXNlUm91dGVFcnJvclwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTmF2aWdhdGlvblwiXSA9IFwidXNlTmF2aWdhdGlvblwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlUm91dGVMb2FkZXJEYXRhXCJdID0gXCJ1c2VSb3V0ZUxvYWRlckRhdGFcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZU1hdGNoZXNcIl0gPSBcInVzZU1hdGNoZXNcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVJldmFsaWRhdG9yXCJdID0gXCJ1c2VSZXZhbGlkYXRvclwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTmF2aWdhdGVTdGFibGVcIl0gPSBcInVzZU5hdmlnYXRlXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSb3V0ZUlkXCJdID0gXCJ1c2VSb3V0ZUlkXCI7XG4gIHJldHVybiBEYXRhUm91dGVyU3RhdGVIb29rO1xufShEYXRhUm91dGVyU3RhdGVIb29rIHx8IHt9KTtcbmZ1bmN0aW9uIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpIHtcbiAgcmV0dXJuIGhvb2tOYW1lICsgXCIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5cIjtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0KGhvb2tOYW1lKSB7XG4gIGxldCBjdHggPSBSZWFjdC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgIWN0eCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlKGhvb2tOYW1lKSB7XG4gIGxldCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICFzdGF0ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpIHtcbiAgbGV0IHJvdXRlID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICAhcm91dGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHJvdXRlO1xufVxuXG4vLyBJbnRlcm5hbCB2ZXJzaW9uIHdpdGggaG9va05hbWUtYXdhcmUgZGVidWdnaW5nXG5mdW5jdGlvbiB1c2VDdXJyZW50Um91dGVJZChob29rTmFtZSkge1xuICBsZXQgcm91dGUgPSB1c2VSb3V0ZUNvbnRleHQoaG9va05hbWUpO1xuICBsZXQgdGhpc1JvdXRlID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAhdGhpc1JvdXRlLnJvdXRlLmlkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgaG9va05hbWUgKyBcIiBjYW4gb25seSBiZSB1c2VkIG9uIHJvdXRlcyB0aGF0IGNvbnRhaW4gYSB1bmlxdWUgXFxcImlkXFxcIlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gdGhpc1JvdXRlLnJvdXRlLmlkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIElEIGZvciB0aGUgbmVhcmVzdCBjb250ZXh0dWFsIHJvdXRlXG4gKi9cbmZ1bmN0aW9uIHVzZVJvdXRlSWQoKSB7XG4gIHJldHVybiB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlSWQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiwgZGVmYXVsdGluZyB0byBhbiBcImlkbGVcIiBuYXZpZ2F0aW9uIHdoZW5cbiAqIG5vIG5hdmlnYXRpb24gaXMgaW4gcHJvZ3Jlc3NcbiAqL1xuZnVuY3Rpb24gdXNlTmF2aWdhdGlvbigpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTmF2aWdhdGlvbik7XG4gIHJldHVybiBzdGF0ZS5uYXZpZ2F0aW9uO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByZXZhbGlkYXRlIGZ1bmN0aW9uIGZvciBtYW51YWxseSB0cmlnZ2VyaW5nIHJldmFsaWRhdGlvbiwgYXMgd2VsbFxuICogYXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYW55IG1hbnVhbCByZXZhbGlkYXRpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZVJldmFsaWRhdG9yKCkge1xuICBsZXQgZGF0YVJvdXRlckNvbnRleHQgPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VSZXZhbGlkYXRvcik7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJldmFsaWRhdG9yKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZXZhbGlkYXRlOiBkYXRhUm91dGVyQ29udGV4dC5yb3V0ZXIucmV2YWxpZGF0ZSxcbiAgICBzdGF0ZTogc3RhdGUucmV2YWxpZGF0aW9uXG4gIH0pLCBbZGF0YVJvdXRlckNvbnRleHQucm91dGVyLnJldmFsaWRhdGUsIHN0YXRlLnJldmFsaWRhdGlvbl0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFjdGl2ZSByb3V0ZSBtYXRjaGVzLCB1c2VmdWwgZm9yIGFjY2Vzc2luZyBsb2FkZXJEYXRhIGZvclxuICogcGFyZW50L2NoaWxkIHJvdXRlcyBvciB0aGUgcm91dGUgXCJoYW5kbGVcIiBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiB1c2VNYXRjaGVzKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgbG9hZGVyRGF0YVxuICB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTWF0Y2hlcyk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IG1hdGNoZXMubWFwKG0gPT4gVU5TQUZFX2NvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG0sIGxvYWRlckRhdGEpKSwgW21hdGNoZXMsIGxvYWRlckRhdGFdKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb2FkZXIgZGF0YSBmb3IgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgbG9hZGVyXG4gKi9cbmZ1bmN0aW9uIHVzZUxvYWRlckRhdGEoKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUxvYWRlckRhdGEpO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG4gIGlmIChzdGF0ZS5lcnJvcnMgJiYgc3RhdGUuZXJyb3JzW3JvdXRlSWRdICE9IG51bGwpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiWW91IGNhbm5vdCBgdXNlTG9hZGVyRGF0YWAgaW4gYW4gZXJyb3JFbGVtZW50IChyb3V0ZUlkOiBcIiArIHJvdXRlSWQgKyBcIilcIik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb2FkZXJEYXRhIGZvciB0aGUgZ2l2ZW4gcm91dGVJZFxuICovXG5mdW5jdGlvbiB1c2VSb3V0ZUxvYWRlckRhdGEocm91dGVJZCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUxvYWRlckRhdGEpO1xuICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhY3Rpb24gZGF0YSBmb3IgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIHVzZUFjdGlvbkRhdGEoKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUFjdGlvbkRhdGEpO1xuICBsZXQgcm91dGVJZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG4gIHJldHVybiBzdGF0ZS5hY3Rpb25EYXRhID8gc3RhdGUuYWN0aW9uRGF0YVtyb3V0ZUlkXSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZWFyZXN0IGFuY2VzdG9yIFJvdXRlIGVycm9yLCB3aGljaCBjb3VsZCBiZSBhIGxvYWRlci9hY3Rpb25cbiAqIGVycm9yIG9yIGEgcmVuZGVyIGVycm9yLiAgVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBjYWxsZWQgZnJvbSB5b3VyXG4gKiBFcnJvckJvdW5kYXJ5L2Vycm9yRWxlbWVudCB0byBkaXNwbGF5IGEgcHJvcGVyIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIHVzZVJvdXRlRXJyb3IoKSB7XG4gIHZhciBfc3RhdGUkZXJyb3JzO1xuICBsZXQgZXJyb3IgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlRXJyb3JDb250ZXh0KTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVFcnJvcik7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUVycm9yKTtcblxuICAvLyBJZiB0aGlzIHdhcyBhIHJlbmRlciBlcnJvciwgd2UgcHV0IGl0IGluIGEgUm91dGVFcnJvciBjb250ZXh0IGluc2lkZVxuICAvLyBvZiBSZW5kZXJFcnJvckJvdW5kYXJ5XG4gIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlIGxvb2sgZm9yIGVycm9ycyBmcm9tIG91ciBkYXRhIHJvdXRlciBzdGF0ZVxuICByZXR1cm4gKF9zdGF0ZSRlcnJvcnMgPSBzdGF0ZS5lcnJvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZXJyb3JzW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGhhcHB5LXBhdGggZGF0YSBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGA8QXdhaXQgLz5gIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHVzZUFzeW5jVmFsdWUoKSB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5fZGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlcnJvciBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGA8QXdhaXQgLz5gIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHVzZUFzeW5jRXJyb3IoKSB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5fZXJyb3I7XG59XG5sZXQgYmxvY2tlcklkID0gMDtcblxuLyoqXG4gKiBBbGxvdyB0aGUgYXBwbGljYXRpb24gdG8gYmxvY2sgbmF2aWdhdGlvbnMgd2l0aGluIHRoZSBTUEEgYW5kIHByZXNlbnQgdGhlXG4gKiB1c2VyIGEgY29uZmlybWF0aW9uIGRpYWxvZyB0byBjb25maXJtIHRoZSBuYXZpZ2F0aW9uLiAgTW9zdGx5IHVzZWQgdG8gYXZvaWRcbiAqIHVzaW5nIGhhbGYtZmlsbGVkIGZvcm0gZGF0YS4gIFRoaXMgZG9lcyBub3QgaGFuZGxlIGhhcmQtcmVsb2FkcyBvclxuICogY3Jvc3Mtb3JpZ2luIG5hdmlnYXRpb25zLlxuICovXG5mdW5jdGlvbiB1c2VCbG9ja2VyKHNob3VsZEJsb2NrKSB7XG4gIGxldCB7XG4gICAgcm91dGVyLFxuICAgIGJhc2VuYW1lXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VCbG9ja2VyKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlQmxvY2tlcik7XG4gIGxldCBbYmxvY2tlcktleSwgc2V0QmxvY2tlcktleV0gPSBSZWFjdC51c2VTdGF0ZShcIlwiKTtcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGFyZyA9PiB7XG4gICAgaWYgKHR5cGVvZiBzaG91bGRCbG9jayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gISFzaG91bGRCbG9jaztcbiAgICB9XG4gICAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikge1xuICAgICAgcmV0dXJuIHNob3VsZEJsb2NrKGFyZyk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhleSBwcm92aWRlZCB1cyBhIGZ1bmN0aW9uIGFuZCB3ZSd2ZSBnb3QgYW4gYWN0aXZlIGJhc2VuYW1lLCBzdHJpcFxuICAgIC8vIGl0IGZyb20gdGhlIGxvY2F0aW9ucyB3ZSBleHBvc2UgdG8gdGhlIHVzZXIgdG8gbWF0Y2ggdGhlIGJlaGF2aW9yIG9mXG4gICAgLy8gdXNlTG9jYXRpb25cbiAgICBsZXQge1xuICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaGlzdG9yeUFjdGlvblxuICAgIH0gPSBhcmc7XG4gICAgcmV0dXJuIHNob3VsZEJsb2NrKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbjogX2V4dGVuZHMoe30sIGN1cnJlbnRMb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pLFxuICAgICAgbmV4dExvY2F0aW9uOiBfZXh0ZW5kcyh7fSwgbmV4dExvY2F0aW9uLCB7XG4gICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSksXG4gICAgICBoaXN0b3J5QWN0aW9uXG4gICAgfSk7XG4gIH0sIFtiYXNlbmFtZSwgc2hvdWxkQmxvY2tdKTtcblxuICAvLyBUaGlzIGVmZmVjdCBpcyBpbiBjaGFyZ2Ugb2YgYmxvY2tlciBrZXkgYXNzaWdubWVudCBhbmQgZGVsZXRpb24gKHdoaWNoIGlzXG4gIC8vIHRpZ2h0bHkgY291cGxlZCB0byB0aGUga2V5KVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBrZXkgPSBTdHJpbmcoKytibG9ja2VySWQpO1xuICAgIHNldEJsb2NrZXJLZXkoa2V5KTtcbiAgICByZXR1cm4gKCkgPT4gcm91dGVyLmRlbGV0ZUJsb2NrZXIoa2V5KTtcbiAgfSwgW3JvdXRlcl0pO1xuXG4gIC8vIFRoaXMgZWZmZWN0IGhhbmRsZXMgYXNzaWduaW5nIHRoZSBibG9ja2VyRnVuY3Rpb24uICBUaGlzIGlzIHRvIGhhbmRsZVxuICAvLyB1bnN0YWJsZSBibG9ja2VyIGZ1bmN0aW9uIGlkZW50aXRpZXMsIGFuZCBoYXBwZW5zIG9ubHkgYWZ0ZXIgdGhlIHByaW9yXG4gIC8vIGVmZmVjdCBzbyB3ZSBkb24ndCBnZXQgYW4gb3JwaGFuZWQgYmxvY2tlckZ1bmN0aW9uIGluIHRoZSByb3V0ZXIgd2l0aCBhXG4gIC8vIGtleSBvZiBcIlwiLiAgVW50aWwgdGhlbiB3ZSBqdXN0IGhhdmUgdGhlIElETEVfQkxPQ0tFUi5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlcktleSAhPT0gXCJcIikge1xuICAgICAgcm91dGVyLmdldEJsb2NrZXIoYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uKTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0pO1xuXG4gIC8vIFByZWZlciB0aGUgYmxvY2tlciBmcm9tIGBzdGF0ZWAgbm90IGByb3V0ZXIuc3RhdGVgIHNpbmNlIERhdGFSb3V0ZXJDb250ZXh0XG4gIC8vIGlzIG1lbW9pemVkIHNvIHRoaXMgZW5zdXJlcyB3ZSB1cGRhdGUgb24gYmxvY2tlciBzdGF0ZSB1cGRhdGVzXG4gIHJldHVybiBibG9ja2VyS2V5ICYmIHN0YXRlLmJsb2NrZXJzLmhhcyhibG9ja2VyS2V5KSA/IHN0YXRlLmJsb2NrZXJzLmdldChibG9ja2VyS2V5KSA6IElETEVfQkxPQ0tFUjtcbn1cblxuLyoqXG4gKiBTdGFibGUgdmVyc2lvbiBvZiB1c2VOYXZpZ2F0ZSB0aGF0IGlzIHVzZWQgd2hlbiB3ZSBhcmUgaW4gdGhlIGNvbnRleHQgb2ZcbiAqIGEgUm91dGVyUHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlU3RhYmxlKCkge1xuICBsZXQge1xuICAgIHJvdXRlclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlTmF2aWdhdGVTdGFibGUpO1xuICBsZXQgaWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZU5hdmlnYXRlU3RhYmxlKTtcbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0bywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoYWN0aXZlUmVmLmN1cnJlbnQsIG5hdmlnYXRlRWZmZWN0V2FybmluZykgOiB2b2lkIDA7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGhlcmUgc2luY2UgaWYgdGhpcyBoYXBwZW5zIG9uIGZpcnN0IHJlbmRlciB0aGUgbmF2aWdhdGVcbiAgICAvLyBpcyB1c2VsZXNzIGJlY2F1c2Ugd2UgaGF2ZW4ndCB3aXJlZCB1cCBvdXIgcm91dGVyIHN1YnNjcmliZXIgeWV0XG4gICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0bywgX2V4dGVuZHMoe1xuICAgICAgICBmcm9tUm91dGVJZDogaWRcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGlkXSk7XG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cbmNvbnN0IGFscmVhZHlXYXJuZWQgPSB7fTtcbmZ1bmN0aW9uIHdhcm5pbmdPbmNlKGtleSwgY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQgJiYgIWFscmVhZHlXYXJuZWRba2V5XSkge1xuICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICBXZWJwYWNrICsgUmVhY3QgMTcgZmFpbHMgdG8gY29tcGlsZSBvbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBiZWNhdXNlIHdlYnBhY2tcbiAgY29tcGxhaW5zIHRoYXQgYHN0YXJ0VHJhbnNpdGlvbmAgZG9lc24ndCBleGlzdCBpbiBgUmVhY3RgOlxuICAqIGltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gXCJyZWFjdFwiXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0W1wic3RhcnRUcmFuc2l0aW9uXCJdKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gIE1vdmluZyBpdCB0byBhIGNvbnN0YW50IHN1Y2ggYXMgdGhlIGZvbGxvd2luZyBzb2x2ZXMgdGhlIFdlYnBhY2svUmVhY3QgMTcgaXNzdWU6XG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBjb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbiAgICBTVEFSVF9UUkFOU0lUSU9OIGluIFJlYWN0ID8gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgSG93ZXZlciwgdGhhdCBpbnRyb2R1Y2VzIHdlYnBhY2svdGVyc2VyIG1pbmlmaWNhdGlvbiBpc3N1ZXMgaW4gcHJvZHVjdGlvbiBidWlsZHNcbiAgaW4gUmVhY3QgMTggd2hlcmUgbWluaWZpY2F0aW9uL29iZnVzY2F0aW9uIGVuZHMgdXAgcmVtb3ZpbmcgdGhlIGNhbGwgb2ZcbiAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uIGVudGlyZWx5IGZyb20gdGhlIGZpcnN0IGhhbGYgb2YgdGhlIHRlcm5hcnkuICBHcmFiYmluZ1xuICB0aGlzIGV4cG9ydGVkIHJlZmVyZW5jZSBvbmNlIHVwIGZyb250IHJlc29sdmVzIHRoYXQgaXNzdWUuXG5cbiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy8xMDU3OVxuKi9cbmNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuY29uc3Qgc3RhcnRUcmFuc2l0aW9uSW1wbCA9IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dO1xuXG4vKipcbiAqIEdpdmVuIGEgUmVtaXggUm91dGVyIGluc3RhbmNlLCByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIFVJXG4gKi9cbmZ1bmN0aW9uIFJvdXRlclByb3ZpZGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBmYWxsYmFja0VsZW1lbnQsXG4gICAgcm91dGVyLFxuICAgIGZ1dHVyZVxuICB9ID0gX3JlZjtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHJvdXRlci5zdGF0ZSk7XG4gIGxldCB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXG4gIH0gPSBmdXR1cmUgfHwge307XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5ld1N0YXRlID0+IHtcbiAgICBpZiAodjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwpIHtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgfVxuICB9LCBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dKTtcblxuICAvLyBOZWVkIHRvIHVzZSBhIGxheW91dCBlZmZlY3QgaGVyZSBzbyB3ZSBhcmUgc3Vic2NyaWJlZCBlYXJseSBlbm91Z2ggdG9cbiAgLy8gcGljayB1cCBvbiBhbnkgcmVuZGVyLWRyaXZlbiByZWRpcmVjdHMvbmF2aWdhdGlvbnMgKHVzZUVmZmVjdC88TmF2aWdhdGU+KVxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gcm91dGVyLnN1YnNjcmliZShzZXRTdGF0ZSksIFtyb3V0ZXIsIHNldFN0YXRlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsbGJhY2tFbGVtZW50ID09IG51bGwgfHwgIXJvdXRlci5mdXR1cmUudjdfcGFydGlhbEh5ZHJhdGlvbiwgXCJgPFJvdXRlclByb3ZpZGVyIGZhbGxiYWNrRWxlbWVudD5gIGlzIGRlcHJlY2F0ZWQgd2hlbiB1c2luZyBcIiArIFwiYHY3X3BhcnRpYWxIeWRyYXRpb25gLCB1c2UgYSBgSHlkcmF0ZUZhbGxiYWNrYCBjb21wb25lbnQgaW5zdGVhZFwiKSA6IHZvaWQgMDtcbiAgICAvLyBPbmx5IGxvZyB0aGlzIG9uY2Ugb24gaW5pdGlhbCBtb3VudFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUhyZWY6IHJvdXRlci5jcmVhdGVIcmVmLFxuICAgICAgZW5jb2RlTG9jYXRpb246IHJvdXRlci5lbmNvZGVMb2NhdGlvbixcbiAgICAgIGdvOiBuID0+IHJvdXRlci5uYXZpZ2F0ZShuKSxcbiAgICAgIHB1c2g6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSksXG4gICAgICByZXBsYWNlOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pXG4gICAgfTtcbiAgfSwgW3JvdXRlcl0pO1xuICBsZXQgYmFzZW5hbWUgPSByb3V0ZXIuYmFzZW5hbWUgfHwgXCIvXCI7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByb3V0ZXIsXG4gICAgbmF2aWdhdG9yLFxuICAgIHN0YXRpYzogZmFsc2UsXG4gICAgYmFzZW5hbWVcbiAgfSksIFtyb3V0ZXIsIG5hdmlnYXRvciwgYmFzZW5hbWVdKTtcblxuICAvLyBUaGUgZnJhZ21lbnQgYW5kIHtudWxsfSBoZXJlIGFyZSBpbXBvcnRhbnQhICBXZSBuZWVkIHRoZW0gdG8ga2VlcCBSZWFjdCAxOCdzXG4gIC8vIHVzZUlkIGhhcHB5IHdoZW4gd2UgYXJlIHNlcnZlci1yZW5kZXJpbmcgc2luY2Ugd2UgbWF5IGhhdmUgYSA8c2NyaXB0PiBoZXJlXG4gIC8vIGNvbnRhaW5pbmcgdGhlIGh5ZHJhdGVkIHNlcnZlci1zaWRlIHN0YXRpY0NvbnRleHQgKGZyb20gU3RhdGljUm91dGVyUHJvdmlkZXIpLlxuICAvLyB1c2VJZCByZWxpZXMgb24gdGhlIGNvbXBvbmVudCB0cmVlIHN0cnVjdHVyZSB0byBnZW5lcmF0ZSBkZXRlcm1pbmlzdGljIGlkJ3NcbiAgLy8gc28gd2UgbmVlZCB0byBlbnN1cmUgaXQgcmVtYWlucyB0aGUgc2FtZSBvbiB0aGUgY2xpZW50IGV2ZW4gdGhvdWdoXG4gIC8vIHdlIGRvbid0IG5lZWQgdGhlIDxzY3JpcHQ+IHRhZ1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRhdGFSb3V0ZXJDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RhdGVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcixcbiAgICBmdXR1cmU6IHtcbiAgICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiByb3V0ZXIuZnV0dXJlLnY3X3JlbGF0aXZlU3BsYXRQYXRoXG4gICAgfVxuICB9LCBzdGF0ZS5pbml0aWFsaXplZCB8fCByb3V0ZXIuZnV0dXJlLnY3X3BhcnRpYWxIeWRyYXRpb24gPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEYXRhUm91dGVzLCB7XG4gICAgcm91dGVzOiByb3V0ZXIucm91dGVzLFxuICAgIGZ1dHVyZTogcm91dGVyLmZ1dHVyZSxcbiAgICBzdGF0ZTogc3RhdGVcbiAgfSkgOiBmYWxsYmFja0VsZW1lbnQpKSksIG51bGwpO1xufVxuZnVuY3Rpb24gRGF0YVJvdXRlcyhfcmVmMikge1xuICBsZXQge1xuICAgIHJvdXRlcyxcbiAgICBmdXR1cmUsXG4gICAgc3RhdGVcbiAgfSA9IF9yZWYyO1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIHVuZGVmaW5lZCwgc3RhdGUsIGZ1dHVyZSk7XG59XG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IHN0b3JlcyBhbGwgZW50cmllcyBpbiBtZW1vcnkuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXItY29tcG9uZW50cy9tZW1vcnktcm91dGVyXG4gKi9cbmZ1bmN0aW9uIE1lbW9yeVJvdXRlcihfcmVmMykge1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuLFxuICAgIGluaXRpYWxFbnRyaWVzLFxuICAgIGluaXRpYWxJbmRleCxcbiAgICBmdXR1cmVcbiAgfSA9IF9yZWYzO1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgdjVDb21wYXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnksXG4gICAgZnV0dXJlOiBmdXR1cmVcbiAgfSk7XG59XG4vKipcbiAqIENoYW5nZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogTm90ZTogVGhpcyBBUEkgaXMgbW9zdGx5IHVzZWZ1bCBpbiBSZWFjdC5Db21wb25lbnQgc3ViY2xhc3NlcyB0aGF0IGFyZSBub3RcbiAqIGFibGUgdG8gdXNlIGhvb2tzLiBJbiBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIHRoZVxuICogYHVzZU5hdmlnYXRlYCBob29rIGluc3RlYWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL25hdmlnYXRlXG4gKi9cbmZ1bmN0aW9uIE5hdmlnYXRlKF9yZWY0KSB7XG4gIGxldCB7XG4gICAgdG8sXG4gICAgcmVwbGFjZSxcbiAgICBzdGF0ZSxcbiAgICByZWxhdGl2ZVxuICB9ID0gX3JlZjQ7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwiPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIGZ1dHVyZSxcbiAgICBzdGF0aWM6IGlzU3RhdGljXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoIWlzU3RhdGljLCBcIjxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gXCIgKyBcIlRoaXMgaXMgYSBuby1vcCwgYnV0IHlvdSBzaG91bGQgbW9kaWZ5IHlvdXIgY29kZSBzbyB0aGUgPE5hdmlnYXRlPiBpcyBcIiArIFwib25seSBldmVyIHJlbmRlcmVkIGluIHJlc3BvbnNlIHRvIHNvbWUgdXNlciBpbnRlcmFjdGlvbiBvciBzdGF0ZSBjaGFuZ2UuXCIpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIG1hdGNoZXNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcblxuICAvLyBSZXNvbHZlIHRoZSBwYXRoIG91dHNpZGUgb2YgdGhlIGVmZmVjdCBzbyB0aGF0IHdoZW4gZWZmZWN0cyBydW4gdHdpY2UgaW5cbiAgLy8gU3RyaWN0TW9kZSB0aGV5IG5hdmlnYXRlIHRvIHRoZSBzYW1lIHBsYWNlXG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKHRvLCBVTlNBRkVfZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzLCBmdXR1cmUudjdfcmVsYXRpdmVTcGxhdFBhdGgpLCBsb2NhdGlvblBhdGhuYW1lLCByZWxhdGl2ZSA9PT0gXCJwYXRoXCIpO1xuICBsZXQganNvblBhdGggPSBKU09OLnN0cmluZ2lmeShwYXRoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IG5hdmlnYXRlKEpTT04ucGFyc2UoanNvblBhdGgpLCB7XG4gICAgcmVwbGFjZSxcbiAgICBzdGF0ZSxcbiAgICByZWxhdGl2ZVxuICB9KSwgW25hdmlnYXRlLCBqc29uUGF0aCwgcmVsYXRpdmUsIHJlcGxhY2UsIHN0YXRlXSk7XG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBSZW5kZXJzIHRoZSBjaGlsZCByb3V0ZSdzIGVsZW1lbnQsIGlmIHRoZXJlIGlzIG9uZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvb3V0bGV0XG4gKi9cbmZ1bmN0aW9uIE91dGxldChwcm9wcykge1xuICByZXR1cm4gdXNlT3V0bGV0KHByb3BzLmNvbnRleHQpO1xufVxuLyoqXG4gKiBEZWNsYXJlcyBhbiBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkIGF0IGEgY2VydGFpbiBVUkwgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2NvbXBvbmVudHMvcm91dGVcbiAqL1xuZnVuY3Rpb24gUm91dGUoX3Byb3BzKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiQSA8Um91dGU+IGlzIG9ubHkgZXZlciB0byBiZSB1c2VkIGFzIHRoZSBjaGlsZCBvZiA8Um91dGVzPiBlbGVtZW50LCBcIiArIFwibmV2ZXIgcmVuZGVyZWQgZGlyZWN0bHkuIFBsZWFzZSB3cmFwIHlvdXIgPFJvdXRlPiBpbiBhIDxSb3V0ZXM+LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDtcbn1cbi8qKlxuICogUHJvdmlkZXMgbG9jYXRpb24gY29udGV4dCBmb3IgdGhlIHJlc3Qgb2YgdGhlIGFwcC5cbiAqXG4gKiBOb3RlOiBZb3UgdXN1YWxseSB3b24ndCByZW5kZXIgYSBgPFJvdXRlcj5gIGRpcmVjdGx5LiBJbnN0ZWFkLCB5b3UnbGwgcmVuZGVyIGFcbiAqIHJvdXRlciB0aGF0IGlzIG1vcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudCBzdWNoIGFzIGEgYDxCcm93c2VyUm91dGVyPmBcbiAqIGluIHdlYiBicm93c2VycyBvciBhIGA8U3RhdGljUm91dGVyPmAgZm9yIHNlcnZlciByZW5kZXJpbmcuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXItY29tcG9uZW50cy9yb3V0ZXJcbiAqL1xuZnVuY3Rpb24gUm91dGVyKF9yZWY1KSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lUHJvcCA9IFwiL1wiLFxuICAgIGNoaWxkcmVuID0gbnVsbCxcbiAgICBsb2NhdGlvbjogbG9jYXRpb25Qcm9wLFxuICAgIG5hdmlnYXRpb25UeXBlID0gQWN0aW9uLlBvcCxcbiAgICBuYXZpZ2F0b3IsXG4gICAgc3RhdGljOiBzdGF0aWNQcm9wID0gZmFsc2UsXG4gICAgZnV0dXJlXG4gIH0gPSBfcmVmNTtcbiAgISF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiWW91IGNhbm5vdCByZW5kZXIgYSA8Um91dGVyPiBpbnNpZGUgYW5vdGhlciA8Um91dGVyPi5cIiArIFwiIFlvdSBzaG91bGQgbmV2ZXIgaGF2ZSBtb3JlIHRoYW4gb25lIGluIHlvdXIgYXBwLlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIC8vIFByZXNlcnZlIHRyYWlsaW5nIHNsYXNoZXMgb24gYmFzZW5hbWUsIHNvIHdlIGNhbiBsZXQgdGhlIHVzZXIgY29udHJvbFxuICAvLyB0aGUgZW5mb3JjZW1lbnQgb2YgdHJhaWxpbmcgc2xhc2hlcyB0aHJvdWdob3V0IHRoZSBhcHBcbiAgbGV0IGJhc2VuYW1lID0gYmFzZW5hbWVQcm9wLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuICBsZXQgbmF2aWdhdGlvbkNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgYmFzZW5hbWUsXG4gICAgbmF2aWdhdG9yLFxuICAgIHN0YXRpYzogc3RhdGljUHJvcCxcbiAgICBmdXR1cmU6IF9leHRlbmRzKHtcbiAgICAgIHY3X3JlbGF0aXZlU3BsYXRQYXRoOiBmYWxzZVxuICAgIH0sIGZ1dHVyZSlcbiAgfSksIFtiYXNlbmFtZSwgZnV0dXJlLCBuYXZpZ2F0b3IsIHN0YXRpY1Byb3BdKTtcbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuICBsZXQge1xuICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIixcbiAgICBzdGF0ZSA9IG51bGwsXG4gICAga2V5ID0gXCJkZWZhdWx0XCJcbiAgfSA9IGxvY2F0aW9uUHJvcDtcbiAgbGV0IGxvY2F0aW9uQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCB0cmFpbGluZ1BhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShwYXRobmFtZSwgYmFzZW5hbWUpO1xuICAgIGlmICh0cmFpbGluZ1BhdGhuYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgcGF0aG5hbWU6IHRyYWlsaW5nUGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCxcbiAgICAgICAgaGFzaCxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGtleVxuICAgICAgfSxcbiAgICAgIG5hdmlnYXRpb25UeXBlXG4gICAgfTtcbiAgfSwgW2Jhc2VuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBzdGF0ZSwga2V5LCBuYXZpZ2F0aW9uVHlwZV0pO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhsb2NhdGlvbkNvbnRleHQgIT0gbnVsbCwgXCI8Um91dGVyIGJhc2VuYW1lPVxcXCJcIiArIGJhc2VuYW1lICsgXCJcXFwiPiBpcyBub3QgYWJsZSB0byBtYXRjaCB0aGUgVVJMIFwiICsgKFwiXFxcIlwiICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoICsgXCJcXFwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgXCIpICsgXCJiYXNlbmFtZSwgc28gdGhlIDxSb3V0ZXI+IHdvbid0IHJlbmRlciBhbnl0aGluZy5cIikgOiB2b2lkIDA7XG4gIGlmIChsb2NhdGlvbkNvbnRleHQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChOYXZpZ2F0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBuYXZpZ2F0aW9uQ29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgdmFsdWU6IGxvY2F0aW9uQ29udGV4dFxuICB9KSk7XG59XG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBhIG5lc3RlZCB0cmVlIG9mIGA8Um91dGU+YCBlbGVtZW50cyB0aGF0IHJlbmRlcnMgdGhlIGJyYW5jaFxuICogdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL3JvdXRlc1xuICovXG5mdW5jdGlvbiBSb3V0ZXMoX3JlZjYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBsb2NhdGlvblxuICB9ID0gX3JlZjY7XG4gIHJldHVybiB1c2VSb3V0ZXMoY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuKSwgbG9jYXRpb24pO1xufVxuLyoqXG4gKiBDb21wb25lbnQgdG8gdXNlIGZvciByZW5kZXJpbmcgbGF6aWx5IGxvYWRlZCBkYXRhIGZyb20gcmV0dXJuaW5nIGRlZmVyKClcbiAqIGluIGEgbG9hZGVyIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIEF3YWl0KF9yZWY3KSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZXJyb3JFbGVtZW50LFxuICAgIHJlc29sdmVcbiAgfSA9IF9yZWY3O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXdhaXRFcnJvckJvdW5kYXJ5LCB7XG4gICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICBlcnJvckVsZW1lbnQ6IGVycm9yRWxlbWVudFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZXNvbHZlQXdhaXQsIG51bGwsIGNoaWxkcmVuKSk7XG59XG52YXIgQXdhaXRSZW5kZXJTdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEF3YWl0UmVuZGVyU3RhdHVzKSB7XG4gIEF3YWl0UmVuZGVyU3RhdHVzW0F3YWl0UmVuZGVyU3RhdHVzW1wicGVuZGluZ1wiXSA9IDBdID0gXCJwZW5kaW5nXCI7XG4gIEF3YWl0UmVuZGVyU3RhdHVzW0F3YWl0UmVuZGVyU3RhdHVzW1wic3VjY2Vzc1wiXSA9IDFdID0gXCJzdWNjZXNzXCI7XG4gIEF3YWl0UmVuZGVyU3RhdHVzW0F3YWl0UmVuZGVyU3RhdHVzW1wiZXJyb3JcIl0gPSAyXSA9IFwiZXJyb3JcIjtcbiAgcmV0dXJuIEF3YWl0UmVuZGVyU3RhdHVzO1xufShBd2FpdFJlbmRlclN0YXR1cyB8fCB7fSk7XG5jb25zdCBuZXZlclNldHRsZWRQcm9taXNlID0gbmV3IFByb21pc2UoKCkgPT4ge30pO1xuY2xhc3MgQXdhaXRFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgY29uc29sZS5lcnJvcihcIjxBd2FpdD4gY2F1Z2h0IHRoZSBmb2xsb3dpbmcgZXJyb3IgZHVyaW5nIHJlbmRlclwiLCBlcnJvciwgZXJyb3JJbmZvKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgbGV0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZXJyb3JFbGVtZW50LFxuICAgICAgcmVzb2x2ZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBwcm9taXNlID0gbnVsbDtcbiAgICBsZXQgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICBpZiAoIShyZXNvbHZlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgIC8vIERpZG4ndCBnZXQgYSBwcm9taXNlIC0gcHJvdmlkZSBhcyBhIHJlc29sdmVkIHByb21pc2VcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3M7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZGF0YVwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gcmVzb2x2ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICAvLyBDYXVnaHQgYSByZW5kZXIgZXJyb3IsIHByb3ZpZGUgaXQgYXMgYSByZWplY3RlZCBwcm9taXNlXG4gICAgICBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvcjtcbiAgICAgIGxldCByZW5kZXJFcnJvciA9IHRoaXMuc3RhdGUuZXJyb3I7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoKS5jYXRjaCgoKSA9PiB7fSk7IC8vIEF2b2lkIHVuaGFuZGxlZCByZWplY3Rpb24gd2FybmluZ3NcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gcmVuZGVyRXJyb3JcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZS5fdHJhY2tlZCkge1xuICAgICAgLy8gQWxyZWFkeSB0cmFja2VkIHByb21pc2UgLSBjaGVjayBjb250ZW50c1xuICAgICAgcHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICBzdGF0dXMgPSBwcm9taXNlLl9lcnJvciAhPT0gdW5kZWZpbmVkID8gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IgOiBwcm9taXNlLl9kYXRhICE9PSB1bmRlZmluZWQgPyBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzIDogQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmF3ICh1bnRyYWNrZWQpIHByb21pc2UgLSB0cmFjayBpdFxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMucGVuZGluZztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl90cmFja2VkXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHByb21pc2UgPSByZXNvbHZlLnRoZW4oZGF0YSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZGF0YVwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gZGF0YVxuICAgICAgfSksIGVycm9yID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9lcnJvclwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gZXJyb3JcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IgJiYgcHJvbWlzZS5fZXJyb3IgaW5zdGFuY2VvZiBBYm9ydGVkRGVmZXJyZWRFcnJvcikge1xuICAgICAgLy8gRnJlZXplIHRoZSBVSSBieSB0aHJvd2luZyBhIG5ldmVyIHJlc29sdmVkIHByb21pc2VcbiAgICAgIHRocm93IG5ldmVyU2V0dGxlZFByb21pc2U7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yICYmICFlcnJvckVsZW1lbnQpIHtcbiAgICAgIC8vIE5vIGVycm9yRWxlbWVudCwgdGhyb3cgdG8gdGhlIG5lYXJlc3Qgcm91dGUtbGV2ZWwgZXJyb3IgYm91bmRhcnlcbiAgICAgIHRocm93IHByb21pc2UuX2Vycm9yO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvcikge1xuICAgICAgLy8gUmVuZGVyIHZpYSBvdXIgZXJyb3JFbGVtZW50XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXdhaXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBwcm9taXNlLFxuICAgICAgICBjaGlsZHJlbjogZXJyb3JFbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2Vzcykge1xuICAgICAgLy8gUmVuZGVyIGNoaWxkcmVuIHdpdGggcmVzb2x2ZWQgdmFsdWVcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBd2FpdENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHByb21pc2UsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVGhyb3cgdG8gdGhlIHN1c3BlbnNlIGJvdW5kYXJ5XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBJbmRpcmVjdGlvbiB0byBsZXZlcmFnZSB1c2VBc3luY1ZhbHVlIGZvciBhIHJlbmRlci1wcm9wIEFQSSBvbiBgPEF3YWl0PmBcbiAqL1xuZnVuY3Rpb24gUmVzb2x2ZUF3YWl0KF9yZWY4KSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY4O1xuICBsZXQgZGF0YSA9IHVzZUFzeW5jVmFsdWUoKTtcbiAgbGV0IHRvUmVuZGVyID0gdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihkYXRhKSA6IGNoaWxkcmVuO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHRvUmVuZGVyKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVVRJTFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDcmVhdGVzIGEgcm91dGUgY29uZmlnIGZyb20gYSBSZWFjdCBcImNoaWxkcmVuXCIgb2JqZWN0LCB3aGljaCBpcyB1c3VhbGx5XG4gKiBlaXRoZXIgYSBgPFJvdXRlPmAgZWxlbWVudCBvciBhbiBhcnJheSBvZiB0aGVtLiBVc2VkIGludGVybmFsbHkgYnlcbiAqIGA8Um91dGVzPmAgdG8gY3JlYXRlIGEgcm91dGUgY29uZmlnIGZyb20gaXRzIGNoaWxkcmVuLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vdXRpbHMvY3JlYXRlLXJvdXRlcy1mcm9tLWNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50UGF0aCkge1xuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50UGF0aCA9IFtdO1xuICB9XG4gIGxldCByb3V0ZXMgPSBbXTtcbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgaWYgKCEgLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAvLyBJZ25vcmUgbm9uLWVsZW1lbnRzLiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gbW9yZSBlYXNpbHkgaW5saW5lXG4gICAgICAvLyBjb25kaXRpb25hbHMgaW4gdGhlaXIgcm91dGUgY29uZmlnLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdHJlZVBhdGggPSBbLi4ucGFyZW50UGF0aCwgaW5kZXhdO1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgICAvLyBUcmFuc3BhcmVudGx5IHN1cHBvcnQgUmVhY3QuRnJhZ21lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgIHJvdXRlcy5wdXNoLmFwcGx5KHJvdXRlcywgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHRyZWVQYXRoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEoZWxlbWVudC50eXBlID09PSBSb3V0ZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIltcIiArICh0eXBlb2YgZWxlbWVudC50eXBlID09PSBcInN0cmluZ1wiID8gZWxlbWVudC50eXBlIDogZWxlbWVudC50eXBlLm5hbWUpICsgXCJdIGlzIG5vdCBhIDxSb3V0ZT4gY29tcG9uZW50LiBBbGwgY29tcG9uZW50IGNoaWxkcmVuIG9mIDxSb3V0ZXM+IG11c3QgYmUgYSA8Um91dGU+IG9yIDxSZWFjdC5GcmFnbWVudD5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAhKCFlbGVtZW50LnByb3BzLmluZGV4IHx8ICFlbGVtZW50LnByb3BzLmNoaWxkcmVuKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiQW4gaW5kZXggcm91dGUgY2Fubm90IGhhdmUgY2hpbGQgcm91dGVzLlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGxldCByb3V0ZSA9IHtcbiAgICAgIGlkOiBlbGVtZW50LnByb3BzLmlkIHx8IHRyZWVQYXRoLmpvaW4oXCItXCIpLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogZWxlbWVudC5wcm9wcy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgZWxlbWVudDogZWxlbWVudC5wcm9wcy5lbGVtZW50LFxuICAgICAgQ29tcG9uZW50OiBlbGVtZW50LnByb3BzLkNvbXBvbmVudCxcbiAgICAgIGluZGV4OiBlbGVtZW50LnByb3BzLmluZGV4LFxuICAgICAgcGF0aDogZWxlbWVudC5wcm9wcy5wYXRoLFxuICAgICAgbG9hZGVyOiBlbGVtZW50LnByb3BzLmxvYWRlcixcbiAgICAgIGFjdGlvbjogZWxlbWVudC5wcm9wcy5hY3Rpb24sXG4gICAgICBlcnJvckVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50LFxuICAgICAgRXJyb3JCb3VuZGFyeTogZWxlbWVudC5wcm9wcy5FcnJvckJvdW5kYXJ5LFxuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogZWxlbWVudC5wcm9wcy5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQgIT0gbnVsbCxcbiAgICAgIHNob3VsZFJldmFsaWRhdGU6IGVsZW1lbnQucHJvcHMuc2hvdWxkUmV2YWxpZGF0ZSxcbiAgICAgIGhhbmRsZTogZWxlbWVudC5wcm9wcy5oYW5kbGUsXG4gICAgICBsYXp5OiBlbGVtZW50LnByb3BzLmxhenlcbiAgICB9O1xuICAgIGlmIChlbGVtZW50LnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICByb3V0ZS5jaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuLCB0cmVlUGF0aCk7XG4gICAgfVxuICAgIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgfSk7XG4gIHJldHVybiByb3V0ZXM7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgcmVzdWx0IG9mIGBtYXRjaFJvdXRlcygpYCBpbnRvIGEgUmVhY3QgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKTtcbn1cblxuZnVuY3Rpb24gbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSB7XG4gIGxldCB1cGRhdGVzID0ge1xuICAgIC8vIE5vdGU6IHRoaXMgY2hlY2sgYWxzbyBvY2N1cnMgaW4gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIHNvIHVwZGF0ZVxuICAgIC8vIHRoZXJlIGlmIHlvdSBjaGFuZ2UgdGhpcyAtLSBwbGVhc2UgYW5kIHRoYW5rIHlvdSFcbiAgICBoYXNFcnJvckJvdW5kYXJ5OiByb3V0ZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgcm91dGUuZXJyb3JFbGVtZW50ICE9IG51bGxcbiAgfTtcbiAgaWYgKHJvdXRlLkNvbXBvbmVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChyb3V0ZS5lbGVtZW50KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgQ29tcG9uZW50YCBhbmQgYGVsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBcIiArIFwiYENvbXBvbmVudGAgd2lsbCBiZSB1c2VkLlwiKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBlbGVtZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChyb3V0ZS5Db21wb25lbnQpLFxuICAgICAgQ29tcG9uZW50OiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICBpZiAocm91dGUuSHlkcmF0ZUZhbGxiYWNrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBIeWRyYXRlRmFsbGJhY2tgIGFuZCBgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudGAgb24geW91ciByb3V0ZSAtIFwiICsgXCJgSHlkcmF0ZUZhbGxiYWNrYCB3aWxsIGJlIHVzZWQuXCIpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGh5ZHJhdGVGYWxsYmFja0VsZW1lbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHJvdXRlLkh5ZHJhdGVGYWxsYmFjayksXG4gICAgICBIeWRyYXRlRmFsbGJhY2s6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG4gIGlmIChyb3V0ZS5FcnJvckJvdW5kYXJ5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHJvdXRlLmVycm9yRWxlbWVudCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYEVycm9yQm91bmRhcnlgIGFuZCBgZXJyb3JFbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gXCIgKyBcImBFcnJvckJvdW5kYXJ5YCB3aWxsIGJlIHVzZWQuXCIpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHVwZGF0ZXMsIHtcbiAgICAgIGVycm9yRWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuRXJyb3JCb3VuZGFyeSksXG4gICAgICBFcnJvckJvdW5kYXJ5OiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdXBkYXRlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeVJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYmFzZW5hbWUsXG4gICAgZnV0dXJlOiBfZXh0ZW5kcyh7fSwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mdXR1cmUsIHtcbiAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxuICAgIH0pLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgaW5pdGlhbEVudHJpZXM6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsSW5kZXg6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaW5pdGlhbEluZGV4XG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5oeWRyYXRpb25EYXRhLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXNcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuXG5leHBvcnQgeyBBd2FpdCwgTWVtb3J5Um91dGVyLCBOYXZpZ2F0ZSwgT3V0bGV0LCBSb3V0ZSwgUm91dGVyLCBSb3V0ZXJQcm92aWRlciwgUm91dGVzLCBEYXRhUm91dGVyQ29udGV4dCBhcyBVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQsIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgYXMgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsIExvY2F0aW9uQ29udGV4dCBhcyBVTlNBRkVfTG9jYXRpb25Db250ZXh0LCBOYXZpZ2F0aW9uQ29udGV4dCBhcyBVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQsIFJvdXRlQ29udGV4dCBhcyBVTlNBRkVfUm91dGVDb250ZXh0LCBtYXBSb3V0ZVByb3BlcnRpZXMgYXMgVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcywgdXNlUm91dGVJZCBhcyBVTlNBRkVfdXNlUm91dGVJZCwgdXNlUm91dGVzSW1wbCBhcyBVTlNBRkVfdXNlUm91dGVzSW1wbCwgY3JlYXRlTWVtb3J5Um91dGVyLCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiBhcyBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMsIHJlbmRlck1hdGNoZXMsIHVzZUFjdGlvbkRhdGEsIHVzZUFzeW5jRXJyb3IsIHVzZUFzeW5jVmFsdWUsIHVzZUJsb2NrZXIsIHVzZUhyZWYsIHVzZUluUm91dGVyQ29udGV4dCwgdXNlTG9hZGVyRGF0YSwgdXNlTG9jYXRpb24sIHVzZU1hdGNoLCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvbiwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVJldmFsaWRhdG9yLCB1c2VSb3V0ZUVycm9yLCB1c2VSb3V0ZUxvYWRlckRhdGEsIHVzZVJvdXRlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJVTlNBRkVfaW52YXJpYW50Iiwiam9pblBhdGhzIiwibWF0Y2hQYXRoIiwiVU5TQUZFX2dldFJlc29sdmVUb01hdGNoZXMiLCJVTlNBRkVfd2FybmluZyIsInJlc29sdmVUbyIsInBhcnNlUGF0aCIsIm1hdGNoUm91dGVzIiwiQWN0aW9uIiwiVU5TQUZFX2NvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIiwic3RyaXBCYXNlbmFtZSIsIklETEVfQkxPQ0tFUiIsImlzUm91dGVFcnJvclJlc3BvbnNlIiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiY3JlYXRlUm91dGVyIiwiTmF2aWdhdGlvblR5cGUiLCJjcmVhdGVQYXRoIiwiZGVmZXIiLCJnZW5lcmF0ZVBhdGgiLCJqc29uIiwicmVkaXJlY3QiLCJyZWRpcmVjdERvY3VtZW50IiwicmVzb2x2ZVBhdGgiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJEYXRhUm91dGVyQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiLCJEYXRhUm91dGVyU3RhdGVDb250ZXh0IiwiQXdhaXRDb250ZXh0IiwiTmF2aWdhdGlvbkNvbnRleHQiLCJMb2NhdGlvbkNvbnRleHQiLCJSb3V0ZUNvbnRleHQiLCJvdXRsZXQiLCJtYXRjaGVzIiwiaXNEYXRhUm91dGUiLCJSb3V0ZUVycm9yQ29udGV4dCIsInVzZUhyZWYiLCJ0byIsIl90ZW1wIiwicmVsYXRpdmUiLCJ1c2VJblJvdXRlckNvbnRleHQiLCJiYXNlbmFtZSIsIm5hdmlnYXRvciIsInVzZUNvbnRleHQiLCJoYXNoIiwicGF0aG5hbWUiLCJzZWFyY2giLCJ1c2VSZXNvbHZlZFBhdGgiLCJqb2luZWRQYXRobmFtZSIsImNyZWF0ZUhyZWYiLCJ1c2VMb2NhdGlvbiIsImxvY2F0aW9uIiwidXNlTmF2aWdhdGlvblR5cGUiLCJuYXZpZ2F0aW9uVHlwZSIsInVzZU1hdGNoIiwicGF0dGVybiIsInVzZU1lbW8iLCJuYXZpZ2F0ZUVmZmVjdFdhcm5pbmciLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiY2IiLCJpc1N0YXRpYyIsInN0YXRpYyIsInVzZUxheW91dEVmZmVjdCIsInVzZU5hdmlnYXRlIiwidXNlTmF2aWdhdGVTdGFibGUiLCJ1c2VOYXZpZ2F0ZVVuc3RhYmxlIiwiZGF0YVJvdXRlckNvbnRleHQiLCJmdXR1cmUiLCJsb2NhdGlvblBhdGhuYW1lIiwicm91dGVQYXRobmFtZXNKc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsInY3X3JlbGF0aXZlU3BsYXRQYXRoIiwiYWN0aXZlUmVmIiwidXNlUmVmIiwiY3VycmVudCIsIm5hdmlnYXRlIiwidXNlQ2FsbGJhY2siLCJvcHRpb25zIiwiZ28iLCJwYXRoIiwicGFyc2UiLCJyZXBsYWNlIiwicHVzaCIsInN0YXRlIiwiT3V0bGV0Q29udGV4dCIsInVzZU91dGxldENvbnRleHQiLCJ1c2VPdXRsZXQiLCJjb250ZXh0IiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VQYXJhbXMiLCJyb3V0ZU1hdGNoIiwicGFyYW1zIiwiX3RlbXAyIiwidXNlUm91dGVzIiwicm91dGVzIiwibG9jYXRpb25BcmciLCJ1c2VSb3V0ZXNJbXBsIiwiZGF0YVJvdXRlclN0YXRlIiwicGFyZW50TWF0Y2hlcyIsInBhcmVudFBhcmFtcyIsInBhcmVudFBhdGhuYW1lIiwicGFyZW50UGF0aG5hbWVCYXNlIiwicGF0aG5hbWVCYXNlIiwicGFyZW50Um91dGUiLCJyb3V0ZSIsInBhcmVudFBhdGgiLCJ3YXJuaW5nT25jZSIsImVuZHNXaXRoIiwibG9jYXRpb25Gcm9tQ29udGV4dCIsIl9wYXJzZWRMb2NhdGlvbkFyZyRwYSIsInBhcnNlZExvY2F0aW9uQXJnIiwic3RhcnRzV2l0aCIsInJlbWFpbmluZ1BhdGhuYW1lIiwic2xpY2UiLCJlbGVtZW50IiwidW5kZWZpbmVkIiwiQ29tcG9uZW50IiwibGF6eSIsInJlbmRlcmVkTWF0Y2hlcyIsIl9yZW5kZXJNYXRjaGVzIiwibWFwIiwibWF0Y2giLCJlbmNvZGVMb2NhdGlvbiIsIlBvcCIsIkRlZmF1bHRFcnJvckNvbXBvbmVudCIsImVycm9yIiwidXNlUm91dGVFcnJvciIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiRXJyb3IiLCJzdGFjayIsImxpZ2h0Z3JleSIsInByZVN0eWxlcyIsInBhZGRpbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2RlU3R5bGVzIiwiZGV2SW5mbyIsImNvbnNvbGUiLCJGcmFnbWVudCIsInN0eWxlIiwiZm9udFN0eWxlIiwiZGVmYXVsdEVycm9yRWxlbWVudCIsIlJlbmRlckVycm9yQm91bmRhcnkiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJwcm9wcyIsInJldmFsaWRhdGlvbiIsImNvbXBvbmVudERpZENhdGNoIiwiZXJyb3JJbmZvIiwicmVuZGVyIiwicm91dGVDb250ZXh0IiwiY2hpbGRyZW4iLCJjb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsIlJlbmRlcmVkUm91dGUiLCJfcmVmIiwic3RhdGljQ29udGV4dCIsImVycm9yRWxlbWVudCIsIkVycm9yQm91bmRhcnkiLCJfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCIsImlkIiwiX2RhdGFSb3V0ZXJTdGF0ZTIiLCJfZGF0YVJvdXRlclN0YXRlIiwiZXJyb3JzIiwiZXJyb3JJbmRleCIsImZpbmRJbmRleCIsIm0iLCJrZXlzIiwiam9pbiIsIk1hdGgiLCJtaW4iLCJyZW5kZXJGYWxsYmFjayIsImZhbGxiYWNrSW5kZXgiLCJ2N19wYXJ0aWFsSHlkcmF0aW9uIiwiSHlkcmF0ZUZhbGxiYWNrIiwiaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCIsImxvYWRlckRhdGEiLCJuZWVkc1RvUnVuTG9hZGVyIiwibG9hZGVyIiwicmVkdWNlUmlnaHQiLCJpbmRleCIsInNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayIsImNvbmNhdCIsImdldENoaWxkcmVuIiwiRGF0YVJvdXRlckhvb2siLCJEYXRhUm91dGVyU3RhdGVIb29rIiwiZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvciIsImhvb2tOYW1lIiwidXNlRGF0YVJvdXRlckNvbnRleHQiLCJjdHgiLCJ1c2VEYXRhUm91dGVyU3RhdGUiLCJ1c2VSb3V0ZUNvbnRleHQiLCJ1c2VDdXJyZW50Um91dGVJZCIsInRoaXNSb3V0ZSIsInVzZVJvdXRlSWQiLCJVc2VSb3V0ZUlkIiwidXNlTmF2aWdhdGlvbiIsIlVzZU5hdmlnYXRpb24iLCJuYXZpZ2F0aW9uIiwidXNlUmV2YWxpZGF0b3IiLCJVc2VSZXZhbGlkYXRvciIsInJldmFsaWRhdGUiLCJyb3V0ZXIiLCJ1c2VNYXRjaGVzIiwiVXNlTWF0Y2hlcyIsInVzZUxvYWRlckRhdGEiLCJVc2VMb2FkZXJEYXRhIiwicm91dGVJZCIsInVzZVJvdXRlTG9hZGVyRGF0YSIsIlVzZVJvdXRlTG9hZGVyRGF0YSIsInVzZUFjdGlvbkRhdGEiLCJVc2VBY3Rpb25EYXRhIiwiYWN0aW9uRGF0YSIsIl9zdGF0ZSRlcnJvcnMiLCJVc2VSb3V0ZUVycm9yIiwidXNlQXN5bmNWYWx1ZSIsIl9kYXRhIiwidXNlQXN5bmNFcnJvciIsIl9lcnJvciIsImJsb2NrZXJJZCIsInVzZUJsb2NrZXIiLCJzaG91bGRCbG9jayIsIlVzZUJsb2NrZXIiLCJibG9ja2VyS2V5Iiwic2V0QmxvY2tlcktleSIsInVzZVN0YXRlIiwiYmxvY2tlckZ1bmN0aW9uIiwiYXJnIiwiY3VycmVudExvY2F0aW9uIiwibmV4dExvY2F0aW9uIiwiaGlzdG9yeUFjdGlvbiIsInVzZUVmZmVjdCIsIlN0cmluZyIsImRlbGV0ZUJsb2NrZXIiLCJnZXRCbG9ja2VyIiwiYmxvY2tlcnMiLCJoYXMiLCJnZXQiLCJVc2VOYXZpZ2F0ZVN0YWJsZSIsImZyb21Sb3V0ZUlkIiwiYWxyZWFkeVdhcm5lZCIsImNvbmQiLCJTVEFSVF9UUkFOU0lUSU9OIiwic3RhcnRUcmFuc2l0aW9uSW1wbCIsIlJvdXRlclByb3ZpZGVyIiwiZmFsbGJhY2tFbGVtZW50Iiwic2V0U3RhdGVJbXBsIiwidjdfc3RhcnRUcmFuc2l0aW9uIiwic2V0U3RhdGUiLCJuZXdTdGF0ZSIsInN1YnNjcmliZSIsIm4iLCJvcHRzIiwicHJldmVudFNjcm9sbFJlc2V0IiwiUm91dGVyIiwiaW5pdGlhbGl6ZWQiLCJEYXRhUm91dGVzIiwiX3JlZjIiLCJNZW1vcnlSb3V0ZXIiLCJfcmVmMyIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwiaGlzdG9yeVJlZiIsInY1Q29tcGF0IiwiaGlzdG9yeSIsImFjdGlvbiIsImxpc3RlbiIsIk5hdmlnYXRlIiwiX3JlZjQiLCJqc29uUGF0aCIsIk91dGxldCIsIlJvdXRlIiwiX3Byb3BzIiwiX3JlZjUiLCJiYXNlbmFtZVByb3AiLCJsb2NhdGlvblByb3AiLCJzdGF0aWNQcm9wIiwibmF2aWdhdGlvbkNvbnRleHQiLCJsb2NhdGlvbkNvbnRleHQiLCJ0cmFpbGluZ1BhdGhuYW1lIiwiUm91dGVzIiwiX3JlZjYiLCJjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4iLCJBd2FpdCIsIl9yZWY3IiwicmVzb2x2ZSIsIkF3YWl0RXJyb3JCb3VuZGFyeSIsIlJlc29sdmVBd2FpdCIsIkF3YWl0UmVuZGVyU3RhdHVzIiwibmV2ZXJTZXR0bGVkUHJvbWlzZSIsIlByb21pc2UiLCJwcm9taXNlIiwicGVuZGluZyIsInN1Y2Nlc3MiLCJkZWZpbmVQcm9wZXJ0eSIsInJlbmRlckVycm9yIiwicmVqZWN0IiwiY2F0Y2giLCJfdHJhY2tlZCIsInRoZW4iLCJkYXRhIiwiX3JlZjgiLCJ0b1JlbmRlciIsIkNoaWxkcmVuIiwiZm9yRWFjaCIsImlzVmFsaWRFbGVtZW50IiwidHJlZVBhdGgiLCJ0eXBlIiwibmFtZSIsImNhc2VTZW5zaXRpdmUiLCJoYXNFcnJvckJvdW5kYXJ5Iiwic2hvdWxkUmV2YWxpZGF0ZSIsImhhbmRsZSIsInJlbmRlck1hdGNoZXMiLCJtYXBSb3V0ZVByb3BlcnRpZXMiLCJ1cGRhdGVzIiwiY3JlYXRlTWVtb3J5Um91dGVyIiwidjdfcHJlcGVuZEJhc2VuYW1lIiwiaHlkcmF0aW9uRGF0YSIsImluaXRpYWxpemUiLCJVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQiLCJVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsIlVOU0FGRV9Mb2NhdGlvbkNvbnRleHQiLCJVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQiLCJVTlNBRkVfUm91dGVDb250ZXh0IiwiVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyIsIlVOU0FGRV91c2VSb3V0ZUlkIiwiVU5TQUZFX3VzZVJvdXRlc0ltcGwiLCJjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-router/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/(auth)/onboarding/page.tsx":
/*!****************************************!*\
  !*** ./app/(auth)/onboarding/page.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_hook_form__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-hook-form */ \"(app-pages-browser)/./node_modules/react-hook-form/dist/index.esm.mjs\");\n/* harmony import */ var web3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! web3 */ \"(app-pages-browser)/./node_modules/web3/lib/esm/index.js\");\n/* harmony import */ var _constants_global__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/constants/global */ \"(app-pages-browser)/./constants/global.ts\");\n/* harmony import */ var _constants_contractABI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/constants/contractABI */ \"(app-pages-browser)/./constants/contractABI.ts\");\n/* harmony import */ var _components_ui_input__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/ui/input */ \"(app-pages-browser)/./components/ui/input.tsx\");\n/* harmony import */ var _components_ui_textarea__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/ui/textarea */ \"(app-pages-browser)/./components/ui/textarea.tsx\");\n/* harmony import */ var _components_ui_button__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/ui/button */ \"(app-pages-browser)/./components/ui/button.tsx\");\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-router-dom */ \"(app-pages-browser)/./node_modules/react-router/dist/index.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst Page = ()=>{\n    _s();\n    const navigate = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_8__.useNavigate)();\n    const { register, handleSubmit } = (0,react_hook_form__WEBPACK_IMPORTED_MODULE_9__.useForm)();\n    const onSubmit = async (values)=>{\n        console.log(\"Hello\");\n        try {\n            if (window.ethereum) {\n                const web3 = new web3__WEBPACK_IMPORTED_MODULE_2__[\"default\"](window.ethereum);\n                await window.ethereum.enable();\n                const contract = new web3.eth.Contract(_constants_contractABI__WEBPACK_IMPORTED_MODULE_4__[\"default\"], _constants_global__WEBPACK_IMPORTED_MODULE_3__.contractAddress);\n                const accounts = await web3.eth.getAccounts();\n                const userAddress = accounts[0];\n                const userData = {\n                    _username: values.username,\n                    _userAddress: userAddress,\n                    _bio: values.bio\n                };\n                await contract.methods.registerUser(userData._username, userData._bio).send({\n                    from: userAddress\n                });\n                console.log(\"Utilisateur enregistr\\xe9 avec succ\\xe8s sur la blockchain!\");\n                navigate(\"/\");\n            } else {\n                console.error(\"MetaMask n'est pas install\\xe9\");\n            }\n        } catch (error) {\n            console.error(\"Erreur lors de l'enregistrement de l'utilisateur sur la blockchain:\", error);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col justify-start gap-10\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                className: \"text-3xl font-bold text-light-2\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\benna\\\\Desktop\\\\blockbox_blockchain\\\\app\\\\(auth)\\\\onboarding\\\\page.tsx\",\n                lineNumber: 50,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                className: \" head-text font-bold text-light-2\",\n                children: \"Inscrivez-vous\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\benna\\\\Desktop\\\\blockbox_blockchain\\\\app\\\\(auth)\\\\onboarding\\\\page.tsx\",\n                lineNumber: 51,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"flex text-xl text-light-2\",\n                children: \"Rejoignez des milliers d'utilisateurs sur le r\\xe9seau Ethereum\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\benna\\\\Desktop\\\\blockbox_blockchain\\\\app\\\\(auth)\\\\onboarding\\\\page.tsx\",\n                lineNumber: 52,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center gap-3 w-full\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        htmlFor: \"username\",\n                        className: \"text-base-semibold text-light-2\",\n                        children: \"Username\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\benna\\\\Desktop\\\\blockbox_blockchain\\\\app\\\\(auth)\\\\onboarding\\\\page.tsx\",\n                        lineNumber: 54,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_input__WEBPACK_IMPORTED_MODULE_5__.Input, {\n                        type: \"text\",\n                        id: \"username\",\n                        className: \"text-light-2 bg-dark-1\",\n                        ...register(\"username\")\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\benna\\\\Desktop\\\\blockbox_blockchain\\\\app\\\\(auth)\\\\onboarding\\\\page.tsx\",\n                        lineNumber: 57,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\benna\\\\Desktop\\\\blockbox_blockchain\\\\app\\\\(auth)\\\\onboarding\\\\page.tsx\",\n                lineNumber: 53,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center gap-3 w-full\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        htmlFor: \"bio\",\n                        className: \"text-base-semibold text-light-2\",\n                        children: \"Bio\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\benna\\\\Desktop\\\\blockbox_blockchain\\\\app\\\\(auth)\\\\onboarding\\\\page.tsx\",\n                        lineNumber: 65,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_textarea__WEBPACK_IMPORTED_MODULE_6__.Textarea, {\n                        rows: 5,\n                        id: \"bio\",\n                        className: \"text-light-2 bg-dark-1\",\n                        ...register(\"bio\")\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\benna\\\\Desktop\\\\blockbox_blockchain\\\\app\\\\(auth)\\\\onboarding\\\\page.tsx\",\n                        lineNumber: 68,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\benna\\\\Desktop\\\\blockbox_blockchain\\\\app\\\\(auth)\\\\onboarding\\\\page.tsx\",\n                lineNumber: 64,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_button__WEBPACK_IMPORTED_MODULE_7__.Button, {\n                onClick: handleSubmit(onSubmit),\n                className: \"bg-primary-500\",\n                children: \"Enregistrez-vous\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\benna\\\\Desktop\\\\blockbox_blockchain\\\\app\\\\(auth)\\\\onboarding\\\\page.tsx\",\n                lineNumber: 75,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\benna\\\\Desktop\\\\blockbox_blockchain\\\\app\\\\(auth)\\\\onboarding\\\\page.tsx\",\n        lineNumber: 49,\n        columnNumber: 9\n    }, undefined);\n};\n_s(Page, \"jfreZv/sc8X2UYhdCE9Fn1HUmYQ=\", false, function() {\n    return [\n        react_router_dom__WEBPACK_IMPORTED_MODULE_8__.useNavigate,\n        react_hook_form__WEBPACK_IMPORTED_MODULE_9__.useForm\n    ];\n});\n_c = Page;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Page);\nvar _c;\n$RefreshReg$(_c, \"Page\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC8oYXV0aCkvb25ib2FyZGluZy9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUMwQjtBQUMrQjtBQUNqQztBQUM2QjtBQUNIO0FBQ0o7QUFDTTtBQUNKO0FBQ0Q7QUFPL0MsTUFBTVMsT0FBaUI7O0lBQ25CLE1BQU1DLFdBQVdGLDZEQUFXQTtJQUM1QixNQUFNLEVBQUVHLFFBQVEsRUFBRUMsWUFBWSxFQUFFLEdBQUdYLHdEQUFPQTtJQUUxQyxNQUFNWSxXQUFzQyxPQUFPQztRQUMvQ0MsUUFBUUMsR0FBRyxDQUFDO1FBQ1osSUFBSTtZQUNBLElBQUlDLE9BQU9DLFFBQVEsRUFBRTtnQkFDakIsTUFBTUMsT0FBTyxJQUFJakIsNENBQUlBLENBQUNlLE9BQU9DLFFBQVE7Z0JBQ3JDLE1BQU1ELE9BQU9DLFFBQVEsQ0FBQ0UsTUFBTTtnQkFDNUIsTUFBTUMsV0FBVyxJQUFJRixLQUFLRyxHQUFHLENBQUNDLFFBQVEsQ0FBQ25CLDhEQUFXQSxFQUFFRCw4REFBZUE7Z0JBQ25FLE1BQU1xQixXQUFXLE1BQU1MLEtBQUtHLEdBQUcsQ0FBQ0csV0FBVztnQkFDM0MsTUFBTUMsY0FBY0YsUUFBUSxDQUFDLEVBQUU7Z0JBQy9CLE1BQU1HLFdBQVc7b0JBQ2JDLFdBQVdkLE9BQU9lLFFBQVE7b0JBQzFCQyxjQUFjSjtvQkFDZEssTUFBTWpCLE9BQU9rQixHQUFHO2dCQUNwQjtnQkFFQSxNQUFNWCxTQUFTWSxPQUFPLENBQUNDLFlBQVksQ0FBQ1AsU0FBU0MsU0FBUyxFQUFFRCxTQUFTSSxJQUFJLEVBQUVJLElBQUksQ0FBQztvQkFBRUMsTUFBTVY7Z0JBQVk7Z0JBRWhHWCxRQUFRQyxHQUFHLENBQUM7Z0JBQ1pOLFNBQVM7WUFDYixPQUFPO2dCQUNISyxRQUFRc0IsS0FBSyxDQUFDO1lBQ2xCO1FBQ0osRUFBRSxPQUFPQSxPQUFPO1lBQ1p0QixRQUFRc0IsS0FBSyxDQUFDLHVFQUF5RUE7UUFDM0Y7SUFDSjtJQUVBLHFCQUNJLDhEQUFDQztRQUFJQyxXQUFVOzswQkFDWCw4REFBQ0M7Z0JBQUdELFdBQVU7Ozs7OzswQkFDZCw4REFBQ0M7Z0JBQUdELFdBQVU7MEJBQW9DOzs7Ozs7MEJBQ2xELDhEQUFDRTtnQkFBR0YsV0FBVTswQkFBNEI7Ozs7OzswQkFDMUMsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FDWCw4REFBQ0c7d0JBQU1DLFNBQVE7d0JBQVdKLFdBQVU7a0NBQWtDOzs7Ozs7a0NBR3RFLDhEQUFDbEMsdURBQUtBO3dCQUNGdUMsTUFBSzt3QkFDTEMsSUFBRzt3QkFDSE4sV0FBVTt3QkFDVCxHQUFHNUIsU0FBUyxXQUFXOzs7Ozs7Ozs7Ozs7MEJBR2hDLDhEQUFDMkI7Z0JBQUlDLFdBQVU7O2tDQUNYLDhEQUFDRzt3QkFBTUMsU0FBUTt3QkFBTUosV0FBVTtrQ0FBa0M7Ozs7OztrQ0FHakUsOERBQUNqQyw2REFBUUE7d0JBQ0x3QyxNQUFNO3dCQUNORCxJQUFHO3dCQUNITixXQUFVO3dCQUNULEdBQUc1QixTQUFTLE1BQU07Ozs7Ozs7Ozs7OzswQkFHM0IsOERBQUNKLHlEQUFNQTtnQkFBQ3dDLFNBQVNuQyxhQUFhQztnQkFBVzBCLFdBQVU7MEJBQWlCOzs7Ozs7Ozs7Ozs7QUFLaEY7R0EvRE05Qjs7UUFDZUQseURBQVdBO1FBQ09QLG9EQUFPQTs7O0tBRnhDUTtBQWlFTiwrREFBZUEsSUFBSUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvKGF1dGgpL29uYm9hcmRpbmcvcGFnZS50c3g/OGU0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VGb3JtLCBTdWJtaXRIYW5kbGVyIH0gZnJvbSAncmVhY3QtaG9vay1mb3JtJztcclxuaW1wb3J0IFdlYjMgZnJvbSAnd2ViMyc7XHJcbmltcG9ydCB7IGNvbnRyYWN0QWRkcmVzcyB9IGZyb20gXCJAL2NvbnN0YW50cy9nbG9iYWxcIjtcclxuaW1wb3J0IGNvbnRyYWN0QUJJIGZyb20gXCJAL2NvbnN0YW50cy9jb250cmFjdEFCSVwiO1xyXG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJ0AvY29tcG9uZW50cy91aS9pbnB1dCc7XHJcbmltcG9ydCB7IFRleHRhcmVhIH0gZnJvbSAnQC9jb21wb25lbnRzL3VpL3RleHRhcmVhJztcclxuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnQC9jb21wb25lbnRzL3VpL2J1dHRvbic7XHJcbmltcG9ydCB7IHVzZU5hdmlnYXRlIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XHJcblxyXG5pbnRlcmZhY2UgRm9ybVZhbHVlcyB7XHJcbiAgICB1c2VybmFtZTogc3RyaW5nO1xyXG4gICAgYmlvOiBzdHJpbmc7XHJcbn1cclxuXHJcbmNvbnN0IFBhZ2U6IFJlYWN0LkZDID0gKCkgPT4ge1xyXG4gICAgY29uc3QgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xyXG4gICAgY29uc3QgeyByZWdpc3RlciwgaGFuZGxlU3VibWl0IH0gPSB1c2VGb3JtPEZvcm1WYWx1ZXM+KCk7XHJcblxyXG4gICAgY29uc3Qgb25TdWJtaXQ6IFN1Ym1pdEhhbmRsZXI8Rm9ybVZhbHVlcz4gPSBhc3luYyAodmFsdWVzKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJIZWxsb1wiKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LmV0aGVyZXVtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3ZWIzID0gbmV3IFdlYjMod2luZG93LmV0aGVyZXVtKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHdpbmRvdy5ldGhlcmV1bS5lbmFibGUoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IHdlYjMuZXRoLkNvbnRyYWN0KGNvbnRyYWN0QUJJLCBjb250cmFjdEFkZHJlc3MpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB3ZWIzLmV0aC5nZXRBY2NvdW50cygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlckFkZHJlc3MgPSBhY2NvdW50c1swXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIF91c2VybmFtZTogdmFsdWVzLnVzZXJuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIF91c2VyQWRkcmVzczogdXNlckFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgX2JpbzogdmFsdWVzLmJpb1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb250cmFjdC5tZXRob2RzLnJlZ2lzdGVyVXNlcih1c2VyRGF0YS5fdXNlcm5hbWUsIHVzZXJEYXRhLl9iaW8pLnNlbmQoeyBmcm9tOiB1c2VyQWRkcmVzcyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVXRpbGlzYXRldXIgZW5yZWdpc3Ryw6kgYXZlYyBzdWNjw6hzIHN1ciBsYSBibG9ja2NoYWluIScpO1xyXG4gICAgICAgICAgICAgICAgbmF2aWdhdGUoXCIvXCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTWV0YU1hc2sgblxcJ2VzdCBwYXMgaW5zdGFsbMOpJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJldXIgbG9ycyBkZSBsXFwnZW5yZWdpc3RyZW1lbnQgZGUgbFxcJ3V0aWxpc2F0ZXVyIHN1ciBsYSBibG9ja2NoYWluOicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGp1c3RpZnktc3RhcnQgZ2FwLTEwXCI+XHJcbiAgICAgICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBmb250LWJvbGQgdGV4dC1saWdodC0yXCI+PC9oMT5cclxuICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT1cIiBoZWFkLXRleHQgZm9udC1ib2xkIHRleHQtbGlnaHQtMlwiPkluc2NyaXZlei12b3VzPC9oMT5cclxuICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cImZsZXggdGV4dC14bCB0ZXh0LWxpZ2h0LTJcIj5SZWpvaWduZXogZGVzIG1pbGxpZXJzIGQndXRpbGlzYXRldXJzIHN1ciBsZSByw6lzZWF1IEV0aGVyZXVtPC9oMj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMyB3LWZ1bGxcIj5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwidXNlcm5hbWVcIiBjbGFzc05hbWU9XCJ0ZXh0LWJhc2Utc2VtaWJvbGQgdGV4dC1saWdodC0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgVXNlcm5hbWVcclxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8SW5wdXRcclxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ9XCJ1c2VybmFtZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1saWdodC0yIGJnLWRhcmstMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgey4uLnJlZ2lzdGVyKCd1c2VybmFtZScpfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTMgdy1mdWxsXCI+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cImJpb1wiIGNsYXNzTmFtZT1cInRleHQtYmFzZS1zZW1pYm9sZCB0ZXh0LWxpZ2h0LTJcIj5cclxuICAgICAgICAgICAgICAgICAgICBCaW9cclxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8VGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICByb3dzPXs1fVxyXG4gICAgICAgICAgICAgICAgICAgIGlkPVwiYmlvXCJcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LWxpZ2h0LTIgYmctZGFyay0xXCJcclxuICAgICAgICAgICAgICAgICAgICB7Li4ucmVnaXN0ZXIoJ2JpbycpfVxyXG4gICAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxCdXR0b24gb25DbGljaz17aGFuZGxlU3VibWl0KG9uU3VibWl0KX0gY2xhc3NOYW1lPVwiYmctcHJpbWFyeS01MDBcIj5cclxuICAgICAgICAgICAgICAgIEVucmVnaXN0cmV6LXZvdXNcclxuICAgICAgICAgICAgPC9CdXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGFnZTsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VGb3JtIiwiV2ViMyIsImNvbnRyYWN0QWRkcmVzcyIsImNvbnRyYWN0QUJJIiwiSW5wdXQiLCJUZXh0YXJlYSIsIkJ1dHRvbiIsInVzZU5hdmlnYXRlIiwiUGFnZSIsIm5hdmlnYXRlIiwicmVnaXN0ZXIiLCJoYW5kbGVTdWJtaXQiLCJvblN1Ym1pdCIsInZhbHVlcyIsImNvbnNvbGUiLCJsb2ciLCJ3aW5kb3ciLCJldGhlcmV1bSIsIndlYjMiLCJlbmFibGUiLCJjb250cmFjdCIsImV0aCIsIkNvbnRyYWN0IiwiYWNjb3VudHMiLCJnZXRBY2NvdW50cyIsInVzZXJBZGRyZXNzIiwidXNlckRhdGEiLCJfdXNlcm5hbWUiLCJ1c2VybmFtZSIsIl91c2VyQWRkcmVzcyIsIl9iaW8iLCJiaW8iLCJtZXRob2RzIiwicmVnaXN0ZXJVc2VyIiwic2VuZCIsImZyb20iLCJlcnJvciIsImRpdiIsImNsYXNzTmFtZSIsImgxIiwiaDIiLCJsYWJlbCIsImh0bWxGb3IiLCJ0eXBlIiwiaWQiLCJyb3dzIiwib25DbGljayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/(auth)/onboarding/page.tsx\n"));

/***/ })

});